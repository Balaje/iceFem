//Program to derive the time-domain solution.
verbosity=0;
macro dimension 2//EOM"
macro fspace 2//EOM"

include "macros.idp"
SolutionDir=getARGV("-solDir","THICKNESS_0");


macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM"

/*
//Gradient Recovery
macro Sigma(ux,uy,vx,vy)[2*muhat*ux+lambdahat*(ux+vy),
2*muhat*vy+lambdahat*(ux+vy),
muhat*(uy+vx)]//EOM"

macro buildGRmat(){
varf vm(unused,v) = int2d(ThIce)(v);
varf vdx(u,v) = int2d(ThIce)(dx(u)*v);
varf vdy(u,v) = int2d(ThIce)(dy(u)*v);
real [int] Mlump = vm(0,Vh);
real [int] one(Vh.ndof); one = 1;
real [int] M1 = one./Mlump;
matrix dM1 = M1;
matrix Mdx = vdx(Vh,Vh);
Mx = dM1*Mdx;
matrix Mdy = vdy(Vh,Vh);
My = dM1*Mdy;
}//EOM"
*/

macro readFile(rows,cols,filename,array){
    ifstream file(filename);
    for(int m=0; m<rows; m++)
        for(int n=0; n<cols; n++)
            file>>array(m,n);
}//Macro to read files.EOM"

//Set the problem and build the meshes
setProblem;
real botRight=-3.*tth, midPX=3.7*LL/4, midPY=-2.5*tth;
setMeshIce(botRight, midPX, midPY);
real midx=LL/2., midy=-0.5*HH, endy=-HH;
setMeshCav(midx, midy, endy);
refineMesh;//Refine Mesh.

Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
if(mpirank==0)
    cout<<"Solved Eigenvalue Problem"<<endl;

complex[int,int] mx(nev,Vh.ndof), my(nev,Vh.ndof);
for(int m=0; m<nev; m++)
 {
     Vh VX1=VX[m], VY1=VY[m];
     mx(m,:).re=VX1[];
     my(m,:).re=VY1[];
 }


//Import the interpolated coefficients.
int nfreq=getARGV("-nfreq",200);

complex[int,int] lambdaRe(nfreq,nev), lambdaIm(nfreq,nev);
readFile(nfreq,nev,SolutionDir+"2_ModesMatrix/Interpolated_L/lambdaRe.dat",lambdaRe);
readFile(nfreq,nev,SolutionDir+"2_ModesMatrix/Interpolated_L/lambdaIm.dat",lambdaIm);

complex[int,int] lambda=lambdaIm;
lambda*=1i;
lambda+=lambdaRe;

//Construct the solution again.
Vh<complex> ux,uy;
complex[int,int] UX(nfreq,Vh.ndof), UY(nfreq,Vh.ndof);
UX=lambda*mx;
UY=lambda*my;
complex[int,int] UXT=UX', UYT=UY';
UXT=conj(UXT);
UYT=conj(UYT);

complex[int,int] FAmp(3,nfreq);
readFile(3, nfreq,  "FAmp.dat", FAmp);
//Write time domain solution
real dt=50, T=10000;
real[int] time=-T:dt:T;

complex[int] domega(nfreq), omegaNew(nfreq);
omegaNew=FAmp(0,:);
domega=omegaNew(1:omegaNew.n);
domega-=omegaNew(0:omegaNew.n-1);
domega(omegaNew.n-1)=0;

//Phase
complex[int] randn(nfreq);
randn=FAmp(2,:);
//Find the complex solution.
complex[int] omegaVec(nfreq), u3x(Vh.ndof), u3y(Vh.ndof);

mesh Th1=emptymesh(ThIce);
fespace Vh1(Th1,P1);
buildParti(time.n);
complex[int] exx(Vh.ndof), exy(Vh.ndof), eyy(Vh.ndof);
complex[int] exxProc(Vh.ndof), exyProc(Vh.ndof), eyyProc(Vh.ndof);
for(int n=start; n<=stop; n++)
 {
     omegaVec=(-1i)*omegaNew;
     omegaVec*=time(n);
     omegaVec+=(-1i)*randn;
     omegaVec=exp(omegaVec);
     omegaVec=omegaVec.*FAmp(1,:);
     omegaVec=omegaVec.*domega;
     omegaVec*=(2*omegaNew.n/pi);

     u3x=UXT*omegaVec;
     u3y=UYT*omegaVec;

     Vh<complex> etax=u3x, etay=u3y;
     for(int m=0; m<ThIce.nv; m++)
     {         
         if(ThIce(m).label==3)
         {
             exxProc[m]=exxProc[m]+epsilon(etax,etax)[0](ThIce(m).x,ThIce(m).y)^2;
             eyyProc[m]=eyyProc[m]+epsilon(etay,etay)[1](ThIce(m).x,ThIce(m).y)^2;
             exyProc[m]=exyProc[m]+epsilon(etax,etay)[2](ThIce(m).x,ThIce(m).y)^2;             
         }

     }

     if(mpirank==0)
         cout<<"Time t="<<n<<endl;
 }
exxProc=sqrt(exxProc);
exxProc/=time.n;
exyProc=sqrt(exyProc);
exyProc/=time.n;
eyyProc=sqrt(eyyProc);
eyyProc/=time.n;
mpiAllReduce(exxProc,exx,mpiCommWorld,mpiSUM);
mpiAllReduce(exyProc,exy,mpiCommWorld,mpiSUM);
mpiAllReduce(eyyProc,eyy,mpiCommWorld,mpiSUM);
//Write the time domain L2--average.
{
    ofstream file(SolutionDir+"RMSStrain.dat");
    for(int m=0; m<ThIce.nv; m++){
        if(ThIce(m).label==3)
            file<<ThIce(m).x*Lc<<"\t"<<abs(exx[m])<<"\t"<<abs(exy[m])<<"\t"<<abs(eyy[m])<<endl;
    }
}
