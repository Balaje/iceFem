//Program to derive the time-domain solution.
verbosity=1;
include "macros.idp"
include "MPIplot.idp"
load "medit"
string solDir="1_BEDMAP2/";

macro readFile(rows,cols,filename,array){
  ifstream file(filename);
  for(int m=0; m<rows; m++)
    for(int n=0; n<cols; n++)
      file>>array(m,n);
}//Macro to read files.EOM"

macro readSolFile(filename,var){
  ifstream file(filename);
  file>>var;
}//EOM"

//Parameters are required.
int nborders=getARGV("-nborders",6);
iceBEDMAP2(nborders,0);

nev=64;
int nfreq=1000;
complex[int,int] lambdaRe(nfreq,nev), lambdaIm(nfreq,nev);
readFile(nfreq, nev, solDir+"2_ModesMatrix/Interpolated_L/lambdaRe.dat", lambdaRe);
readFile(nfreq, nev, solDir+"2_ModesMatrix/Interpolated_L/lambdaIm.dat", lambdaIm);
complex[int,int] lambda=lambdaIm;
lambda*=1i;
lambda+=lambdaRe;

complex[int,int] mx(nev,Vh.ndof), my(nev,Vh.ndof);
for(int m=0; m<nev; m++)  
  {
    complex[int] tmp(Vh.ndof);
    readSolFile(solDir+"2_Modes/MODEX"+m+".dat",tmp);
    mx(m,:)=tmp;
    readSolFile(solDir+"2_Modes/MODEY"+m+".dat",tmp);
    my(m,:)=tmp;
  }

complex[int,int] ux(nfreq,Vh.ndof), uy(nfreq,Vh.ndof);
ux=lambda*mx;
uy=lambda*my;
complex[int,int] uxt=ux', uyt=uy';
uxt=conj(uxt);
uyt=conj(uyt);
complex[int,int] FAmp(3,nfreq);
readFile(3, nfreq,  "FAmp.dat", FAmp);

//Write time domain solution
real dt=10, T=10000;
real[int] time=-T:dt:T;

//Extracting the frequency and the Fourier Transform vector.
complex[int] domega(nfreq), omegaNew(nfreq);
omegaNew=FAmp(0,:);
domega=omegaNew(1:omegaNew.n);
domega-=omegaNew(0:omegaNew.n-1);
domega(omegaNew.n-1)=0;

//Phase
complex[int] randn(nfreq);
randn=FAmp(2,:);


//Find the complex solution.
complex[int] omegaVec(nfreq), u3x(Vh.ndof), u3y(Vh.ndof);
int parti=time.n/mpisize;
int scaleFac=1;

macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM"

for(int n=mpirank*parti; n<mpirank*parti+parti; n++)
  {    
    omegaVec=(-1i)*omegaNew;
    omegaVec*=time(n);    
    omegaVec+=(-1i)*randn;    
    omegaVec=exp(omegaVec);    
    omegaVec=omegaVec.*FAmp(1,:);    
    omegaVec=omegaVec.*domega;
    omegaVec*=(2*omegaNew.n/pi);

    u3x=uxt*omegaVec;
    u3y=uyt*omegaVec;    

    Vh<complex> u=u3x, v=u3y;    
    int[int] Order=[1,1];    
    Vh<complex> Sigmavm = sqrt(Sigma(u,v)[0]*Sigma(u,v)[0]-Sigma(u,v)[0]*Sigma(u,v)[1]
                               +Sigma(u,v)[1]*Sigma(u,v)[1]+3*Sigma(u,v)[2]*Sigma(u,v)[2]);    
    Sigmavm[]*=Lc^2;
    savevtk(solDir+"2_TimeDomain/Disp/Redisp"+n+".vtk", ThIce, real(Sigmavm), [real(u),real(v)], dataname="Re(Sigmavm) Re(disp)", order=Order);        

    if(mpirank==0)
      cout<<"Writing file: "<<n<<" using Processor "<<mpirank<<endl;
  }
