//Program to derive the time-domain solution.
verbosity=0.;
include "macros.idp"
include "MPIplot.idp"
load "medit"
string solDir="1_BEDMAP2/";

macro readFile(rows,cols,filename,array){
  ifstream file(filename);
  for(int m=0; m<rows; m++)
    for(int n=0; n<cols; n++)
      file>>array(m,n);
}//Macro to read files.EOM"

macro readSolFile(filename,var){
  ifstream file(filename);
  file>>var;
}//EOM"

//Parameters are required.
int nborders=getARGV("-nborders",6);
iceBEDMAP2(nborders,0);

nev=4;
int nfreq=4;
complex[int,int] lambdaRe(nfreq,nev), lambdaIm(nfreq,nev);
readFile(nfreq, nev, solDir+"2_ModesMatrix/Interpolated_L/lambdaRe.dat", lambdaRe);
readFile(nfreq, nev, solDir+"2_ModesMatrix/Interpolated_L/lambdaIm.dat", lambdaIm);
complex[int,int] lambda=lambdaIm;
lambda*=1i;
lambda+=lambdaRe;

complex[int,int] mx(nev,Vh.ndof), my(nev,Vh.ndof);
for(int m=0; m<nev; m++)  
  {
    complex[int] tmp(Vh.ndof);
    readSolFile(solDir+"2_Modes/MODEX"+m+".dat",tmp);
    mx(m,:)=tmp;
    readSolFile(solDir+"2_Modes/MODEX"+m+".dat",tmp);
    my(m,:)=tmp;
  }

complex[int,int] ux(nfreq,Vh.ndof), uy(nfreq,Vh.ndof);
ux=lambda*mx;
uy=lambda*my;
complex[int,int] uxt=ux', uyt=uy';
uxt=conj(uxt);
uyt=conj(uyt);
complex[int,int] FAmp(2,nfreq);
readFile(2, nfreq,  "FAmp.dat", FAmp);

//Write time domain solution
real dt=20, T=5000;
real[int] time=-T:dt:T;

//Extracting the frequency and the Fourier Transform vector.
complex[int] domega(nfreq), omegaNew(nfreq);
omegaNew=FAmp(0,:);
if(mpirank==0)
  cout<<omegaNew<<endl;
domega=omegaNew(1:omegaNew.n);
domega-=omegaNew(0:omegaNew.n-1);
domega(omegaNew.n-1)=0;
if(mpirank==0)
  cout<<domega<<endl;

//Find the complex solution.
complex[int] omegaVec(nfreq), u3x(Vh.ndof), u3y(Vh.ndof);
int parti=time.n/mpisize;
for(int n=mpirank*parti; n<mpirank*parti+parti; n++)
  {    
    omegaVec=(-1i)*omegaNew;    
    omegaVec*=time(n);
    omegaVec=exp(omegaVec);    
    omegaVec=omegaVec.*FAmp(1,:);    
    omegaVec=omegaVec.*domega;    

    u3x=uxt*omegaVec;
    u3y=uyt*omegaVec;    

    Vh<complex> dispX=u3x, dispY=u3y;    
    mesh ThNewIce=movemesh(ThIce,[x+real(dispX),y+real(dispY)]);    
    int[int] Order=[1];
    savevtk(solDir+"2_TimeDomain/dispY"+n+".vtk",ThNewIce,real(dispY),dataname="vx",order=Order);       
  }
