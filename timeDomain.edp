//Program to derive the time-domain solution.
verbosity=1;
include "macros.idp"
include "MPIplot.idp"
load "medit"
string solDir="1_BEDMAP2/";

macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM"

/*
//Gradient Recovery
macro Sigma(ux,uy,vx,vy)[2*muhat*ux+lambdahat*(ux+vy),
2*muhat*vy+lambdahat*(ux+vy),
muhat*(uy+vx)]//EOM"

macro buildGRmat(){
varf vm(unused,v) = int2d(ThIce)(v);
varf vdx(u,v) = int2d(ThIce)(dx(u)*v);
varf vdy(u,v) = int2d(ThIce)(dy(u)*v);
real [int] Mlump = vm(0,Vh);
real [int] one(Vh.ndof); one = 1;
real [int] M1 = one./Mlump;
matrix dM1 = M1;
matrix Mdx = vdx(Vh,Vh);
Mx = dM1*Mdx;
matrix Mdy = vdy(Vh,Vh);
My = dM1*Mdy;
}//EOM"
*/

macro readFile(rows,cols,filename,array){
  ifstream file(filename);
  for(int m=0; m<rows; m++)
    for(int n=0; n<cols; n++)
      file>>array(m,n);
}//Macro to read files.EOM"

//Load the mesh
int nborders=getARGV("-nborders",6);
nev=64;
iceBEDMAP2(nborders,0);

Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
if(mpirank==0)
  cout<<"Solved Eigenvalue problem"<<endl;

complex[int,int] mx(nev,Vh.ndof), my(nev,Vh.ndof);
//real[int] tmp(Vh.ndof);
for(int m=0; m<nev; m++)
  {
    Vh VX1=VX[m], VY1=VY[m];
    mx(m,:).re=VX1[];
    my(m,:).re=VY1[];
  }

int nfreq=getARGV("-nfreq",200);
complex[int,int] lambdaRe(nfreq,nev), lambdaIm(nfreq,nev);
for(int m=0; m<nfreq; m++)
  {
    ifstream file(solDir+"2_ModesMatrix/lambdaj"+m+".dat");
    for(int n=0; n<nev; n++)
      file>>lambdaRe(m,n)>>lambdaIm(m,n);         
  }
complex[int,int] lambda=lambdaIm;
lambda*=1i;
lambda+=lambdaRe;

//Construct the solution again.
Vh<complex> ux,uy;
complex[int,int] UX(nfreq,Vh.ndof), UY(nfreq,Vh.ndof);
UX=lambda*mx;
UY=lambda*my;
complex[int,int] UXT=UX', UYT=UY';
UXT=conj(UXT);
UYT=conj(UYT);

complex[int,int] FAmp(3,nfreq);
readFile(3, nfreq,  "FAmp.dat", FAmp);
//Write time domain solution
real dt=50, T=10000;
real[int] time=-T:dt:T;

complex[int] domega(nfreq), omegaNew(nfreq);
omegaNew=FAmp(0,:);
domega=omegaNew(1:omegaNew.n);
domega-=omegaNew(0:omegaNew.n-1);
domega(omegaNew.n-1)=0;

//Phase
complex[int] randn(nfreq);
randn=FAmp(2,:);

//Find the complex solution.
complex[int] omegaVec(nfreq), u3x(Vh.ndof), u3y(Vh.ndof);
int parti=time.n/mpisize;

mesh Th1=emptymesh(ThIce);
fespace Vh1(Th1,P1);
for(int n=mpirank*parti; n<mpirank*parti+parti; n++)
  {
    omegaVec=(-1i)*omegaNew;
    omegaVec*=time(n);
    omegaVec+=(-1i)*randn;
    omegaVec=exp(omegaVec);
    omegaVec=omegaVec.*FAmp(1,:);
    omegaVec=omegaVec.*domega;
    omegaVec*=(2*omegaNew.n/pi);    
    
    u3x=UXT*omegaVec;
    u3y=UYT*omegaVec;    

    Vh<complex> etax=u3x, etay=u3y;
    int[int] Order=[1,1];
    savevtk(solDir+"/2_TimeDomain/sol1_"+n+".vtk",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
    savevtk(solDir+"/2_TimeDomain/sol2_"+n+".vtk",ThIce,[real(Sigma(etax,etay)[0]), real(Sigma(etax,etay)[1]), real(Sigma(etax,etay)[2])],[imag(Sigma(etax,etay)[0]), imag(Sigma(etax,etay)[1]), imag(Sigma(etax,etay)[2])],dataname="ReSigma ImSigma",order=Order);
    savevtk(solDir+"/ThCavity.vtk",ThCavity);

    ofstream file(solDir+"/2_Stresses/stressAtBdy"+n+".dat");
    for(int m=0; m<Th1.nv; m++){
      if(Th1(m).label==1)
	{
	  Vh1 sigmaxx=real(Sigma(etax,etay)[0]), sigmayy=real(Sigma(etax,etay)[1]), sigmaxy=real(Sigma(etax,etay)[2]);
	  file<<Th1(m).x<<"\t"<<Th1(m).y<<"\t"<<sigmaxx(Th1(m).x,Th1(m).y)<<"\t"<<sigmayy(Th1(m).x,Th1(m).y)<<"\t"<<sigmaxy(Th1(m).x,Th1(m).y)<<endl;	    
	}
    }

    if(mpirank==0)
      cout<<"Time t="<<n<<endl;
  }
