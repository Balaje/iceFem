/*
  WARNING:
  Should be run after splitting the meshes
  ff-mpirun -np 4 splitMesh.edp -hsize 0.02 -isBEDMAP 1
*/

verbosity=0;

include "macros.idp"

macro extractFS(fefunc, febdymesh, filename){
  ofstream file(filename);
  for(int m=0; m<febdymesh.nv; m++){
    if(febdymesh(m).y==0)
      file<<real(fefunc(febdymesh(m).x,0))<<"\t"<<imag(fefunc(febdymesh(m).x,0))<<"\n";
  }
}//EOM" End of macro to extract the Free Surface of the function .

macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM (Macro to define the stress tensor)"

real timeTaken;

NModes=5;
SolutionDir="1_BEDMAP2/";
real cpu=mpiWtime();
int isMesh= getARGV("-isMesh",1);
int nborders= getARGV("-nborders",4);

macro writeSolution(var, filename){
  ofstream file(filename);
  file<<var<<endl;
}//Tiny macro to write files

//Construct/Load the meshes.
real starttime=mpiWtime();
iceBEDMAP2(nborders,isMesh);
if(isMesh){
  refineMesh; //refine the meshes and overwrite the original meshes.
 }
splitMesh(isSplit);
real endtime=mpiWtime();
real difTime=endtime-starttime;
mpiReduce(difTime,timeTaken,processor(0),mpiMAX);
if(nborders!=4)
  dd=0.;

//Solve the dispersion equation.
solveDispersion;
if(mpirank==0)
  cout<<"Solved Dispersion Equation ... "<<endl;

matrix<complex> MQ;
complex[int] ctilde(NModes+1);
Wh<complex> chi1;
MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
for(int m=0; m<NModes+1; m++)
  chi1=chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

if(mpirank==0)
  cout<<"Obtained the nonlocal boundary condition"<<endl;

//Solve EigenValue problem
Xh[int][VX,VY](nev);
real[int] ev(nev);
starttime=mpiWtime();
readEigen;
endtime=mpiWtime();
difTime=endtime-starttime;
mpiReduce(difTime,timeTaken,processor(0),mpiMAX);
if(mpirank==0)
  cout<<"Time to solve Eigenvalue = "<<timeTaken<<" s"<<endl;

if(mpirank==0){
  cout<<"Number of ice    boundary DOFs = "<<ThEmptyIce.nv<<endl;
  cout<<"Number of cavity boundary DOFs = "<<ThEmptyCav.nv<<endl;
 }

//Solve for the Diffraction potential
Wh<complex> phi0;
func fh=chi1;
getLaplaceMatBEDMAP2(0,0);
LHS=STIMA+(MQ)+(-BMASSMA);
set(LHS,solver=UMFPACK,eps=1e-20);
phih[]=LHS^-1*RHS[];
phi0=phih;
WhBdy<complex> phi00=phi0;

Wh<complex>[int] phij(nev);
WhBdy<complex>[int] phijj(nev);
int parti, rem, start, stop, partisize;
buildParti;
complex[int,int] PHIJ(WhBdy.ndof,nev),PHIJProc(WhBdy.ndof,partisize);
starttime=mpiWtime();
for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    func fh=0;
    getLaplaceMatBEDMAP2(VX[m],VY[m]);
    LHS=STIMA+(MQ)+(-BMASSMA);
    set(LHS,solver=UMFPACK,eps=1e-20);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    phijj[m]=phih;
    PHIJProc(:,m-start)=phijj[m][];
  }
mpiAllgatherv(PHIJProc,PHIJ,rcounts,dspls);
endtime=mpiWtime();
difTime=endtime-starttime;
mpiReduce(difTime,timeTaken,processor(0),mpiSUM);
if(mpirank==0)
  cout<<"Time taken to solve potentials = "<<timeTaken/mpisize<<" s"<<endl;

//Unpack and set to phij locally in all procs
for(int m=0; m<nev; m++)
  phijj[m][]=PHIJ(m,:);

F.resize(nev);
B.resize(nev,nev);
K.resize(nev,nev);
AB.resize(nev,nev);
starttime=mpiWtime();
buildReducedSystemOptim;
endtime=mpiWtime();
difTime=endtime-starttime;
mpiReduce(difTime,timeTaken,processor(0),mpiMAX);
if(mpirank==0){
  cout<<"Time taken to build reduced system = "<<timeTaken<<" s"<<endl;
  writeReducedSystem;
 }

//Solve the reduced system.
solveReducedSystem;

//Compute the solution.
Vh <complex> etax, etay, etaxProc, etayProc;
Wh<complex> phi, phiProc;
for(int m=start; m<=stop; m++)
  {
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
  }

mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0){
  //Compute the reflection coefficient.
  cout<<"\n\n\n";
  cout<<"Non-Dim parameter Lc,Tc = "<<Lc<<","<<tc<<endl;
  phi=phi0+phi;

  //Write the reflection coefficient to a file.
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;
  ofstream file("1_BEDMAP2/2_RefCoeff/RefCoeff"+iter+".dat");
  file.precision(16);
  file<<real(Ref)<<"\t"<<imag(Ref)<<endl;

  //Write data to MATLAB
  //iter could be used to index the solution.

  Vh ux=real(etax), uy=real(etay);
  int[int] Order=[1,1];
  savevtk("1_BEDMAP2/sol1_"+iter+".vtk",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
  savevtk("1_BEDMAP2/sol2_"+iter+".vtk",ThIce,[real(Sigma(etax,etay)[0]), real(Sigma(etax,etay)[1]), real(Sigma(etax,etay)[2])],[imag(Sigma(etax,etay)[0]), imag(Sigma(etax,etay)[1]), imag(Sigma(etax,etay)[2])],dataname="ReSigma ImSigma",order=Order);
  savevtk("1_BEDMAP2/solCavity"+iter+".vtk",ThCavity,[real(phi),imag(phi)],dataname="RePhi ImPhi",order=Order);
 }

if(mpirank==0)
  cout<<"\nP: "<<mpirank<<" T = "<<mpiWtime()-cpu<<"\t s"<<endl;
