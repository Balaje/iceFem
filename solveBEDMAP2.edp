verbosity=0;

load "lapack"
include "macros.idp"

mpiRequest rq;

nev=20;
NModes=5;
real cpu=clock();
int isSolve= getARGV("-isMesh",0);
int nborders= getARGV("-nborders",4);

//Load the meshes.
iceBEDMAP2(nborders,isSolve);


if(mpirank==0){
  cout<<"Imported Ice Mesh (proc 0)..."<<endl;
  cout<<"Refining Ice Mesh (proc 0) ..."<<endl;
  cout<<"Ice : Before Refinement, NBV = "<<ThIce.nv<<endl;
  func metricFuncIce=0.02;
  ThIce=adaptmesh(ThIce,metricFuncIce,IsMetric=1,nbvx=2e6);
  cout<<"Ice : After Refinement, NBV = "<<ThIce.nv<<endl;
  plot(ThIce,wait=1);
 }
 else if(mpirank==1){
   cout<<"Imported Cavity Mesh (proc 1)..."<<endl;
   cout<<"Refining Cavity Mesh (proc 1) ..."<<endl;
   real LCav=abs(cavBegin-cavEnd)/Lc;
   func metricFuncCav=0.02;
   cout<<"Cavity : Before Refinement, NBV = "<<ThCavity.nv<<endl;
   ThCavity=adaptmesh(ThCavity,metricFuncCav,IsMetric=1,nbvx=2e6);
   cout<<"Cavity : After Refinement, NBV = "<<ThCavity.nv<<endl;
   plot(ThCavity,wait=1);
 }


mpiBarrier;

broadcast(processor(0),ThIce);
broadcast(processor(1),ThCavity);

//Solve the dispersion equation.
if(nborders!=4)
  dd=0.;

solveDispersion;
if(mpirank==0)
  cout<<"Solved Dispersion Equation ... "<<endl;


matrix<complex> MQ;
complex[int] ctilde(NModes+1);
MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
if(mpirank==0)
  cout<<"Obtained MQ (Proc "<<mpirank<<")"<<endl;
if(mpirank==1){
  ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
  cout<<"Obtained ctilde (Proc "<<mpirank<<")"<<endl;
 }
broadcast(processor(0),MQ);
broadcast(processor(1),ctilde);

Wh<complex> chi1;
for(int m=0; m<NModes+1; m++)
  chi1=chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

mpiWaitAll;
mpiBarrier;

//Solve EigenValue problem
Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
if(mpirank==0)
  cout<<"Solved EigenValue Problem ... "<<endl;

//Solve for the Diffraction potential
Wh<complex> phi0;

func fh=chi1;
getLaplaceMatBEDMAP2(0,0);
LHS=STIMA+(MQ)+(-BMASSMA);
set(LHS,solver=sparsesolver);
phih[]=LHS^-1*RHS[];
phi0=phih;
plot(phi0,wait=0,fill=1,value=1,dim=3);
if(mpirank==0){
  cout<<"Solved Diffraction Potential "<<endl<<endl;
 }
broadcast(processor(0),phi0[]);

//Things are done differently in the parallel version...
//1) Solve for the Radiation Potential and build the F[] vector in the reduced system
int partition = nev/mpisize;
Wh<complex>[int] phij(nev);
F.resize(nev);
B.resize(nev,nev);
K.resize(nev,nev);
AB.resize(nev,nev);
complex[int] B1(nev), B2(nev);
for(int m=mpirank*partition; m< mpirank*partition+partition; m++)
  {
    func fh=0;
    getLaplaceMatBEDMAP2(VX[m],VY[m]);
    LHS=STIMA+(MQ)+(-BMASSMA);
    set(LHS,solver=sparsesolver);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    F[m]=-(1i*omega*gammahat)*int1d(ThIce,1,qforder=10)(phi0*(VX[m]*N.x+VY[m]*N.y));
    for(int n=0; n<nev; n++)
      {
        B(m,n) = (rhoi*ev[m]-rhoi*omega^2)*int2d(ThIce)(VX[m]*VX[n]+VY[m]*VY[n]);
        K(n,m) = int1d(ThIce,1,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y));
      }


    if(mpirank!=0)
      {
        processor(0)<<phih[]<<F[m]<<B(m,:)<<K(:,m);
      }
    else if(mpirank==0)
      {
        for(int n=1; n<=mpisize-1; n++){
          processor(n)>>phih[]>>F[m+n*partition]>>B1>>B2;
          phij[m+n*partition][]=phih[];
          B(m+n*partition,:)=B1;
          K(:,m+n*partition)=B2;
        }
      }
    cout<<"Solved Radiation Potential ... "<<m+1<<"\t Proc: "<<mpirank<<endl;
  }

mpiBarrier;

//Build the reduced system and solve it.
if(mpirank==0){
  cout<<"Built the system... Solving ... "<<endl;

  complex[int] xi(nev);
  solveReducedSystem;

  //Compute the solution.
  Vh <complex> etax, etay;
  Wh<complex> phi;
  phi = phi0;
  for(int m=0; m<nev; m++)
    {
      phi = phi + xi[m]*phij[m];
      etax = etax + xi[m]*VX[m];
      etay = etay + xi[m]*VY[m];
    }

  mpiBarrier;

  //Compute the reflection coefficient.
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;

  mesh ThNewIce=movemesh(ThIce,[x+real(etax),y+real(etay)]);
  plot(ThNewIce,wait=1);
  Wh rphi=real(phi);
  Wh iphi=imag(phi);
  plot(rphi,wait=1,fill=1,value=1);

  //Write data to MATLAB
  //iter could be used to index the solution.
  Vh ux=real(etax), uy=real(etay);
  Vh iux=imag(etax), iuy=imag(etay);
  writeToMATLAB(ux,ThIce,"xDisp"+iter+".bb","meshIce"+iter+".msh");
  writeToMATLAB(uy,ThIce,"yDisp"+iter+".bb","meshIce"+iter+".msh");
  writeToMATLAB(iux,ThIce,"xDispI"+iter+".bb","meshIce"+iter+".msh");
  writeToMATLAB(iuy,ThIce,"yDispI"+iter+".bb","meshIce"+iter+".msh");
  writeToMATLAB(rphi,ThCavity,"potentialCav"+iter+".bb","meshCav"+iter+".msh");
  writeToMATLAB(iphi,ThCavity,"potentialCavI"+iter+".bb","meshCav"+iter+".msh");
  cout<<"Time = "<<clock()-cpu<<endl;
 }
