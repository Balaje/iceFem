/*
  WARNING:
  Should be run after splitting the meshes
  ff-mpirun -np 4 splitMesh.edp -hsize 0.02 -isBEDMAP 1
*/

verbosity=0;
macro dimension 2//EOM"
load "lapack"
include "macros.idp"
load "medit"
include "macro_ddm.idp"
include "ffddm_parameters.idp"
macro minimalMesh()square(2,2)//EOM
  include "ffddm_partitioning.idp"

  load "iovtk"

  nev=60;
NModes=5;
string SolutionDir="1_BEDMAP2/";
real cpu=mpiWtime();
int isSolve= getARGV("-isMesh",0);
int nborders= getARGV("-nborders",4);
iter=getARGV("-iter",0);

//Load the meshes.
iceBEDMAP2(nborders,isSolve);
ThIce=readmesh("MESHES_SPLIT/FullIce.msh");
ThCavity=readmesh("MESHES_SPLIT/FullCavity.msh");

if(nborders!=4)
  dd=0.;

//Solve the dispersion equation.
solveDispersion;
if(mpirank==0)
  cout<<"Solved Dispersion Equation ... "<<endl;

matrix<complex> MQ;
complex[int] ctilde(NModes+1);
Wh<complex> chi1;
MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
for(int m=0; m<NModes+1; m++)
  chi1=chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

//Solve EigenValue problem
string SolutionDir="1_BEDMAP2/"
Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
if(mpirank==0){
  writeEigen; 
  cout<<"Solved EigenValue Problem ... "<<endl;
  ofstream file("1_BEDMAP2/2_Modes/eval.dat");
  for(int m=0; m<nev; m++)
    file<<ev[m]<<endl;  
 }

//Solve for the Diffraction potential
Wh<complex> phi0;
func fh=chi1;
getLaplaceMatBEDMAP2(0,0);
LHS=STIMA+(MQ);
set(LHS,solver=UMFPACK,eps=1e-20);
phih[]=LHS^-1*RHS[];
phi0=phih;
plot(phi0,wait=0,fill=1,value=1,dim=3);
if(mpirank==0)
  cout<<"Solved Diffraction Potential "<<endl<<endl;


if(mpirank==0)
  {
    complex[int] phiVec(phi0.n), c(NModes+1);
    phiVec = phi0[]; //Get the vector form of the finite element function.
    complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"

    //Write the reflectiion coeffiecient to a file.
    ofstream file("1_BEDMAP2/2_RefCoeff/RefCoeff_Dif/refC"+iter+".dat");
    file.precision(16);
    file<<real(Ref)<<"\t"<<imag(Ref)<<endl;
  }

int parti = nev/mpisize;
Wh<complex>[int] phij(nev);
F.resize(nev);
B.resize(nev,nev);
K.resize(nev,nev);
AB.resize(nev,nev);
complex[int] FProc(nev), RefmProc(nev), Refm(nev);
complex[int,int] BProc(nev,nev), KProc(nev,nev);
complex[int,int] PHIJ(nev,Wh.ndof),PHIJProc(nev,Wh.ndof);
complex[int] phiVecm(Wh.ndof), cc(NModes+1), pk1(NModes+1);

for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    real cpu1=mpiWtime();
    func fh=0;
    getLaplaceMatBEDMAP2(VX[m],VY[m]);
    LHS=STIMA+(MQ);
    set(LHS,solver=UMFPACK,eps=1e-20);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    PHIJProc(m,:)=phij[m][];
    //Compute the radiation reflection coefficients
    pk1=0.;
    phiVecm = phij[m][];
    RefmProc[m] = getRefModes(ThCavity, NModes, kd, k, phiVecm, HH, dd, Ap, cc, pk1);
    if(mpirank==0)
      cout<<"P: "<<mpirank<<" S: "<<mpiWtime()-cpu1<<"s "<<endl;
  }
mpiAllReduce(PHIJProc,PHIJ,mpiCommWorld,mpiSUM)
mpiReduce(RefmProc,Refm,processor(0),mpiSUM);

//Unpack and set to phij locally in all procs
for(int m=0; m<nev; m++){
  phij[m][]=PHIJ(m,:);
 }

//Read the interpolate matrix;
matrix M1xM, M2xM;
{
  ifstream file1("./MESHES_SPLIT/M1xM"+mpirank+".dat");
  file1>>M1xM;
  ifstream file2("./MESHES_SPLIT/M2xM"+mpirank+".dat");
  file2>>M2xM;
}

mesh MaTh, M1aTh;
MaTh=readmesh("./MESHES_SPLIT/IceMaTh"+mpirank+".msh");
M1aTh=readmesh("./MESHES_SPLIT/CavityM1aTh"+mpirank+".msh");

real cpu1=mpiWtime();
buildReducedSystemOptim;
if(mpirank==0)
  cout<<"V : "<<MaTh.nv<<" T "<<mpirank<<" = "<<mpiWtime()-cpu1<<" s"<<endl;

if(mpirank==0) //Write the matrices to a file.
  {
    ofstream file1("1_BEDMAP2/2_ModesMatrix/ReH"+iter+".dat");
    ofstream file2("1_BEDMAP2/2_ModesMatrix/ImH"+iter+".dat");
    ofstream file3("1_BEDMAP2/2_ModesMatrix/ReF"+iter+".dat");
    ofstream file4("1_BEDMAP2/2_ModesMatrix/ImF"+iter+".dat");
    ofstream file5("1_BEDMAP2/2_RefCoeff/RefCoeff_Rad/refC"+iter+".dat");
    file1.precision(16);
    file2.precision(16);
    file3.precision(16);
    file4.precision(16);
    for(int m=0; m<nev; m++)
      {
        file3<<real(F[m])<<endl;
        file4<<imag(F[m])<<endl;
        file5<<real(Refm[m])<<"\t"<<imag(Refm[m])<<endl;
        for(int n=0; n<nev; n++)
          {
            file1<<real(B(m,n)+K(m,n))<<endl;
            file2<<imag(B(m,n)+K(m,n))<<endl;
          }
      }
  }

//Build the reduced system and solve it.
complex[int] xi(nev);
if(mpirank==0){
  cout<<"Built the system... Solving ... "<<endl;
  matrix<complex> Kmat, Bmat, ABmat;
  Kmat=K;
  Bmat=B;
  ABmat=AB;
  HHmat=Kmat+Bmat+ABmat;
  set(HHmat,solver=LU,eps=1e-20);
  xi=HHmat^-1*F;
  
  //Write solution vector to file.
  ofstream file1("1_BEDMAP2/2_ModesMatrix/lambdaj"+iter+".dat");
  file1.precision(16);
  for(int m=0; m<nev; m++)
    file1<<real(xi[m])<<"\t"<<imag(xi[m])<<endl;

 }
broadcast(processor(0),xi);

//Compute the solution.
Vh <complex> etax, etay, etaxProc, etayProc;
Wh<complex> phi, phiProc;
for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
  }

mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0){
  //Compute the reflection coefficient.
  phi=phi0+phi;

  //Write the reflection coefficient to a file.
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;
  ofstream file("1_BEDMAP2/2_RefCoeff/RefCoeff"+iter+".dat");
  file.precision(16);
  file<<real(Ref)<<"\t"<<imag(Ref)<<endl;

  mesh ThNewIce=movemesh(ThIce,[x+real(etax),y+real(etay)]);
  plot(ThNewIce,wait=1);
  Wh rphi=real(phi);
  Wh iphi=imag(phi);
  plot(rphi,wait=1,fill=1,value=1);

  //Write data to MATLAB
  //iter could be used to index the solution.
  Vh ux=real(etax), uy=real(etay);
  Vh iux=imag(etax), iuy=imag(etay);

  savevtk("1_BEDMAP2/ThIce.vtk",ThIce);
  savevtk("1_BEDMAP2/ThCavity.vtk",ThCavity);
  savevtk("1_BEDMAP2/ThNewIce"+iter+".vtk",ThNewIce);
  int[int] Order=[1];
  savevtk("1_BEDMAP2/rphi"+iter+".vtk",ThCavity,rphi,dataname="rphi",order=Order);
 }

if(mpirank==0)
  cout<<"\nProcessor: "<<mpirank<<" Total time = "<<mpiWtime()-cpu<<"\t s"<<endl;
