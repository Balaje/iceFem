verbosity=0;

load "lapack"
include "macros.idp"

nev=20;
NModes=5;

int isSolve= getARGV("-isMesh",0);
int nborders= getARGV("-nborders",4);

//Load the meshes.
iceBEDMAP2(nborders,isSolve);
cout<<"Imported Meshes ..."<<endl;

//Solve the dispersion equation.
dd=0;
solveDispersion;
cout<<"Solved Dispersion Equation ..."<<endl;

//Solve EigenValue problem
Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
cout<<"Solved EigenValue Problem ..."<<endl;

matrix<complex> MQ;
complex[int] ctilde(NModes+1);
MQ=getQphi(ThCavity,NModes,k,kd,HH,0,Ap,4);
ctilde=getChi(ThCavity,NModes,k,kd,HH,0,Ap);
Wh<complex> chi1;
for(int m=0; m<NModes+1; m++)
  chi1=chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-0));
cout<<"Obtained Non-Local boundary condition ..."<<endl;

//Solve for the Diffraction potential
Wh<complex> phi0;
func fh=chi1;
getLaplaceMatBEDMAP2(0,0);
LHS=STIMA+(-BMASSMA)+(MQ);
set(LHS,solver=sparsesolver);
phih[]=LHS^-1*RHS[];
phi0=phih;
plot(phi0,wait=0,fill=1,value=1,dim=3);
cout<<"Solved Diffraction Potential ..."<<endl<<endl;

//Solve for the Radiation Potential
Wh<complex>[int] phij(nev);
for(int m=0; m<nev; m++)
  {
    func fh=0;
    getLaplaceMatBEDMAP2(VX[m],VY[m]);
    LHS=STIMA+(-BMASSMA)+(MQ);
    set(LHS,solver=sparsesolver);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    plot(phij[m],wait=0,fill=1,value=1,dim=3);
    cout<<"Solved Radiation Potential ... "<<m+1<<endl;
  }

//Build the reduced system and solve it.
complex[int] c0(NModes+1);
complex[int,int] cc(NModes+1,nev);
c0=0.; cc=0.;
buildReducedSystem(VX,VY,phi0,phij,c0,cc,0.);
complex[int] xi(nev);
solveReducedSystem;

//Compute the solution.
Vh <complex> etax, etay;
Wh<complex> phi;
phi = phi0;
for(int m=0; m<nev; m++)
  {
    phi = phi + xi[m]*phij[m];
    etax = etax + xi[m]*VX[m];
    etay = etay + xi[m]*VY[m];
  }

//Compute the reflection coefficient.
complex[int] phiVec(phi.n), c(NModes+1);
phiVec = phi[]; //Get the vector form of the finite element function.
complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, 0, Ap, c); //From "refCoeff.idp"
cout.precision(16);
cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;

mesh ThNewIce=movemesh(ThIce,[x+real(etax),y+real(etay)]);
plot(ThNewIce,wait=1);
Wh rphi=real(phi);
Wh iphi=imag(phi);
plot(rphi,wait=1,fill=1,value=1);

//Write data to MATLAB
//iter could be used to index the solution.
Vh ux=real(etax), uy=real(etay);
Vh iux=imag(etax), iuy=imag(etay);
writeToMATLAB(ux,ThIce,"xDisp"+iter+".bb","meshIce"+iter+".msh")
writeToMATLAB(uy,ThIce,"yDisp"+iter+".bb","meshIce"+iter+".msh");
writeToMATLAB(iux,ThIce,"xDispI"+iter+".bb","meshIce"+iter+".msh");
writeToMATLAB(iuy,ThIce,"yDispI"+iter+".bb","meshIce"+iter+".msh");
writeToMATLAB(rphi,ThCavity,"potentialCav"+iter+".bb","meshCav"+iter+".msh");
writeToMATLAB(iphi,ThCavity,"potentialCavI"+iter+".bb","meshCav"+iter+".msh");
