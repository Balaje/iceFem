/*
  Module to get the matrices on the boundary of the domain.
*/

//function to compute the innerproduct on the interface.
func complex innerproduct(complex k, complex kappa, real H, real d)
{
  if(abs(k-kappa) >= 1e-7)
    {
      return ( (kappa*sin(kappa*(H-d))*cos(k*(H-d)) - k*cos(kappa*(H-d))*sin(k*(H-d)))/(kappa^2-k^2) );
    }
  else
    {
      return ( (H-d)/2 + sin(2*k*(H-d))/(4*k)  );
    }
}

// Get the elementary matrices associated with the innerproduct.
func int getMat(mesh &ThCavity, complex[int] k, complex[int] kd, real HH, real dd, complex Ap, int NModes, complex [int,int] &A, complex [int] &f, complex [int] &g, complex [int,int] &MM, complex [int,int] &MMt, complex [int, int] &D)
{
  // Initialize the matrices to 0
  A = 0.; MM = 0.; D = 0.; MMt = 0.; f = 0.; g = 0.;

  // Compute the matrices A,M,M^T and vectors f,g
  func phih0 = cos(k[0]*(y+HH))/cos(k[0]*HH);
  for(int m=0; m<NModes+1; m++)
    {
      func phidm = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
      func phim = cos(k[m]*(y+HH))/cos(k[m]*(HH));
      A(m,m) = k[m]*0.5*(cos(k[m]*HH)*sin(k[m]*HH) + k[m]*HH)/(k[m]*(cos(k[m]*HH))^2);
      f(m) = Ap*innerproduct(k[0], kd[m], HH, dd)/(cos(kd[m]*(HH-dd))*cos(k[0]*(HH)));

      for(int n=0; n<NModes+1; n++)
        {
          func phidn = cos(kd[n]*(y+HH))/cos(kd[n]*(HH-dd));
          func phin = cos(k[n]*(y+HH))/cos(k[n]*HH);

          MM(m,n) = innerproduct(k[n], kd[m], HH, dd)/(cos(kd[m]*(HH-dd))*cos(k[n]*(HH)));
          MMt(n,m) = MM(m,n);
        }
    }  
  g(0) = -Ap*A(0,0);

  // Find the matrix D.
  int nbv = ThCavity.nv;
  int nbe=ThCavity.nbe; //No of boundary elements
  real [int] interfacepoints(0); //Initialize as an empty array
  int [int] interfacenodes(0); //Initialize as an empty array
  int counter = 0;
  for(int m=0; m<nbv; m++)
    {
      if(ThCavity(m).x == 0)
        {
          interfacepoints.resize(interfacepoints.n + 1);
          interfacenodes.resize(interfacenodes.n + 1);
          interfacepoints(counter) = ThCavity(m).y;          
          interfacenodes(counter) = m;
          counter += 1;
        }
    }  
  counter = 0;
  // D is the DOF of the eigenfunctions at the interface.
  for(int m=0; m<interfacepoints.n; m++)
    for(int n=0; n<NModes+1; n++)
      D(interfacenodes[m],n) = cos(kd[n]*(interfacepoints[m] + HH))/cos(kd[n]*(HH-dd));

  return 0;
}
