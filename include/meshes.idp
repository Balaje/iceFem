/*
  IDP file for building meshes.
  Three different ways to build the meshes.
  1) Build linear thickening meshes.
  2) Build multiple piecewise spline meshes.
*/

//Macros for linear thickening meshes.
//1) Droughts (0,d1), (L,d2);
//2) Freeboards (0,f1), (L,f2);
//In non-dimensional units.
macro setLinearThickeningIce(draft1, draft2, free1, free2)
{
    int N1 = getARGV("-N",3);
    dd=abs(draft1);
    IFMACRO(dimension,3)
        if(mpirank==0){
            cout<<"Dimension should be 2 to use this routine with linear thickening. I am returning a uniform version instead."<<endl;
        }
    
        int[int] lb1=[3,2,1,1,1,1];
        ThIce=cube(LL/tth*N1,N1,N1,[LL*x,-dd+(tth)*y,tth*z],label=lb1); 
    ENDIFMACRO
    IFMACRO(dimension,2)
        real slope1=(free2-free1)/LL, slope2=(draft2-draft1)/LL;
        real intercept1=free1, intercept2=draft1;
        border I01(t=0,LL) {x=t; y=slope2*t+intercept2; label=3;};
        border I02(t=draft2,free2) {x=LL; y=t; label=2;};
        border I03(t=LL,0) {x=t; y=slope1*t+intercept1; label=1;};
        border I04(t=free1,draft1) {x=0; y=t; label=1;};
        ThIce = buildmesh(I01(LL/tth*N1)+I02(N1)+I03(LL/tth*N1)+I04(N1));
    ENDIFMACRO
    savemesh(ThIce,SolutionDir+"2_Modes/iceMesh.mesh");        
}//EOM"
macro setLinearThickeningCavity(Height1, Height2, draft1, draft2)
{
    int N1 = getARGV("-N",3);
    IFMACRO(dimension,3)
        if(mpirank==0){
            cout<<"Dimension should be 2 to use this routine with linear thickening. I am returning a uniform version instead."<<endl;
        }
        int[int] lb1=[1,6,3,4,1,1];
        ThCavity=cube(LL/tth*N1,N1,N1,[LL*x,-HH+(HH-dd)*y,tth*z],label=lb1); 
    ENDIFMACRO
        
    IFMACRO(dimension,2)
        real slope1=(draft2-draft1)/LL, slope2=(Height2-Height1)/LL;
        real intercept1=draft1, intercept2=Height1;
        border C01(t=0,LL) {x=t; y=slope2*t+intercept2+0*sin(pi*x/LL)*x/LL; label=1;};
        border C02(t=Height2,draft2) {x=LL; y=t; label=6;};
        border C03(t=LL,0) {x=t; y=slope1*t+intercept1; label=3;};
        border C04(t=draft1,Height1) {x=0; y=t; label=4;};
        ThCavity = buildmesh(C01(LL/tth*N1)+C02(N1)+C03(LL/tth*N1)+C04(LL/tth*N1));
    ENDIFMACRO
    savemesh(ThCavity,SolutionDir+"2_Modes/cavMesh.mesh");        
}//EOM"


//Macro to build the multiple spline part.
//Indicate the number of borders in the domains
// nborders = 4 for cavity region under the shelf.
// nborders = 6 for cavity region beyond the shelf.

/*
  Needs the following files about the geometry of the shelf and cavity.
  "./Meshes/BEDMAP2/iceCavInt_Breaks.dat"
  "./Meshes/BEDMAP2/iceCavInt_Coeffs.dat"
  "./Meshes/BEDMAP2/iceTop_Breaks.dat"
  "./Meshes/BEDMAP2/iceTop_Coeffs.dat"
  "./Meshes/BEDMAP2/cavBed_Breaks.dat"
  "./Meshes/BEDMAP2/cavBed_Coeffs.dat"
  These files are generated by the MATLAB code for the BEDMAP2 interface.
  Run the code bedMapProfile.m to get the data.
*/

macro iceBEDMAP2(nborders, isBuild)
{
    IFMACRO(dimension,3)
        cout<<"dimension should be 2 to use BEDMAP2 "<<endl;
        exit(1);
    ENDIFMACRO
    ifstream file("./Meshes/BEDMAP2/iceDat.dat");
    ifstream file1("./Meshes/BEDMAP2/iceCavInt_Breaks.dat");
    ifstream file2("./Meshes/BEDMAP2/iceCavInt_Coeffs.dat");
    ifstream file3("./Meshes/BEDMAP2/iceTop_Breaks.dat");
    ifstream file4("./Meshes/BEDMAP2/iceTop_Coeffs.dat");
    ifstream file5("./Meshes/BEDMAP2/cavBed_Breaks.dat");
    ifstream file6("./Meshes/BEDMAP2/cavBed_Coeffs.dat");

    real iceBegin, iceEnd, cavBegin, cavEnd, cavTop;
    int npieces, npieces1;

    file>>iceBegin>>iceEnd>>npieces>>cavBegin>>cavEnd>>npieces1>>cavTop;

    real[int,int] coefsBot(npieces,4), coefsTop(npieces,4), coefsCav(npieces1,4);
    real[int] breaksBot(npieces+1), breaksTop(npieces+1), breaksCav(npieces1+1);
    for(int m=0; m<npieces; m++) {
        file2>>coefsBot(m,0)>>coefsBot(m,1)>>coefsBot(m,2)>>coefsBot(m,3);
        file4>>coefsTop(m,0)>>coefsTop(m,1)>>coefsTop(m,2)>>coefsTop(m,3);
    }
    for(int m=0; m<npieces+1; m++) {
        file1>>breaksBot[m];
        file3>>breaksTop[m];
    }
    for(int m=0; m<npieces1; m++)
        file6>>coefsCav(m,0)>>coefsCav(m,1)>>coefsCav(m,2)>>coefsCav(m,3);
    for(int m=0; m<npieces1+1; m++)
        file5>>breaksCav[m];

    real L=abs(iceBegin-iceEnd);
    real H=abs(splineRecon(coefsCav,breaksCav,cavBegin,npieces1));
    real th=abs(splineRecon(coefsTop,breaksTop,iceBegin,npieces)-splineRecon(coefsBot,breaksBot,iceBegin,npieces));
    real d=abs(splineRecon(coefsBot,breaksBot,iceBegin,npieces));
    real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
    complex t = Tr+1i*Ti;
    real E, nu;
    real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
    real EI = E*th^3/(12*(1-nu^2));
    Lc = (EI/(rhow*ag))^(1./4.);
    tc = sqrt(rhow*Lc^6/(EI*H));
    omega = 2*pi/t;
    LL = L/Lc;
    HH = H/Lc;
    dd = d/Lc;
    tth = th/Lc;
    tt = t/tc;
    complex ndOmega = 2*pi/tt;
    alpha = HH*ndOmega^2;
    Ap = ag/(1i*omega)*Ad;
    real mu1 = elasCons[0], lambda = elasCons[1];
    muhat = mu1/Lc^2;
    lambdahat = lambda/Lc^2;
    gammahat = rhow/Lc;
    deltahat = rhow*ag/Lc;
    densRat = rhoi/rhow;

    if(isBuild)
    {
        if(nborders==4)
        {
            if(mpirank==0)
            {
                if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(5000)+C02(100)+C03(5000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
                else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03(2000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
            }
            else if(mpirank==1){
                cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
                real yy1=splineRecon(coefsCav,breaksCav,cavEnd,npieces1), yy2=splineRecon(coefsBot,breaksBot,cavEnd,npieces);
                border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
                border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),splineRecon(coefsBot,breaksBot,cavEnd,npieces)){x=cavEnd; y=t; label=1;};
                border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                border S04(t=splineRecon(coefsBot,breaksBot,iceBegin,npieces),splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=iceBegin; y=t; label=4;};
                ThCavity=buildmesh(S01(2000)+S02(100)+S03(2000)+S04(100));
                cout<<"Built Cavity-Mesh"<<endl;
            }
            broadcast(processor(0),ThIce);
            broadcast(processor(1),ThCavity);
        }
        else
        {
            if(mpirank==0)
            {
                if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(500)+C02(100)+C03(500)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
                else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    real widthFrac=getARGV("-notchWidth",0.005), heightFrac=getARGV("-notchHeight",0.0);
                    real locFrac = getARGV("-notchLoc",0.35);
                    real icelen=abs(iceBegin-iceEnd), crackloc=iceBegin+locFrac*icelen, crackwidth=icelen*widthFrac;
                    real crackheight=heightFrac*(splineRecon(coefsTop,breaksTop,crackloc,npieces)-splineRecon(coefsBot,breaksBot,crackloc,npieces));
                    cout<<"Notch Option Enabled. Height fraction="<<heightFrac<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces)-0*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(5000)+C01x(1000)+C02(100)+C03(5000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
            }
            else if(mpirank==1){
                cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
                real widthFrac=getARGV("-notchWidth",0.005), heightFrac=getARGV("-notchHeight",0.0);
                real locFrac = getARGV("-notchLoc",0.35);
                real icelen=abs(iceBegin-iceEnd), crackloc=iceBegin+locFrac*icelen, crackwidth=icelen*widthFrac;
                real crackheight=heightFrac*(splineRecon(coefsTop,breaksTop,crackloc,npieces)-splineRecon(coefsBot,breaksBot,crackloc,npieces));
                cout<<"Notch Option Enabled. Height fraction="<<heightFrac<<endl;
                border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
                border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),cavTop){x=cavEnd; y=t; label=1;};
                border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
                border S04(t=0,splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=0; y=t; label=4;};
                border S05(t=0,iceBegin){x=t; y=0; label=2;};
                border S06(t=0,splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                ThCavity=buildmesh(S01(500)+S02(200)+S03(500)+S04(600)+S05(-500)+S06(-100));
                cout<<"Built Cavity-Mesh"<<endl;
            }

            broadcast(processor(0),ThIce);
            broadcast(processor(1),ThCavity);
        }
        ThIce=movemesh(ThIce,[x*1./Lc,y*1./Lc]);
        ThCavity=movemesh(ThCavity,[x*1./Lc,y*1./Lc]);
        savemesh(ThCavity,SolutionDir+"2_Modes/cavMesh.msh");
        savemesh(ThIce,SolutionDir+"2_Modes/iceMesh.msh");
    }
    else
    {
        ThCavity=readmeshN(SolutionDir+"2_Modes/cavMesh.msh");
        ThIce=readmeshN(SolutionDir+"2_Modes/iceMesh.msh");
    }

}//EOM"

/*Macro to refine the mesh. Works on ThIce and ThCavity and refines the mesh
  The macros contain two options
  1) isUniRef to toggle uniform refinement. 
  True: Uniform refinement over the meshes
  False: To refine with the thickness of the ice. Start with a small value.
*/
macro refineMesh()
{
    if(mpirank==0){        
        cout<<"Imported Ice Mesh (proc 0)..."<<endl;
        cout<<"Refining Ice Mesh (proc 0) ..."<<endl;
        cout<<"Ice : Before Refinement, NBV = "<<ThIce.nv<<endl;       
        real metricFuncIce=getARGV("-hsize",0.1);
        ThIce=adaptmesh(ThIce,metricFuncIce,IsMetric=1,nbvx=2e6);        
        cout<<"Ice : After Refinement, NBV = "<<ThIce.nv<<endl;
        savemesh(ThIce,SolutionDir+"2_Modes/iceMesh.msh");        
    }
    else if(mpirank==1){
        cout<<"Cavity : Before Refinement, NBV = "<<ThCavity.nv<<endl;       
        real metricFuncCav=getARGV("-hsize",0.1);
        ThCavity=adaptmesh(ThCavity,metricFuncCav,IsMetric=1,nbvx=2e6);   
        cout<<"Cavity : After Refinement, NBV = "<<ThCavity.nv<<endl;
        savemesh(ThCavity,SolutionDir+"2_Modes/cavMesh.msh");
    }
    broadcast(processor(0),ThIce);
    broadcast(processor(1),ThCavity);
}//EOM"


//Macro to split the meshes using the FFDDM module
//Toggle splitting on and off using -isSplit option
IFMACRO(dimension,3)
bool isSplit = getARGV("-isSplit",0);
int[int] lbls=[3];
meshN MaThEmpty=ThIce;
meshN ThEmptyIce=ThIce;
meshN MaTh1=ThIce;
meshN ThEmptyCav=ThCavity;
fespace VhBdy(MaThEmpty,P1);
fespace WhBdy(ThEmptyCav,P1);
macro splitMesh(isSplit)
{
    if(isSplit){
        ffddmbuildDmesh(M,ThIce,mpiCommWorld);
        ffddmbuildDfespace(Fe,M,real,def,init,P1);
        MaThEmpty=MaTh[mpirank];
        MaTh1=MaTh[mpirank];
        if(mpirank==0)
            cout<<"Splitting on ... "<<endl;
        ThEmptyIce=ThIce;
        ThEmptyCav=ThCavity;
    }
    else
    {
        if(mpirank==0)
            cout<<"Splitting off ... "<<endl;
        MaThEmpty=ThIce;
        ThEmptyIce=ThIce;
        ThEmptyCav=ThCavity;
        MaTh1=ThIce;
    }
    if(mpirank==0){
        cout<<"Number of ice    boundary DOFs = "<<ThEmptyIce.nv<<endl;
        cout<<"Number of cavity boundary DOFs = "<<ThEmptyCav.nv<<endl;
    }
    cout<<"Number of boundary DOFs in Processor "<<mpirank<<" = "<<MaThEmpty.nv<<endl;
}//EOM" Split Mesh
ENDIFMACRO
//

IFMACRO(dimension,2)
bool isSplit = getARGV("-isSplit",0);
meshN MaThEmpty=emptymesh(ThIce);
meshN MaTh1=ThIce;
meshN ThEmptyIce=emptymesh(ThIce);
meshN ThEmptyCav=emptymesh(ThCavity);
fespace VhBdy(MaThEmpty,P1);
fespace WhBdy(ThEmptyCav,P1);
searchMethod = 2;
macro splitMesh(isSplit)
{
    if(isSplit){
        ffddmbuildDmesh(M,ThIce,mpiCommWorld);
        ffddmbuildDfespace(Fe,M,real,def,init,P1);
        MaThEmpty=emptymesh(MaTh[mpirank]);
        MaTh1=MaTh[mpirank];
        fespace MMh(MaThEmpty,P1);
        if(mpirank==0)
            cout<<"Splitting on ..."<<endl;
        ThEmptyIce=emptymesh(ThIce);
        ThEmptyCav=emptymesh(ThCavity);
    }
    else
    {
        if(mpirank==0)
            cout<<"Splitting off ..."<<endl;
        MaThEmpty=emptymesh(ThIce);
        ThEmptyIce=emptymesh(ThIce);
        ThEmptyCav=emptymesh(ThCavity);
        MaTh1=ThIce;
    }
}//Macro to SPLIT MESH
ENDIFMACRO

macro iceshelf2iceberg()
{    
    int[int] lbl=[3,3,2,1,1,1,1,1];
    ThIce=change(ThIce,label=lbl);
    lbl=[1,1,6,5,3,3,4,4];
    ThCavity=change(ThCavity,label=lbl);   
}//EOM"

// -- END of MESHES.idp
