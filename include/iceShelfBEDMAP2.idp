//Program to generate the meshes using the data from BEDMAP2

verbosity=0.;

load "lapack"
include "macros.idp"

int nborders=getARGV("-nborders",4);

//Define a set of file handlers
ifstream file("./Meshes/BEDMAP2/iceDat.dat");
ifstream file1("./Meshes/BEDMAP2/iceCavInt_Breaks.dat");
ifstream file2("./Meshes/BEDMAP2/iceCavInt_Coeffs.dat");
ifstream file3("./Meshes/BEDMAP2/iceTop_Breaks.dat");
ifstream file4("./Meshes/BEDMAp2/iceTop_Coeffs.dat");
ifstream file5("./Meshes/BEDMAP2/cavBed_Breaks.dat");
ifstream file6("./Meshes/BEDMAP2/cavBed_Coeffs.dat");

real iceBegin, iceEnd, cavBegin, cavEnd, cavTop;
int npieces, npieces1;
file>>iceBegin>>iceEnd>>npieces>>cavBegin>>cavEnd>>npieces1>>cavTop;

real[int,int] coefsBot(npieces,4), coefsTop(npieces,4), coefsCav(npieces1,4);
real[int] breaksBot(npieces+1), breaksTop(npieces+1), breaksCav(npieces1+1);

//Rough programming - Need to optimize.
for(int m=0; m<npieces; m++) {
  file2>>coefsBot(m,0)>>coefsBot(m,1)>>coefsBot(m,2)>>coefsBot(m,3);
  file4>>coefsTop(m,0)>>coefsTop(m,1)>>coefsTop(m,2)>>coefsTop(m,3);
 }
for(int m=0; m<npieces+1; m++) {
  file1>>breaksBot[m];
  file3>>breaksTop[m];
 }
for(int m=0; m<npieces1; m++)
  file6>>coefsCav(m,0)>>coefsCav(m,1)>>coefsCav(m,2)>>coefsCav(m,3);
for(int m=0; m<npieces1+1; m++)
  file5>>breaksCav[m];


//Build ice-mesh
border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};

mesh ThIce=buildmesh(C01(3000)+C02(200)+C03(3000)+C04(200));
plot(ThIce,wait=1);
savemesh(ThIce,"Meshes/iceMeshBEDMAP.msh");
cout<<"Built Ice-Mesh\n";

//Build cavity mesh
real y1=splineRecon(coefsCav,breaksCav,cavEnd,npieces1), y2=splineRecon(coefsBot,breaksBot,iceEnd,npieces);
real y3=splineRecon(coefsBot,breaksBot,iceBegin,npieces), y4=splineRecon(coefsCav,breaksCav,iceBegin,npieces1);
mesh ThCav=ThIce;
if(nborders==4)
  {
    border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
    border S02(t=y1,y2){x=(t-y1)/(y2-y1)*(iceEnd-cavEnd)+cavEnd; y=t; label=2;};
    border S03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
    border S04(t=y3,y4){x=(t-y3)/(y4-y3)*(cavBegin-iceBegin)+iceBegin; y=t; label=4;};
    ThCav=buildmesh(S01(3000)+S02(30)+S03(300)+S04(600));
  }
 else
   {
     border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
     //border S02(t=y1,y2){x=(t-y1)/(y2-y1)*(iceEnd-cavEnd)+cavEnd; y=t; label=2;};
     border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),cavTop){x=cavEnd; y=t; label=2;};
     border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
     border S04(t=splineRecon(coefsCav,breaksCav,cavBegin,npieces1),0){x=0; y=t; label=4;};
     border S05(t=0,iceBegin){x=t; y=0; label=5;};
     border S06(t=0,splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=6;};
     ThCav=buildmesh(S01(3000)+S02(200)+S03(3000)+S04(-600)+S05(-500)+S06(-100));
   }

savemesh(ThCav,"Meshes/cavMeshBEDMAP.msh");
cout<<"Built Cavity-Mesh";

plot(ThIce,ThCav,wait=1);

