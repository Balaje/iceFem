//Import everything from the include folder.
load "lapack"
include "getARGV.idp"

include "dispersionFreeSurface.idp"
include "getMatrices.idp"
include "spline.idp"
include "nonLocal.idp"
include "refCoeff.idp"
include "getProperties.idp"

load "Element_P3"

//List of useful set of macros.
macro grad(u) [dx(u),dy(u)]//EOM" //Gradient
macro div(u,v)(dx(u)+dy(v))//EOM" //Divergence of a vector field
macro epsilon(u,v)[dx(u), dy(v), (dy(u)+dx(v))/sqrt(2.)]//EOM" //Strain tensor components
macro bilinLap(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM"
macro bilinElas(u,v,uu,vv,a,b)(a*div(u,v)*div(uu,vv) + 2*b*epsilon(u,v)'*epsilon(uu,vv))//EOM"
macro ipScalar(u,v)(u*v)//EOM"
macro ipVector(u,v,uu,vv)(u*uu+v*vv)//EOM"

mesh ThIce=square(10,10);
mesh ThCavity=square(10,10);

fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1]);
fespace Wh(ThCavity,P1);

real lambdahat, muhat, rhoi;
real rhow, Ad;
real Lc, tc;
int iter, NModes=3, nev=20;
real LL,HH,dd,tth, ag;
real gammahat, deltahat, densRat;
complex omega, Ap, tt;
bool isUniformIce, isUniformCav;

complex [int] k(NModes+1), kd(NModes+1);
complex [int,int] B(nev,nev), K(nev,nev), AB(nev,nev), Hmat(nev,nev);
complex [int] F(nev);

macro setProblem()
{
  real L = getARGV("-L",20000.), H = getARGV("-H",500.), th = getARGV("-h",200.);
  iter=getARGV("-iter",0);
  real E, nu;
  real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
  real d = rhoi/rhow*th;
  real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
  complex t = Tr+1i*Ti;
  real EI = E*th^3/(12*(1-nu^2));
  Lc = (EI/(rhow*ag))^(1./4.);
  tc = sqrt(rhow*Lc^6/(EI*H));
  omega = 2*pi/t;
  LL = L/Lc;
  HH = H/Lc;
  dd = d/Lc;
  tth = th/Lc;
  tt = t/tc;  
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Ap = ag/(1i*omega)*Ad;
  real mu1 = elasCons[0], lambda = elasCons[1];
  muhat = mu1/Lc^2;
  lambdahat = lambda/Lc^2;
  gammahat = rhow/Lc;
  deltahat = rhow*ag/Lc;
  densRat = rhoi/rhow;
}//This is a macro for getting the parameters to set the problem

real iceBegin, iceEnd, cavBegin, cavEnd, cavTop;
macro iceBEDMAP2(nborders, isBuild)
{
  ifstream file("./Meshes/BEDMAP2/iceDat.dat");
  ifstream file1("./Meshes/BEDMAP2/iceCavInt_Breaks.dat");
  ifstream file2("./Meshes/BEDMAP2/iceCavInt_Coeffs.dat");
  ifstream file3("./Meshes/BEDMAP2/iceTop_Breaks.dat");
  ifstream file4("./Meshes/BEDMAp2/iceTop_Coeffs.dat");
  ifstream file5("./Meshes/BEDMAP2/cavBed_Breaks.dat");
  ifstream file6("./Meshes/BEDMAP2/cavBed_Coeffs.dat");

  int npieces, npieces1;
  file>>iceBegin>>iceEnd>>npieces>>cavBegin>>cavEnd>>npieces1>>cavTop;
  
  real[int,int] coefsBot(npieces,4), coefsTop(npieces,4), coefsCav(npieces1,4);
  real[int] breaksBot(npieces+1), breaksTop(npieces+1), breaksCav(npieces1+1);
  for(int m=0; m<npieces; m++) {
    file2>>coefsBot(m,0)>>coefsBot(m,1)>>coefsBot(m,2)>>coefsBot(m,3);
    file4>>coefsTop(m,0)>>coefsTop(m,1)>>coefsTop(m,2)>>coefsTop(m,3);
  }
  for(int m=0; m<npieces+1; m++) {
    file1>>breaksBot[m];
    file3>>breaksTop[m];
  }
  for(int m=0; m<npieces1; m++)
    file6>>coefsCav(m,0)>>coefsCav(m,1)>>coefsCav(m,2)>>coefsCav(m,3);
  for(int m=0; m<npieces1+1; m++)
    file5>>breaksCav[m];

  real L=abs(iceBegin-iceEnd);
  real H=abs(splineRecon(coefsCav,breaksCav,cavBegin,npieces1));
  real th=abs(splineRecon(coefsTop,breaksTop,iceBegin,npieces)-splineRecon(coefsBot,breaksBot,iceBegin,npieces));
  real d=abs(splineRecon(coefsBot,breaksBot,iceBegin,npieces));
  real E, nu;
  real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
  real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
  complex t = Tr+1i*Ti;
  real EI = E*th^3/(12*(1-nu^2));
  Lc = (EI/(rhow*ag))^(1./4.);
  tc = sqrt(rhow*Lc^6/(EI*H));
  omega = 2*pi/t;
  LL = L/Lc;
  HH = H/Lc;
  dd = d/Lc;
  tth = th/Lc;
  tt = t/tc;  
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Ap = ag/(1i*omega)*Ad;
  real mu1 = elasCons[0], lambda = elasCons[1];
  muhat = mu1/Lc^2;
  lambdahat = lambda/Lc^2;
  gammahat = rhow/Lc;
  deltahat = rhow*ag/Lc;
  densRat = rhoi/rhow;

  if(isBuild)
    {
      if(nborders==4)
        {
          if(mpirank==0){
            if(abs(cavEnd-iceEnd)<1e-5){
              cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
              border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
              border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
              border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
              border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
              ThIce=buildmesh(C01(5000)+C02(100)+C03(5000)+C04(100));
              cout<<"Built Ice-Mesh\n";
            }
            else {
              cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
              border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
              border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
              border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
              border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
              border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
              ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03(2000)+C04(100));
              cout<<"Built Ice-Mesh\n";
            }
          }
          else if(mpirank==1){
            cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
            real yy1=splineRecon(coefsCav,breaksCav,cavEnd,npieces1), yy2=splineRecon(coefsBot,breaksBot,cavEnd,npieces);
            border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
            border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),splineRecon(coefsBot,breaksBot,cavEnd,npieces)){x=cavEnd; y=t; label=2;};
            border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
            border S04(t=splineRecon(coefsBot,breaksBot,iceBegin,npieces),splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=iceBegin; y=t; label=4;};
            ThCavity=buildmesh(S01(2000)+S02(100)+S03(2000)+S04(100));
            cout<<"Built Cavity-Mesh"<<endl;
          }          
          
          broadcast(processor(0),ThIce);
          broadcast(processor(1),ThCavity);
        }
      else
        {
          if(mpirank==0){
            border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
            border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
            border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
            border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
            border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
            ThIce=buildmesh(C01(3000)+C01x(2000)+C02(100)+C03(5000)+C04(100));
            cout<<"Built Ice-Mesh\n";
          }
          else if(mpirank==1){
            border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
            border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),cavTop){x=cavEnd; y=t; label=2;};
            border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
            border S04(t=0,splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=0; y=t; label=4;};
            border S05(t=0,iceBegin){x=t; y=0; label=5;};
            border S06(t=0,splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=6;};
            ThCavity=buildmesh(S01(5000)+S02(200)+S03(5000)+S04(600)+S05(-500)+S06(-100));
            cout<<"Built Cavity-Mesh"<<endl;
          }          

          broadcast(processor(0),ThIce);
          broadcast(processor(1),ThCavity);
        }
      ThIce=movemesh(ThIce,[x*1./Lc,y*1./Lc]);
      ThCavity=movemesh(ThCavity,[x*1./Lc,y*1./Lc]);
      savemesh(ThCavity,"Meshes/cavMeshBEDMAP.msh");
      savemesh(ThIce,"Meshes/iceMeshBEDMAP.msh");
    }
  else
    {
      ThCavity=readmesh("Meshes/cavMeshBEDMAP.msh");
      ThIce=readmesh("Meshes/iceMeshBEDMAP.msh");
    }
}//This is a macro to obtain the ice-cavity profiles from BEDMAP2

macro solveDispersion()
{
  k.resize(NModes+1);
  kd.resize(NModes+1);
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  k = dispersionfreesurface(alpha, NModes, HH);
  k[0] = -k[0];
  kd = dispersionfreesurface(alpha, NModes, HH-dd);
  kd[0] = -kd[0];
}//Macro to solve the dispersion equations

real ix1, iy1, ix2, iy2, ix3, iy3;
real icetopleft=(1-densRat)*tth, icebottomleft=-(densRat)*tth, icebottomright;
isUniformIce=getARGV("-isUniIce",1);
macro setMeshIce(brx, midx, midy)
{
  int N1 = getARGV("-N",3);
  if(isUniformIce==true)
    {
      icetopleft = (1-rhoi/rhow)*tth;
      icebottomleft = -(rhoi/rhow)*tth;
      icebottomright = -(rhoi/rhow)*tth;
      ix2 = 3.7*LL/4;
      iy2 = -(rhoi/rhow)*tth;
    }
  else
    {
      icetopleft = (1-rhoi/rhow)*tth;
      icebottomleft = -(rhoi/rhow)*tth;
      icebottomright = -3.*tth;
      ix2 = midx;
      iy2 = midy;
    }
  ix1 = 0; iy1 = icebottomleft;
  ix3 = LL; iy3 = icebottomright;

  border I01(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=1;};
  border I02(t=iy3,icetopleft) {x=LL; y=t; label=2;};
  border I03(t=LL,0) {x=t; y=icetopleft; label=3;};
  border I04i(t=icetopleft,0) {x=0; y=t; label=4;};
  border I04ii(t=0,icebottomleft){x=0; y=t; label=5;};
  ThIce = buildmesh(I01(LL/tth*N1)+I02(N1)+I03(LL/tth*N1)+I04i(LL/tth*N1)+I04ii(LL/tth*N1));
}//This is a macro for creating the ice mesh using 3 point cubic spline.

isUniformCav=getARGV("-isUniCav",1);
macro setMeshCav(midx, midy, endy)
{
  int N2 = getARGV("-N",3);
  real x1,x2,x3,uy1,y2,y3;
  if(isUniformCav)
    {
      x1=0.; uy1=-HH;
      x2=LL/2; y2=-HH;
      x3=LL; y3=-HH;
    }
  else
    {
      x1=0.; uy1=-HH;
      x2=midx; y2=midy;
      x3=LL; y3=endy;
    }
  border C01(t=0,LL){x = t; y = splineCurve(t,x1,uy1,x2,y2,x3,y3); label=1;};
  border C02(t=y3,iy3) {x=LL; y=t; label=2;};
  border C03(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=3;};
  border C04(t=icebottomleft,uy1) {x=0; y=t; label=4;};
  ThCavity = buildmesh(C01(LL/tth*N2)+C02(N2)+C03(-LL/tth*N2)+C04(N2));
}//This is a macro for creating the cavity Mesh using 3 point cubic spline.

macro solveEigen()
{
  Xh [u,v],[uu,vv];  
  varf a([u,v],[uu,vv]) = int2d(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + on(2,u=0,v=0);
  varf b([u,v],[uu,vv]) = int2d(ThIce,qft=qf1pTlump)(rhoi*(u*uu + v*vv));
  matrix stima = a(Xh,Xh,solver=Crout,factorize=1);
  matrix massma = b(Xh,Xh,solver=CG,eps=1e-20);
  int kkk = EigenValue(stima,massma,sym=true,sigma=0,value=ev,vector=VX,tol=1e-10);  
}//This is a macro for solving the elasticity Eigenvalue problem.


real[int] mu(nev);
macro solveEigenEB()
{
  mu.resize(nev);
  func real[int] EBroots(int nev, real L)
  {
    real[int] RR(nev);
    real xbar = pi/(2.*L);
    RR=0.;
    int count=1;

    real f,difff;
    while(1>=0)
      {
        real tol=1e-9, error=1;
        real r=xbar, rr;
        while(error>tol)
          {
            f=cos(r*L)*cosh(r*L)+1;
            difff=L*cos(r*L)*sinh(r*L)-L*sin(r*L)*cosh(r*L);
            rr=r-f/difff;
            error=abs(r-rr);
            r=rr;
          }

        real eps=1e-10;
        if(abs(r-RR[count-1]) > eps)
          {
            RR[count-1]=r;
            count=count+1;
          }
        xbar=(count-0.5)*pi/L;
        if(count==nev+1)
          break;
      }
    return RR;
  }
  mu=EBroots(nev,LL);
}//This is a marco to compute the eigenmodes of the Euler Bernoulli equation


macro writeEigen()
{
  for(int m=0; m<nev; m++)
    {
      Vh modeX = VX[m];
      Vh modeY = VY[m];
      {
        ofstream file(SolutionDir+"2_Modes/modex"+m+".bb");
        file.precision(16);
        file<<"2 1 1 "<<modeX.n<<" 2 \n";
        for(int p=0; p<modeX[].n; p++)
          file<<modeX[][p]<<endl;
        ofstream file2(SolutionDir+"2_Modes/MODEX"+m+".dat");
        file2.precision(16);
        file2<<modeX[]<<endl;
      }
      {
        ofstream file(SolutionDir+"2_Modes/modey"+m+".bb");
        file.precision(16);
        file<<"2 1 1 "<<modeY.n<<" 2 \n";
        for(int p=0; p<modeY[].n; p++)
          file<<modeY[][p]<<endl;

        ofstream file2(SolutionDir+"2_Modes/MODEY"+m+".dat");
        file2.precision(16);
        file2<<modeY[]<<endl;
      }
    }
}//Macro to write the Eigenfunctions.


matrix<complex> STIMA,BMASSMA;
matrix<complex> LHS;
Wh<complex> RHS,phih;
macro getLaplaceMat(a,b){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the LE modes.

matrix<complex> BMASSMA1;
macro getLaplaceMatBEDMAP2(a,b){
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih) + int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  varf bFS(phih,psih) = int1d(ThCavity,5,qforder=10)(alpha*phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bFS(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS, MASS matrices and the RHS vector for the BEDMAP2 problem.

macro getLaplaceMatEB(m,rad){
  Wh<complex> psih;
  func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the EB modes.

macro getLaplaceMatFunc(eta){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih) + int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*eta*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as before, but for a general 1D function eta

macro getLaplaceMatDBC(a,b){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
  varf lh(unused,psih) = int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as above but for DBC.


macro getLaplaceMatEBdbc(m,rad){
  Wh<complex> psih;
  func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
  varf lh(unused,psih) = int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as above but for EB DBC.

macro buildReducedSystem(VX,VY,phi0,phij,c0,cc,isForcedFront)
{
  B.resize(nev,nev);
  K.resize(nev,nev);
  AB.resize(nev,nev);
  F.resize(nev);
  func phid = isForcedFront*(Ap*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                             c0[0]*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                             c0[1]*cos(k[1]*(y+HH))/cos(k[1]*HH) +
                             c0[2]*cos(k[2]*(y+HH))/cos(k[2]*HH) +
                             c0[3]*cos(k[3]*(y+HH))/cos(k[3]*HH) );
  for(int m=0; m<nev; m++)
    {

      F[m] = -(1i*omega*gammahat)*(int1d(ThIce,1,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y) ) +
                                   int1d(ThIce,5,qforder=10)( phid*(VX[m]*N.x + VY[m]*N.y) ));
      complex[int] cm=cc(:,m);
      func phiminus = isForcedFront*(Ap*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                                     cm[0]*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                                     cm[1]*cos(k[1]*(y+HH))/cos(k[1]*HH) +
                                     cm[2]*cos(k[2]*(y+HH))/cos(k[2]*HH) +
                                     cm[3]*cos(k[3]*(y+HH))/cos(k[3]*HH));

      for(int n=0; n<nev; n++)
        {
          B(m,n) = (rhoi*ev[m]-rhoi*omega^2)*int2d(ThIce)(VX[m]*VX[n] + VY[m]*VY[n]);
          K(n,m) = int1d(ThIce,1,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y)) +
            int1d(ThIce,5,qforder=10)((-isForcedFront*y*deltahat + phiminus*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y));
          AB(n,m) = 0;
        }
    }
}//Macro to build the reduced system for the linear elasticity case. (Needs to be generalized even further. User should just specify the wetted surface and this should be computed).

macro buildReducedSystemEB(mu, phi0, phij, alpha, beta, gamma)
{
  B.resize(nev,nev);
  K.resize(nev,nev);
  AB.resize(nev,nev);
  F.resize(nev);
  for(int m=0; m<nev; m++)
    {
      func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));

      B(m,m)=(1-gamma*alpha)*(cosh(LL*mu[m])*sin(LL*mu[m]) - cos(LL*mu[m])*sinh(LL*mu[m]) - (cos(LL*mu[m])^2*sinh(2*LL*mu[m]))/2 + (cosh(LL*mu[m])^2*sin(2*LL*mu[m]))/2 - LL*mu[m]*cos(LL*mu[m])^2 + LL*mu[m]*cosh(LL*mu[m])^2 + 2*LL*mu[m]*sin(LL*mu[m])*sinh(LL*mu[m]))/(mu[m]*(cos(LL*mu[m]) + cosh(LL*mu[m]))^2);
      K(m,m)=beta*mu[m]^4*B(m,m);
      F[m]= (1i)*(omega/ag)*int1d(ThCavity,3,qforder=10)(phi0*etaj);

      for(int n=0; n<nev; n++)
        {
          func etak = ((cos(LL*mu[n]) + cosh(LL*mu[n]))*(sin(mu[n]*x) + sinh(mu[n]*x)) - (sin(LL*mu[n]) + sinh(LL*mu[n]))*(cos(mu[n]*x) + cosh(mu[n]*x)))/(cos(LL*mu[n]) + cosh(LL*mu[n]));
          AB(n,m)= -(1i)*(omega/ag)*int1d(ThCavity,3,qforder=10)(phij[m]*etak);
        }
    }
}//Build the reduced system for the Euler Bernoulli case.


matrix<complex> HHmat;
macro solveReducedSystem(){
  matrix<complex> Kmat, Bmat, ABmat;
  Kmat = K;
  Bmat=B;
  ABmat=AB;
  HHmat=Kmat+Bmat+ABmat;
  set(HHmat,solver=sparsesolver,eps=1e-20);
  xi=HHmat^-1*F;
}//Macro to solve the reduced system

func eta = 0;
macro constructEBdisp()
{
  for(int m=0; m<nev; m++)
    {
      func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
      eta = eta + lambda[m]*etaj;
    }
}//Macro to construct the EB solution.


macro writeToMATLAB(uh,Th,solfilename,meshfilename)
{
  savemesh(Th,meshfilename);
  ofstream file(solfilename);
  file.precision(16);
  file<<"2 1 1 "<<uh.n<<" 2 \n";
  for(int m=0; m<uh[].n; m++)
    file<<uh[][m]<<endl;

}//Macro to write the mesh and solution data for MATLAB visualization.
