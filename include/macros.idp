//Import everything from the include folder.
load "lapack"
include "getARGV.idp"

include "dispersionFreeSurface.idp"
include "getMatrices.idp"
include "spline.idp"
include "nonLocal.idp"
include "refCoeff.idp"
include "getProperties.idp"

//List of useful set of macros.
macro grad(u) [dx(u),dy(u)]//EOM" //Gradient
macro div(u,v)(dx(u)+dy(v))//EOM" //Divergence of a vector field
macro epsilon(u,v)[dx(u), dy(v), (dy(u)+dx(v))/sqrt(2.)]//EOM" //Strain tensor components
macro bilinLap(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM"
macro bilinElas(u,v,uu,vv,a,b)(a*div(u,v)*div(uu,vv) + 2*b*epsilon(u,v)'*epsilon(uu,vv))//EOM"
macro ipScalar(u,v)(u*v)//EOM"
macro ipVector(u,v,uu,vv)(u*uu+v*vv)//EOM"


mesh ThIce=square(10,10);
mesh ThCavity=square(10,10);

fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1]);
fespace Wh(ThCavity,P1);

real lambdahat, muhat, rhoi;
real rhow, Ad;
real Lc, tc;
int NModes=3, nev=20, iter;
real LL,HH,dd, ag;
real gammahat, deltahat;

complex omega, Ap;
complex [int] k(NModes+1), kd(NModes+1);

complex [int,int] B(nev,nev), K(nev,nev), AB(nev,nev), Hmat(nev,nev);
complex [int] F(nev);

macro setProblem()
{
  bool isUniformIce=getARGV("-isUniIce",1);
  bool isUniformCav=getARGV("-isUniCav",1);
  int N1 = getARGV("-N",3), N2 = getARGV("-N",3);
  real L = getARGV("-L",20000.), H = getARGV("-H",500.), th = getARGV("-h",200.);
  iter=getARGV("-iter",0);
  real E, nu;
  real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
  real d = rhoi/rhow*th;
  real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
  complex t = Tr+1i*Ti;
  real EI = E*th^3/(12*(1-nu^2));
  Lc = (EI/(rhow*ag))^(1./4.);
  tc = sqrt(rhow*Lc^6/(EI*H));
  omega = 2*pi/t;
  LL = L/Lc;
  HH = H/Lc;
  dd = d/Lc;
  real tth = th/Lc;
  complex tt = t/tc, ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Ap = ag/(1i*omega)*Ad;
  k = dispersionfreesurface(alpha, NModes, HH);
  k[0] = -k[0];
  kd = dispersionfreesurface(alpha, NModes, HH-dd);
  kd[0] = -kd[0];
  real mu = elasCons[0], lambda = elasCons[1];
  muhat = mu/Lc^2;
  lambdahat = lambda/Lc^2;
  real icetopleft, icebottomleft, icebottomright, ix2, iy2;
  if(isUniformIce==true)
    {
      icetopleft = (1-rhoi/rhow)*(th/Lc);
      icebottomleft = -(rhoi/rhow)*(th/Lc);
      icebottomright = -(rhoi/rhow)*(th/Lc);
      ix2 = 3.7*LL/4;
      iy2 = -(rhoi/rhow)*(th/Lc);
    }
  else
    {
      icetopleft = (1-rhoi/rhow)*(th/Lc);
      icebottomleft = -(rhoi/rhow)*(th/Lc);
      icebottomright = -3.*th/Lc;
      ix2 = 3.7*LL/4;
      iy2 = -2.5*(th/Lc);
    }
  real ix1 = 0, iy1 = icebottomleft;
  real ix3 = LL, iy3 = icebottomright;
  border I01(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=1;};
  border I02(t=iy3,icetopleft) {x=LL; y=t; label=2;};
  border I03(t=LL,0) {x=t; y=icetopleft; label=3;};
  border I04i(t=icetopleft,0) {x=0; y=t; label=4;};
  border I04ii(t=0,icebottomleft){x=0; y=t; label=5;};
  ThIce = buildmesh(I01(L/th*N1)+I02(N1)+I03(L/th*N1)+I04i(L/th*N1)+I04ii(L/th*N1));
  real x1,x2,x3,uy1,y2,y3;
  if(isUniformCav)
    {
      x1=0.; uy1=-HH;
      x2=LL/2; y2=-HH;
      x3=LL; y3=-HH;
    }
  else
    {
      x1=0.; uy1=-HH;
      x2=LL/2; y2=-0.5*HH;
      x3=LL; y3=-HH;
    }
  border C01(t=0,LL){x = t; y = splineCurve(t,x1,uy1,x2,y2,x3,y3); label=1;};
  border C02(t=y3,iy3) {x=LL; y=t; label=2;};
  border C03(t=LL,0) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=3;};
  border C04(t=icebottomleft,uy1) {x=0; y=t; label=4;};
  ThCavity = buildmesh(C01(L/th*N2)+C02(N2)+C03(L/th*N2)+C04(N2));

  gammahat = rhow/Lc;
  deltahat = rhow*ag/Lc;
}//This is a macro for getting the parameters and creating the meshes.


macro solveEigen()
{
  Xh [u,v],[uu,vv];
  varf a([u,v],[uu,vv]) = int2d(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + on(2,u=0,v=0);
  varf b([u,v],[uu,vv]) = int2d(ThIce,qft=qf1pTlump)(rhoi*(u*uu + v*vv));
  matrix stima = a(Xh,Xh,solver=sparsesolver);
  matrix massma = b(Xh,Xh,solver=sparsesolver);
  int kkk = EigenValue(stima,massma,sym=true,sigma=0,value=ev,vector=VX,tol=1e-10);
}//This is a macro for solving the Eigenvalue problem.


macro writeEigen()
{
  for(int m=0; m<nev; m++)
    {
      Vh modeX = VX[m];
      Vh modeY = VY[m];
      {
        ofstream file(SolutionDir+"2_Modes/modex"+m+".bb");
        file.precision(16);
        file<<"2 1 1 "<<modeX.n<<" 2 \n";
        for(int p=0; p<modeX[].n; p++)
          file<<modeX[][p]<<endl;
        ofstream file2(SolutionDir+"2_Modes/MODEX"+m+".dat");
        file2.precision(16);
        file2<<modeX[]<<endl;
      }
      {
        ofstream file(SolutionDir+"2_Modes/modey"+m+".bb");
        file.precision(16);
        file<<"2 1 1 "<<modeY.n<<" 2 \n";
        for(int p=0; p<modeY[].n; p++)
          file<<modeY[][p]<<endl;

        ofstream file2(SolutionDir+"2_Modes/MODEY"+m+".dat");
        file2.precision(16);
        file2<<modeY[]<<endl;
      }
    }
}//Macro to write the Eigenfunctions.


matrix<complex> STIMA,BMASSMA;
matrix<complex> LHS;
Wh<complex> RHS,phih;
macro getLaplaceMat(a,b){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector .

macro getLaplaceMatDBC(a,b){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
  varf lh(unused,psih) = int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as above but for DBC


macro buildReducedSystem(VX,VY,phi0,phij,c0,cc,isForcedFront)
{  
  func phid = isForcedFront*(Ap*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                             c0[0]*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                             c0[1]*cos(k[1]*(y+HH))/cos(k[1]*HH) +
                             c0[2]*cos(k[2]*(y+HH))/cos(k[2]*HH) +
                             c0[3]*cos(k[3]*(y+HH))/cos(k[3]*HH) );  
  for(int m=0; m<nev; m++)
    {

      F[m] = -(1i*omega*gammahat)*(int1d(ThIce,1,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y) ) +
                                   int1d(ThIce,5,qforder=10)( phid*(VX[m]*N.x + VY[m]*N.y) ));      
      complex[int] cm=cc(:,m);      
      func phiminus = isForcedFront*(Ap*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                            cm[0]*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                            cm[1]*cos(k[1]*(y+HH))/cos(k[1]*HH) +
                            cm[2]*cos(k[2]*(y+HH))/cos(k[2]*HH) +
                            cm[3]*cos(k[3]*(y+HH))/cos(k[3]*HH));
      
      for(int n=0; n<nev; n++)
        {
          B(m,n) = (rhoi*ev[m]-rhoi*omega^2)*int2d(ThIce)(VX[m]*VX[n] + VY[m]*VY[n]);
          K(n,m) = (deltahat)*(int1d(ThIce,1,qforder=10)(-VY[m]*(VX[n]*N.x+VY[n]*N.y)) +
                               int1d(ThIce,5,qforder=10)(-isForcedFront*y*(VX[n]*N.x+VY[n]*N.y)));
          AB(n,m) = (1i*omega*gammahat)*( int1d(ThIce,1,qforder=10)(phij[m]*(VX[n]*N.x + VY[n]*N.y)) +
                                          int1d(ThIce,5,qforder=10)(phiminus*(VX[n]*N.x + VY[n]*N.y)) );
        }
    }
}//Macro to build the reduced system. (Needs to be generalized even further. User should just specify the wetted surface and this should be computed).


macro solveReducedSystem(){
  matrix<complex> Kmat, Bmat, ABmat;
  Kmat = K;
  Bmat=B;
  ABmat=AB;
  matrix<complex> HHmat=Kmat+Bmat+ABmat;
  set(HHmat,solver=UMFPACK);
  xi=HHmat^-1*F;
}//Macro to solve the reduced system
