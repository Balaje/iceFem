//Import everything from the include folder.
load "lapack"
load "medit"
load "iovtk"
include "getARGV.idp"
include "functions.idp"


include "macro_ddm.idp"
include "ffddm_parameters.idp"
include "ffddm_partitioning.idp"

macro def(u) u//EOM
macro init(u) u//EOM

string SolutionDir;

//List of useful set of macros.
IFMACRO(dimension,2)
macro grad(u) [dx(u),dy(u)]//EOM" //Gradient
macro div(u,v)(dx(u)+dy(v))//EOM" //Divergence of a vector field
macro epsilon(u,v)[dx(u), dy(v), (dy(u)+dx(v))/sqrt(2.)]//EOM" //Strain tensor components
cout<<"Dimension : 2"<<endl;
macro minimalMesh()square(2,2)//EOM
    meshN ThIce=minimalMesh;
meshN ThCavity=minimalMesh;
IFMACRO(fspace,1)
fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1]);
fespace Wh(ThCavity,P1);
ENDIFMACRO
IFMACRO(fspace,2)
    fespace Vh(ThIce,P2);
fespace Xh(ThIce,[P2,P2]);
fespace Wh(ThCavity,P2);
ENDIFMACRO
ENDIFMACRO

IFMACRO(dimension,3)
    macro grad(u) [dx(u),dy(u),dz(u)]//EOM" //Gradient
    macro epsilon(u,v,w)[dx(u),dy(v),dz(w),1/sqrt(2.)*(dy(u)+dx(v)),1/sqrt(2.)*(dz(u)+dx(w)),1/sqrt(2.)*(dz(v)+dy(w))]//Eom"
    macro div(u,v,w)(dx(u)+dy(v)+dz(w))//Eom"
    cout<<"Dimension : 3"<<endl;
macro minimalMesh()cube(1,1,1)//EOM
    meshN ThIce=minimalMesh;
meshN ThCavity=minimalMesh;
IFMACRO(fspace,1)
fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1,P1]);
fespace Wh(ThCavity,P1);
ENDIFMACRO
IFMACRO(fspace,2)
    fespace Vh(ThIce,P2);
fespace Xh(ThIce,[P2,P2,P2]);
fespace Wh(ThCavity,P2);
ENDIFMACRO
ENDIFMACRO


real[int] elasCons(2);
real lambdahat, muhat, rhoi;
real rhow, Ad;
real L, H, th;
real Lc, tc;
real E, nu;
int NModes=3, nev=getARGV("-nev",16);
real LL,HH,dd,tth, ag;
real gammahat, deltahat, densRat;
complex omega, Ap, tt;
bool isUniformIce, isUniformCav;
string iter=getARGV("-iter","0");

complex [int] k(NModes+1), kd(NModes+1);
complex [int,int] B(nev,nev), K(nev,nev), AB(nev,nev), Hmat(nev,nev);
complex [int] F(nev);

macro getNonDimConstants()
{    
    elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);    
    real EI = E*th^3/(12*(1-nu^2));    
    Lc = (EI/(rhow*ag))^(1./4.);
    tc = sqrt(rhow*Lc^6/(EI*H));
}//EOM"

macro setProblem()
{
    L = getARGV("-L",20000.);
    H = getARGV("-H",500.);
    th = getARGV("-h",200.);        
    real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
    complex t = Tr+1i*Ti;
    getNonDimConstants;
    real d = rhoi/rhow*th;
    omega = 2*pi/t;
    LL = L/Lc;
    HH = H/Lc;
    dd = d/Lc;
    tth = th/Lc;
    tt = t/tc;
    complex ndOmega = 2*pi/tt;
    complex alpha = HH*ndOmega^2;
    Ap = ag/(1i*omega)*Ad;
    real mu1 = elasCons[0], lambda = elasCons[1];
    muhat = mu1/Lc^2;
    lambdahat = lambda/Lc^2;
    gammahat = rhow/Lc;
    deltahat = rhow*ag/Lc;
    densRat = rhoi/rhow;
}//This is a macro for getting the parameters to set the problem

real iceBegin, iceEnd, cavBegin, cavEnd, cavTop;
macro iceBEDMAP2(nborders, isBuild)
{
    IFMACRO(dimension,3)
        cout<<"dimension should be 2 to use BEDMAP2 "<<endl;
    exit(0);
    ENDIFMACRO
        nev=getARGV("-nev",16);
    ifstream file("./Meshes/BEDMAP2/iceDat.dat");
    ifstream file1("./Meshes/BEDMAP2/iceCavInt_Breaks.dat");
    ifstream file2("./Meshes/BEDMAP2/iceCavInt_Coeffs.dat");
    ifstream file3("./Meshes/BEDMAP2/iceTop_Breaks.dat");
    ifstream file4("./Meshes/BEDMAP2/iceTop_Coeffs.dat");
    ifstream file5("./Meshes/BEDMAP2/cavBed_Breaks.dat");
    ifstream file6("./Meshes/BEDMAP2/cavBed_Coeffs.dat");

    int npieces, npieces1;
    file>>iceBegin>>iceEnd>>npieces>>cavBegin>>cavEnd>>npieces1>>cavTop;

    real[int,int] coefsBot(npieces,4), coefsTop(npieces,4), coefsCav(npieces1,4);
    real[int] breaksBot(npieces+1), breaksTop(npieces+1), breaksCav(npieces1+1);
    for(int m=0; m<npieces; m++) {
        file2>>coefsBot(m,0)>>coefsBot(m,1)>>coefsBot(m,2)>>coefsBot(m,3);
        file4>>coefsTop(m,0)>>coefsTop(m,1)>>coefsTop(m,2)>>coefsTop(m,3);
    }
    for(int m=0; m<npieces+1; m++) {
        file1>>breaksBot[m];
        file3>>breaksTop[m];
    }
    for(int m=0; m<npieces1; m++)
        file6>>coefsCav(m,0)>>coefsCav(m,1)>>coefsCav(m,2)>>coefsCav(m,3);
    for(int m=0; m<npieces1+1; m++)
        file5>>breaksCav[m];

    L=abs(iceBegin-iceEnd);
    H=abs(splineRecon(coefsCav,breaksCav,cavBegin,npieces1));
    th=abs(splineRecon(coefsTop,breaksTop,iceBegin,npieces)-splineRecon(coefsBot,breaksBot,iceBegin,npieces));
    d=abs(splineRecon(coefsBot,breaksBot,iceBegin,npieces));    
    real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
    complex t = Tr+1i*Ti;
    getNonDimConstants;
    omega = 2*pi/t;
    LL = L/Lc;
    HH = H/Lc;
    dd = d/Lc;
    tth = th/Lc;
    tt = t/tc;
    complex ndOmega = 2*pi/tt;
    complex alpha = HH*ndOmega^2;
    Ap = ag/(1i*omega)*Ad;
    real mu1 = elasCons[0], lambda = elasCons[1];
    muhat = mu1/Lc^2;
    lambdahat = lambda/Lc^2;
    gammahat = rhow/Lc;
    deltahat = rhow*ag/Lc;
    densRat = rhoi/rhow;

    if(isBuild)
    {
        if(nborders==4)
        {
            if(mpirank==0)
            {
                if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                    ThIce=buildmesh(C01(5000)+C02(100)+C03(5000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
                else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                    ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03(2000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
            }
            else if(mpirank==1){
                cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
                real yy1=splineRecon(coefsCav,breaksCav,cavEnd,npieces1), yy2=splineRecon(coefsBot,breaksBot,cavEnd,npieces);
                border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
                border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),splineRecon(coefsBot,breaksBot,cavEnd,npieces)){x=cavEnd; y=t; label=2;};
                border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                border S04(t=splineRecon(coefsBot,breaksBot,iceBegin,npieces),splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=iceBegin; y=t; label=4;};
                ThCavity=buildmesh(S01(2000)+S02(100)+S03(2000)+S04(100));
                cout<<"Built Cavity-Mesh"<<endl;
            }
            broadcast(processor(0),ThIce);
            broadcast(processor(1),ThCavity);
        }
        else
        {
            if(mpirank==0)
            {
                if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                    ThIce=buildmesh(C01(500)+C02(100)+C03(500)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
                else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    real widthFrac=getARGV("-notchWidth",0.005), heightFrac=getARGV("-notchHeight",0.0);
                    real icelen=abs(iceBegin-iceEnd), crackloc=iceBegin+0.35*icelen, crackwidth=icelen*widthFrac;
                    real crackheight=heightFrac*(splineRecon(coefsTop,breaksTop,crackloc,npieces)-splineRecon(coefsBot,breaksBot,crackloc,npieces));
                    cout<<"Notch Option Enabled. Height fraction="<<heightFrac<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=1;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces)-0*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                    ThIce=buildmesh(C01(5000)+C01x(1000)+C02(100)+C03(5000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
            }
            else if(mpirank==1){
                cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
                real widthFrac=getARGV("-notchWidth",0.005), heightFrac=getARGV("-notchHeight",0.0);
                real icelen=abs(iceBegin-iceEnd), crackloc=iceBegin+0.35*icelen, crackwidth=icelen*widthFrac;
                real crackheight=heightFrac*(splineRecon(coefsTop,breaksTop,crackloc,npieces)-splineRecon(coefsBot,breaksBot,crackloc,npieces));
                cout<<"Notch Option Enabled. Height fraction="<<heightFrac<<endl;
                border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
                border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),cavTop){x=cavEnd; y=t; label=2;};
                border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
                border S04(t=0,splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=0; y=t; label=4;};
                border S05(t=0,iceBegin){x=t; y=0; label=5;};
                border S06(t=0,splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=6;};
                ThCavity=buildmesh(S01(500)+S02(200)+S03(500)+S04(600)+S05(-500)+S06(-100));
                cout<<"Built Cavity-Mesh"<<endl;
            }

            broadcast(processor(0),ThIce);
            broadcast(processor(1),ThCavity);
        }
        ThIce=movemesh(ThIce,[x*1./Lc,y*1./Lc]);
        ThCavity=movemesh(ThCavity,[x*1./Lc,y*1./Lc]);
        savemesh(ThCavity,"Meshes/cavMeshBEDMAP.msh");
        savemesh(ThIce,"Meshes/iceMeshBEDMAP.msh");
    }
    else
    {
        ThCavity=readmeshN("Meshes/cavMeshBEDMAP.msh");
        ThIce=readmeshN("Meshes/iceMeshBEDMAP.msh");
    }
}//This is a macro to obtain the ice-cavity profiles from BEDMAP2

macro solveDispersion()
{
    k.resize(NModes+1);
    kd.resize(NModes+1);
    complex ndOmega = 2*pi/tt;
    complex alpha = HH*ndOmega^2;
    k = dispersionfreesurface(alpha, NModes, HH);
    k[0] = -k[0];
    kd = dispersionfreesurface(alpha, NModes, HH-dd);
    kd[0] = -kd[0];
}//Macro to solve the dispersion equations

real ix1, iy1, ix2, iy2, ix3, iy3;
real icetopleft=(1-densRat)*tth, icebottomleft=-(densRat)*tth, icebottomright;
isUniformIce=getARGV("-isUniIce",1);
macro setMeshIce(brx, midx, midy)
{
    IFMACRO(dimension,3)
        cout<<"dimension should be 2 to use the 2D mesh example"<<endl;
    exit(0);
    ENDIFMACRO

        int N1 = getARGV("-N",3);
    if(isUniformIce==true)
    {
        icetopleft = (1-rhoi/rhow)*tth;
        icebottomleft = -(rhoi/rhow)*tth;
        icebottomright = -(rhoi/rhow)*tth;
        ix2 = 3.7*LL/4;
        iy2 = -(rhoi/rhow)*tth;
    }
    else
    {
        icetopleft = (1-rhoi/rhow)*tth;
        icebottomleft = -(rhoi/rhow)*tth;
        icebottomright = -3.*tth;
        ix2 = midx;
        iy2 = midy;
    }
    ix1 = 0; iy1 = icebottomleft;
    ix3 = LL; iy3 = icebottomright;

    real widthFrac=getARGV("-notchWidth",0.005);
    real heightFrac=getARGV("-notchHeight",0.0);
    real crackheight=heightFrac*tth;
    real crackwidth=widthFrac*LL;
    real crackloc=getARGV("-notchLoc",0.5)*LL;

    border I01(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
    border I02(t=iy3,icetopleft) {x=LL; y=t; label=2;};
    border I03(t=LL,0) {x=t; y=icetopleft-0*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=1;};
    border I04(t=icetopleft,icebottomleft) {x=0; y=t; label=1;};
    ThIce = buildmesh(I01(LL/tth*N1)+I02(N1)+I03(LL/tth*N1)+I04(LL/tth*N1));
}//This is a macro for creating the ice mesh using 3 point cubic spline.

isUniformCav=getARGV("-isUniCav",1);
macro setMeshCav(midx, midy, endy)
{
    IFMACRO(dimension,3)
        cout<<"dimension should be 2 to use the 2D mesh example"<<endl;
    exit(0);
    ENDIFMACRO

        int N2 = getARGV("-N",3);
    real x1,x2,x3,uy1,y2,y3;
    if(isUniformCav)
    {
        x1=0.; uy1=-HH;
        x2=LL/2; y2=-HH;
        x3=LL; y3=-HH;
    }
    else
    {
        x1=0.; uy1=-HH;
        x2=midx; y2=midy;
        x3=LL; y3=endy;
    }

    real widthFrac=getARGV("-notchWidth",0.005);
    real heightFrac=getARGV("-notchHeight",0.0);
    real crackheight=heightFrac*tth;
    real crackwidth=widthFrac*LL;
    real crackloc=getARGV("-notchLoc",0.5)*LL;;


    border C01(t=0,LL){x = t; y = splineCurve(t,x1,uy1,x2,y2,x3,y3); label=1;};
    border C02(t=y3,iy3) {x=LL; y=t; label=1;};
    border C03(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
    border C04(t=icebottomleft,uy1) {x=0; y=t; label=4;};
    ThCavity = buildmesh(C01(LL/tth*N2)+C02(N2)+C03(-LL/tth*N2)+C04(N2));
}//This is a macro for creating the cavity Mesh using 3 point cubic spline.



//MACROS to import sample 3D meshes
macro setMeshIceCav3d()
{
    L=100;
    real BB=10, th=2.25;
    H=0.8*L;    
    getNonDimConstants;
    LL=L/Lc;
    dd=0;
    HH=H/Lc;
    real mu1=elasCons[0], lambda=elasCons[1];
    muhat=mu1/Lc^2;
    lambdahat=lambda/Lc^2;
    gammahat = rhow/Lc;
    deltahat = rhow*ag/Lc;
    real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
    complex t = Tr+1i*Ti;
    omega = 2*pi/t;
    Ap=(ag/(1i*omega))*Ad;
    IFMACRO(dimension,2)
        cout<<"Dimension should be 3 to use 3d meshes"<<endl;
    exit(0);
    ENDIFMACRO
        int N1 = getARGV("-N",3);
    int N2 = getARGV("-N",3);
    ThIce = readmesh3("MESHES/boat.mesh");
    ThCavity = readmesh3("MESHES/water.mesh");
    ThIce = movemesh(ThIce,[x/Lc,y/Lc,z/Lc]);
    ThCavity = movemesh(ThCavity,[x/Lc,y/Lc,z/Lc]);
    if(mpirank==0){
        cout<<"Number of Ice Vertices = "<<ThIce.nv<<endl;
        cout<<"Number of Cavity Vertices = "<<ThCavity.nv<<endl;
    }
}//EOM"


//Solve for the in--vacuo mode.
//Set the boundary 2-for clamped condition.
macro solveEigen()
{
    IFMACRO(dimension,2)
        if(mpirank==0){
            Xh [u,v],[uu,vv];
            varf a([u,v],[uu,vv]) = intN(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + on(2,u=0,v=0);
            varf b([u,v],[uu,vv]) = intN(ThIce,qft=qf1pTlump)((u*uu + v*vv));
            matrix stima = a(Xh,Xh,solver=Crout,factorize=1);
            matrix massma = b(Xh,Xh,solver=CG,eps=1e-20);
            int kkk = EigenValue(stima,massma,sym=true,sigma=0,value=ev,vector=VX,tol=1e-10);
        }
    ENDIFMACRO
        IFMACRO(dimension,3)
        if(mpirank==0){
            Xh [u,v,w],[uu,vv,ww];
            varf a([u,v,w],[uu,vv,ww]) = intN(ThIce)(lambdahat*div(u,v,w)*div(uu,vv,ww) + 2*muhat*epsilon(u,v,w)'*epsilon(uu,vv,ww)) + on(2,u=0,v=0,w=0);
            varf b([u,v,w],[uu,vv,ww]) = intN(ThIce,qft=qf1pTlump)((u*uu + v*vv + w*ww));
            matrix stima = a(Xh,Xh,solver=sparsesolver);
            matrix massma = b(Xh,Xh,solver=sparsesolver);
            int kkk = EigenValue(stima,massma,value=ev,vector=VX,tol=1e-10);
        }
    ENDIFMACRO
        for(int m=0; m<nev; m++)
            broadcast(processor(0),VX[m][]);
}//This is a macro for solving the elasticity Eigenvalue problem.

macro writeEigen(isVtk, isDat)
{
    int[int] Order1=[1,1];
    ofstream fileEigen(SolutionDir+"/2_Modes/eval.dat");
    for(int m=0; m<nev; m++)
    {
        fileEigen<<ev[m]<<endl;;
        if(isVtk)
        {
            Vh modeX=VX[m],modeY=VY[m];
            IFMACRO(dimension,2)
                savevtk(SolutionDir+"2_Modes/Modes"+m+".vtk",ThIce,[modeX,modeY],dataname="ReMode",order=Order1);
            ENDIFMACRO

                IFMACRO(dimension,3)
                int[int] Order1=[1,1,1];
            Vh modeZ=VZ[m];
            savevtk(SolutionDir+"2_Modes/Modes"+m+".vtu",ThIce,[modeX,modeY,modeZ],dataname="ReMode",order=Order1);
            ENDIFMACRO
                }
        if(isDat)
        {
            ofstream fileX(SolutionDir+"2_Modes/ModesX"+m+".dat");
            fileX<<VX[m][];
            ofstream fileY(SolutionDir+"2_Modes/ModesY"+m+".dat");
            fileY<<VY[m][];
            IFMACRO(dimension,3)
                ofstream fileZ(SolutionDir+"2_Modes/ModesZ"+m+".dat");
            fileZ<<VZ[m][];
            ENDIFMACRO
                }
    }
}//Macro to write the Eigenfunctions to a file.

macro readEigen()
{
    if(mpirank==0){
        ifstream fileEigen(SolutionDir+"2_Modes/eval.dat");
        for(int m=0; m<nev; m++)
        {
            fileEigen>>ev[m];
            ifstream fileX(SolutionDir+"2_Modes/ModesX"+m+".dat");
            fileX>>VX[m][];
            ifstream fileY(SolutionDir+"2_Modes/ModesY"+m+".dat");
            fileY>>VY[m][];
        }
    }
    broadcast(processor(0),ev);
    for(int m=0; m<nev; m++)
        broadcast(processor(0),VX[m][]);
}//EOM To read eigenfunctions from a file"


macro refineMesh(){
    if(mpirank==0){
        real widthFrac=getARGV("-notchWidth",0.005);
        real heightFrac=getARGV("-notchHeight",0.0);
        real crackheight=heightFrac*tth;
        real crackwidth=widthFrac*LL;
        real crackloc=getARGV("-notchLoc",0.5)*LL;
        cout<<"Imported Ice Mesh (proc 0)..."<<endl;
        cout<<"Refining Ice Mesh (proc 0) ..."<<endl;
        cout<<"Ice : Before Refinement, NBV = "<<ThIce.nv<<endl;
        int isUniformRef=getARGV("-isUniRef",1);
        if(!isUniformRef){
            real metricFuncIce=getARGV("-hsize",0.02);
            ThIce=adaptmesh(ThIce,metricFuncIce*(0.1*tth-splineCurve(x,0,-0.9*tth,LL/2,-0.9*tth,LL,-0.9*tth)-1*crackheight*exp(-(x-crackloc)^2/(2*crackwidth^2))),IsMetric=1,nbvx=2e6);
        }
        else if(isUniformRef){
            real metricFuncIce=getARGV("-hsize",0.02);
            ThIce=adaptmesh(ThIce,metricFuncIce,IsMetric=1,nbvx=2e6);
        }
        cout<<"Ice : After Refinement, NBV = "<<ThIce.nv<<endl;
        savemesh(ThIce,"Meshes/iceMeshBEDMAP.msh");
        plot(ThIce,wait=1);
    }
    else if(mpirank==1){
        real widthFrac=getARGV("-notchWidth",0.005);
        real heightFrac=getARGV("-notchHeight",0.0);
        real crackheight=heightFrac*tth;
        real crackwidth=widthFrac*LL;
        real crackloc=getARGV("-notchLoc",0.5)*LL;
        cout<<"Imported Cavity Mesh (proc 1)..."<<endl;
        cout<<"Refining Cavity Mesh (proc 1) ..."<<endl;
        cout<<"Cavity : Before Refinement, NBV = "<<ThCavity.nv<<endl;
        real LCav=abs(cavBegin-cavEnd)/Lc;
        int isUniformRef=getARGV("-isUniRef",1);
        if(!isUniformRef){
            real metricFuncCav=getARGV("-hsize",0.01);
            ThCavity=adaptmesh(ThCavity,0.5*metricFuncCav*(0.1*tth-splineCurve(x,0,-HH,LL/2,-HH,LL,-HH)-1*crackheight*exp(-(x-crackloc)^2/(2*crackwidth^2))),IsMetric=1,nbvx=2e6);
        }
        else if(isUniformRef){
            real metricFuncCav=getARGV("-hsize",0.01);
            ThCavity=adaptmesh(ThCavity,metricFuncCav,IsMetric=1,nbvx=2e6);
        }
        cout<<"Cavity : After Refinement, NBV = "<<ThCavity.nv<<endl;
        savemesh(ThCavity,"Meshes/cavMeshBEDMAP.msh");
        plot(ThCavity,wait=1);
    }
    broadcast(processor(0),ThIce);
    broadcast(processor(1),ThCavity);
}//EOM" (Macro to refine mesh).


IFMACRO(dimension,3)
bool isSplit = getARGV("-isSplit",0);
int[int] lbls=[3];
meshN MaThEmpty=ThIce;
meshN ThEmptyIce=ThIce;
meshN ThEmptyCav=ThCavity;
fespace VhBdy(MaThEmpty,P1);
fespace WhBdy(ThEmptyCav,P1);
macro splitMesh(isSplit)
{
    if(isSplit){
        ffddmbuildDmesh(M,ThIce,mpiCommWorld);
        ffddmbuildDfespace(Fe,M,real,def,init,P1);
        MaThEmpty=MaTh[mpirank];
        if(mpirank==0)
            cout<<"Splitting on ... "<<endl;
        ThEmptyIce=ThIce;
        ThEmptyCav=ThCavity;
    }
    else
    {
        if(mpirank==0)
            cout<<"Splitting off ... "<<endl;
        MaThEmpty=ThIce;
        ThEmptyIce=ThIce;
        ThEmptyCav=ThCavity;
    }
    if(mpirank==0){
        cout<<"Number of ice    boundary DOFs = "<<ThEmptyIce.nv<<endl;
        cout<<"Number of cavity boundary DOFs = "<<ThEmptyCav.nv<<endl;
    }
    cout<<"Number of boundary DOFs in Processor "<<mpirank<<" = "<<MaThEmpty.nv<<endl;
}//EOM" Split Mesh
ENDIFMACRO
//

IFMACRO(dimension,2)
bool isSplit = getARGV("-isSplit",0);
meshN MaThEmpty=emptymesh(ThIce);
meshN ThEmptyIce=emptymesh(ThIce);
meshN ThEmptyCav=emptymesh(ThCavity);
fespace VhBdy(MaThEmpty,P1);
fespace WhBdy(ThEmptyCav,P1);
searchMethod = 2;
macro splitMesh(isSplit)
{
    if(isSplit){
        ffddmbuildDmesh(M,ThIce,mpiCommWorld);
        ffddmbuildDfespace(Fe,M,real,def,init,P1);
        MaThEmpty=emptymesh(MaTh[mpirank]);
        fespace MMh(MaThEmpty,P1);
        if(mpirank==0)
            cout<<"Splitting on ..."<<endl;
        ThEmptyIce=emptymesh(ThIce);
        ThEmptyCav=emptymesh(ThCavity);
    }
    else
    {
        if(mpirank==0)
            cout<<"Splitting off ..."<<endl;
        MaThEmpty=emptymesh(ThIce);
        ThEmptyIce=emptymesh(ThIce);
        ThEmptyCav=emptymesh(ThCavity);
    }
}//Macro to SPLIT MESH
ENDIFMACRO

real[int] mu(nev);
macro solveEigenEB()
{
    mu.resize(nev);
    func real[int] EBroots(int nev, real L)
    {
        real[int] RR(nev);
        real xbar = pi/(2.*L);
        RR=0.;
        int count=1;

        real f,difff;
        while(1>=0)
        {
            real tol=1e-9, error=1;
            real r=xbar, rr;
            while(error>tol)
            {
                f=cos(r*L)+2*exp(-r*L)/(1+exp(-r*L));
                difff=(2*L*exp(-2*L*r))/(exp(-L*r) + 1)^2 - (2*L*exp(-L*r))/(exp(-L*r) + 1) - L*sin(L*r);
                rr=r-f/difff;
                error=abs(r-rr);
                r=rr;
            }

            real eps=1e-10;
            if(abs(r-RR[count-1]) > eps)
            {
                RR[count-1]=r;
                count=count+1;
            }
            xbar=(count-0.5)*pi/L;
            if(count==nev+1)
                break;
        }
        return RR;
    }
    mu=EBroots(nev,LL);
}//This is a marco to compute the eigenmodes of the Euler Bernoulli equation

macro getMat(A, f, g, MM, MMt){
    func complex innerproduct(complex k, complex kappa, real H, real d)
    {
        if(abs(k-kappa) >= 1e-7)
            return ( (kappa*sin(kappa*(H-d))*cos(k*(H-d)) - k*cos(kappa*(H-d))*sin(k*(H-d)))/(kappa^2-k^2) );
        else
            return ( (H-d)/2 + sin(2*k*(H-d))/(4*k)  );
    }
    A = 0.; MM = 0.; MMt = 0.; f = 0.; g = 0.;
    for(int m=0; m<NModes+1; m++)
    {
        A(m,m) = k[m]*0.5*(cos(k[m]*HH)*sin(k[m]*HH) + k[m]*HH)/(k[m]*(cos(k[m]*HH))^2);
        f(m) = Ap*innerproduct(k[0], kd[m], HH, dd)/(cos(kd[m]*(HH-dd))*cos(k[0]*(HH)));
        for(int n=0; n<NModes+1; n++)
        {
            MM(m,n) = innerproduct(k[n], kd[m], HH, dd)/(cos(kd[m]*(HH-dd))*cos(k[n]*(HH)));
            MMt(n,m) = MM(m,n);
        }
    }
    g(0) = -Ap*A(0,0);
}//EOM"

//Non-local boundary condition and the velocity potential problem.
//Label - 3, Wetted Surface
//Label - 4, Inlet boundary
//Label - 5, Ocean surface (if any)
macro getQphi(bInd,MQ){
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    int nbv = ThCavity.nv;
    getMat(A, f, g, MM, MMt);
    complex [int,int] pp(NModes+1,Wh.ndof), ppt(Wh.ndof,NModes+1);
    pp = 0;
    ppt = 0;
    for(int m=0; m<NModes+1; m++)
    {
        IFMACRO(dimension,2)
            func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        ENDIFMACRO
            IFMACRO(dimension,3)
            func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        ENDIFMACRO

            varf boundaryip(unused,vh) = intN1(ThCavity,bInd,qforder=10)(eigenfunc*vh);
        Wh<complex> ph;
        ph[] = boundaryip(0,Wh);
        pp(m,:) = ph[];
        ppt(:,m) = ph[];
    }
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    complex [int,int] tP = T*pp;
    matrix<complex> ttP=tP;
    matrix<complex> pt=ppt;
    MQ=pt*ttP;
}//EOM to compute Qphi"

complex[int] ctilde(NModes+1);
macro getChi(){
    ctilde.resize(NModes+1);
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    getMat(A, f, g, MM, MMt);
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    complex [int] Mg = MMtinv*g;
    complex [int] Tf = T*f;
    ctilde = Mg - Tf;
}//EOM to compute ctilde"

matrix<complex> STIMA,BMASSMA;
matrix<complex> LHS;
Wh<complex> RHS,phih;

macro getLaplaceMat(a,b,c){
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    IFMACRO(dimension,2)
        varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(-fh*psih)+ intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
    ENDIFMACRO
        IFMACRO(dimension,3)
        varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(-fh*psih)+ intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y+c*N.z)*psih);
    ENDIFMACRO
        varf bMh(phih,psih) = intN1(ThCavity,2,qforder=10)(phih*psih);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the LE modes.

matrix<complex> BMASSMA1;
macro getLaplaceMatBEDMAP2(a,b,c){
    complex ndOmega = 2*pi/tt;
    complex alpha = HH*ndOmega^2;
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    IFMACRO(dimension,2)
        varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(-fh*psih) + intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
    ENDIFMACRO
        IFMACRO(dimension,3)
        varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(-fh*psih) + intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y+c*N.z)*psih);
    ENDIFMACRO
        varf bMh(phih,psih) = intN1(ThCavity,2,qforder=10)(phih*psih);
    varf bFS(phih,psih) = intN1(ThCavity,5,qforder=10)(alpha*phih*psih);
    STIMA=ah(Wh,Wh);
    BMASSMA=bFS(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS, MASS matrices and the RHS vector for the BEDMAP2 problem.

macro getLaplaceMatEB(m,rad){
    Wh<complex> psih;
    real Px=(sqrt(2)*sin(mu[m]*L+pi/4) + exp(-mu[m]*LL))/(exp(-2*mu[m]*LL)+2*exp(-mu[m]*LL)*sin(mu[m]*LL)-1);
    func etaj=rad*(-exp(-mu[m]*x)) + Px*(exp(-mu[m]*(LL-x))+exp(-mu[m]*(LL+x))) - sin(mu[m]*x) + (1-2*Px*exp(-mu[m]*LL))*cos(mu[m]*x);
    etaj=etaj(LL-x,0);
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(fh*psih*N.x)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih*N.x);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the EB modes.

macro getLaplaceMatFunc(eta){
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(fh*psih*N.x) + int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*eta*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih*N.x);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Same as before, but for a general 1D function eta

macro getLaplaceMatDBC(a,b){
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
    varf lh(unused,psih) = intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih*N.x);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Same as above but for DBC.


macro getLaplaceMatEBdbc(m,rad){
    Wh<complex> psih;
    func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
    varf lh(unused,psih) = intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Same as above but for EB DBC.

int[int] rcounts(mpisize), dspls(mpisize);
int parti, rem, start, stop, partisize;
macro buildParti(){
    parti = nev/mpisize;
    rem = nev%mpisize;
    if(mpirank < rem){
        start=mpirank*(parti+1);
        stop=start+parti;
    }
    else{
        start=mpirank*parti+rem;
        stop=start+(parti-1);
    }
    partisize=stop-start+1;
    int[int] dsplsProc(mpisize), rcountsProc(mpisize);
    rcountsProc[mpirank]=((stop-start)+1);
    dsplsProc[mpirank]=start;
    mpiAllReduce(dsplsProc,dspls,mpiCommWorld,mpiSUM);
    mpiAllReduce(rcountsProc,rcounts,mpiCommWorld,mpiSUM);
}//EOM to build partition


macro buildReducedSystem(VX,VY,phi0,phij)
{
    B.resize(nev,nev);
    K.resize(nev,nev);
    AB.resize(nev,nev);
    F.resize(nev);
    for(int m=0; m<nev; m++)
    {

        IFMACRO(dimension,2)
            F[m] = -(1i*omega*gammahat)*(intN1(ThIce,3,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y) ));
        ENDIFMACRO
            IFMACRO(dimension,3)
            F[m] = -(1i*omega*gammahat)*(intN1(ThIce,3,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y + VZ[m]*N.z) ));
        ENDIFMACRO

            for(int n=0; n<nev; n++)
            {
                B(m,n) = (rhoi*ev[m]-rhoi*omega^2)*intN(ThIce)(VX[m]*VX[n] + VY[m]*VY[n]);

                IFMACRO(dimension,2)
                    K(n,m) = intN1(ThIce,3,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y));
                ENDIFMACRO
                    IFMACRO(dimension,3)
                    K(n,m) = intN1(ThIce,3,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y+Vz[n]*N.z));
                ENDIFMACRO

                    AB(n,m) = 0;
                if(mpirank==0)
                    cout<<"(m,n)"<<"("<<m<<","<<n<<")"<<endl;
            }
    }
}//Macro to build the reduced system for the linear elasticity case. (Needs to be generalized even further. User should just specify the wetted surface and this should be computed).

macro buildReducedSystemEB(mu, phi0, phij, alpha, beta, gamma)
{
    B.resize(nev,nev);
    K.resize(nev,nev);
    AB.resize(nev,nev);
    F.resize(nev);
    for(int m=0; m<nev; m++)
    {
        func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));

        B(m,m)=(1-gamma*alpha)*(cosh(LL*mu[m])*sin(LL*mu[m]) - cos(LL*mu[m])*sinh(LL*mu[m]) - (cos(LL*mu[m])^2*sinh(2*LL*mu[m]))/2 + (cosh(LL*mu[m])^2*sin(2*LL*mu[m]))/2 - LL*mu[m]*cos(LL*mu[m])^2 + LL*mu[m]*cosh(LL*mu[m])^2 + 2*LL*mu[m]*sin(LL*mu[m])*sinh(LL*mu[m]))/(mu[m]*(cos(LL*mu[m]) + cosh(LL*mu[m]))^2);
        K(m,m)=beta*mu[m]^4*B(m,m);
        F[m]= (1i)*(omega/ag)*intN1(ThCavity,3,qforder=10)(phi0*etaj);

        for(int n=0; n<nev; n++)
        {
            func etak = ((cos(LL*mu[n]) + cosh(LL*mu[n]))*(sin(mu[n]*x) + sinh(mu[n]*x)) - (sin(LL*mu[n]) + sinh(LL*mu[n]))*(cos(mu[n]*x) + cosh(mu[n]*x)))/(cos(LL*mu[n]) + cosh(LL*mu[n]));
            AB(n,m)= -(1i)*(omega/ag)*intN1(ThCavity,3,qforder=10)(phij[m]*etak);
        }
    }
}//Build the reduced system for the Euler Bernoulli case.


matrix<complex> HHmat;
complex[int] xi(nev);
macro solveReducedSystem(){
    xi.resize(nev);
    if(mpirank==0){
        matrix<complex> Kmat, Bmat, ABmat;
        Kmat = K;
        Bmat=B;
        ABmat=AB;
        HHmat=Kmat+Bmat+ABmat;
        set(HHmat,solver=UMFPACK,eps=1e-20);
        xi=HHmat^-1*F;
        ofstream file1(SolutionDir+"/2_ModesMatrix/lambdaj"+iter+".dat");
        file1.precision(8);
        for(int m=0; m<nev; m++)
            file1<<real(xi[m])<<"\t"<<imag(xi[m])<<endl;
    }
    broadcast(processor(0),xi);
}//Macro to solve the reduced system

func eta = 0;
macro constructEBdisp()
{
    for(int m=0; m<nev; m++)
    {
        func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
        eta = eta + lambda[m]*etaj;
    }
}//Macro to construct the EB solution.


macro writeToMATLAB(uh,Th,meshfilename)
{
    savemesh(Th,meshfilename+".mesh");
    ofstream file(meshfilename);
    file.precision(16);
    file<<"2 1 1 "<<uh.n<<" 2 \n";
    for(int m=0; m<uh[].n; m++)
        file<<uh[][m]<<endl;

}//Macro to write the mesh and solution data for MATLAB visualization.

//Macro to build the reduced system (optimized for split mesh)
macro buildReducedSystemOptim(){
    if(isSplit){
        complex[int] FProc(nev);
        complex[int,int] BProc(nev,nev), KProc(nev,nev);
        real[int,int] VXaTh(MaThEmpty.nv,nev), VYaTh(MaThEmpty.nv,nev), VY1aTh(MaThEmpty.nv,nev);

        IFMACRO(dimension,3)
            real[int,int] VZaTh(MaThEmpty.nv,nev);
        ENDIFMACRO

            complex[int] phi0aTh(MaThEmpty.nv);
        complex[int,int] phiMaTh(MaThEmpty.nv,nev);

        fespace MMh(MaThEmpty,P1);
        MMh AA,BB;
        varf ipx(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.x);
        varf ipy(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.y);

        IFMACRO(dimension,3)
            varf ipz(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.z);
        ENDIFMACRO

            MMh<complex> phi0Ice, phijIce;
        matrix massMax=ipx(MMh,MMh);
        matrix massMay=ipy(MMh,MMh);

        IFMACRO(dimension,3)
            matrix massMaz=ipz(MMh,MMh);
        ENDIFMACRO

            phi0Ice=phi00;
        phi0aTh=phi0Ice[];
        phi0aTh=phi0aTh*(-1i*omega*gammahat);

        for(int m=0; m<nev; m++)
        {
            MMh vxx=VX[m],vyy=VY[m];

            IFMACRO(dimension,3)
                MMh vzz=VZ[m];
            VZaTh(:,m)=vzz[];
            ENDIFMACRO

                VXaTh(:,m)=vxx[];
            VYaTh(:,m)=vyy[];

            VY1aTh(:,m)=deltahat*VYaTh(:,m);
            phijIce=phijj[m];
            phiMaTh(:,m)=phijIce[];
            phiMaTh(:,m)=phiMaTh(:,m)*(1i*omega*gammahat);
        }

        real[int,int] Txx(MaThEmpty.nv,nev), Tyy(MaThEmpty.nv,nev);
        complex[int,int] KProcX(nev,nev), KProcY(nev,nev);
        complex[int] FProcX(nev), FProcY(nev);

        IFMACRO(dimension,3)
            real[int,int] Tzz(MaThEmpty.nv,nev);
        complex[int,int] KProcZ(nev,nev);
        complex[int] FProcZ(nev);
        ENDIFMACRO

            real tmpre, tmpim;
        for(int m=0; m<nev; m++)
        {
            Txx(:,m)=massMax*VXaTh(:,m);
            Tyy(:,m)=massMay*VYaTh(:,m);

            tmpre=phi0aTh.re'*Txx(:,m);
            tmpim=phi0aTh.im'*Txx(:,m);
            FProcX(m)=tmpre+1i*tmpim;
            tmpre=phi0aTh.re'*Tyy(:,m);
            tmpim=phi0aTh.im'*Tyy(:,m);
            FProcY(m)=tmpre+1i*tmpim;

            IFMACRO(dimension,3)
                Tzz(:,m)=massMaz*VZaTh(:,m);
            tmpre=phi0aTh.re'*Tzz(:,m);
            tmpim=phi0aTh.im'*Tzz(:,m);
            FProcZ(m)=tmpre+1i*tmpim;
            ENDIFMACRO

                B(m,m)=(ev[m]-rhoi*omega^2);

            for(int n=0; n<nev; n++)
            {
                tmpre=VY1aTh(:,n)'*Txx(:,m);
                tmpre=-1*tmpre;
                tmpre+=phiMaTh(:,n).re'*Txx(:,m);
                tmpim=phiMaTh(:,n).im'*Txx(:,m);
                KProcX(m,n)=tmpre+1i*tmpim;

                tmpre=VY1aTh(:,n)'*Tyy(:,m);
                tmpre=-1*tmpre;
                tmpre+=phiMaTh(:,n).re'*Tyy(:,m);
                tmpim=phiMaTh(:,n).im'*Tyy(:,m);
                KProcY(m,n)=tmpre+1i*tmpim;

                IFMACRO(dimension,3)
                    tmpre=VY1aTh(:,n)'*Tzz(:,m);
                tmpre=-1*tmpre;
                tmpre+=phiMaTh(:,n).re'*Tzz(:,m);
                tmpim=phiMaTh(:,n).im'*Tzz(:,m);
                KProcZ(m,n)=tmpre+1i*tmpim;
                ENDIFMACRO
                    }
        }
        FProc=FProcX+FProcY;
        KProc=KProcX+KProcY;
        mpiReduce(FProc,F,processor(0),mpiSUM);
        mpiReduce(KProc,K,processor(0),mpiSUM);

        IFMACRO(dimension,3)
            FProc+=FProcZ;
        KProc+=KProcZ;
        mpiReduce(FProc,F,processor(0),mpiSUM);
        mpiReduce(KProc,K,processor(0),mpiSUM);
        ENDIFMACRO
            }
    else
    {
        if(mpirank==0){
            complex[int] FProc(nev);
            complex[int,int] BProc(nev,nev), KProc(nev,nev);
            real[int,int] VXaTh(MaThEmpty.nv,nev), VYaTh(MaThEmpty.nv,nev), VY1aTh(MaThEmpty.nv,nev);


            complex[int] phi0aTh(MaThEmpty.nv);
            complex[int,int] phiMaTh(MaThEmpty.nv,nev);

            fespace MMh(MaThEmpty,P1);
            MMh AA,BB;
            varf ipx(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.x);
            varf ipy(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.y);

            MMh<complex> phi0Ice, phijIce;
            matrix massMax=ipx(MMh,MMh);
            matrix massMay=ipy(MMh,MMh);

            phi0Ice=phi00;
            phi0aTh=phi0Ice[];
            phi0aTh=phi0aTh*(-1i*omega*gammahat);

            IFMACRO(dimension,3)
                real[int,int] VZaTh(MaThEmpty.nv,nev);
            varf ipz(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.z);
            matrix massMaz=ipz(MMh,MMh);
            ENDIFMACRO

                for(int m=0; m<nev; m++)
                {
                    MMh vxx=VX[m],vyy=VY[m];
                    VXaTh(:,m)=vxx[];
                    VYaTh(:,m)=vyy[];

                    VY1aTh(:,m)=deltahat*VYaTh(:,m);
                    phijIce=phijj[m];
                    phiMaTh(:,m)=phijIce[];
                    phiMaTh(:,m)=phiMaTh(:,m)*(1i*omega*gammahat);

                    IFMACRO(dimension,3)
                        MMh vzz=VZ[m];
                    VZaTh(:,m)=vzz[];
                    ENDIFMACRO
                        }

            real[int,int] Txx(MaThEmpty.nv,nev), Tyy(MaThEmpty.nv,nev);
            complex[int,int] KProcX(nev,nev), KProcY(nev,nev);
            complex[int] FProcX(nev), FProcY(nev);

            IFMACRO(dimension,3)
                real[int,int] Tzz(MaThEmpty.nv,nev);
            complex[int,int] KProcZ(nev,nev);
            complex[int] FProcZ(nev);
            ENDIFMACRO

                real tmpre, tmpim;
            for(int m=0; m<nev; m++)
            {
                Txx(:,m)=massMax*VXaTh(:,m);
                Tyy(:,m)=massMay*VYaTh(:,m);

                tmpre=phi0aTh.re'*Txx(:,m);
                tmpim=phi0aTh.im'*Txx(:,m);
                FProcX(m)=tmpre+1i*tmpim;
                tmpre=phi0aTh.re'*Tyy(:,m);
                tmpim=phi0aTh.im'*Tyy(:,m);
                FProcY(m)=tmpre+1i*tmpim;

                IFMACRO(dimension,3)
                    Tzz(:,m)=massMaz*VZaTh(:,m);
                tmpre=phi0aTh.re'*Tzz(:,m);
                tmpim=phi0aTh.im'*Tzz(:,m);
                FProcZ(m)=tmpre+1i*tmpim;
                ENDIFMACRO

                    B(m,m)=(ev[m]-rhoi*omega^2);

                for(int n=0; n<nev; n++)
                {
                    tmpre=VY1aTh(:,n)'*Txx(:,m);
                    tmpre=-1*tmpre;
                    tmpre+=phiMaTh(:,n).re'*Txx(:,m);
                    tmpim=phiMaTh(:,n).im'*Txx(:,m);
                    KProcX(m,n)=tmpre+1i*tmpim;

                    tmpre=VY1aTh(:,n)'*Tyy(:,m);
                    tmpre=-1*tmpre;
                    tmpre+=phiMaTh(:,n).re'*Tyy(:,m);
                    tmpim=phiMaTh(:,n).im'*Tyy(:,m);
                    KProcY(m,n)=tmpre+1i*tmpim;

                    IFMACRO(dimension,3)
                        tmpre=VY1aTh(:,n)'*Tzz(:,m);
                    tmpre=-1*tmpre;
                    tmpre+=phiMaTh(:,n).re'*Tzz(:,m);
                    tmpim=phiMaTh(:,n).im'*Tzz(:,m);
                    KProcZ(m,n)=tmpre+1i*tmpim;
                    ENDIFMACRO
                        }
            }
            FProc=FProcX+FProcY;
            KProc=KProcX+KProcY;

            IFMACRO(dimension,3)
                FProc+=FProcZ;
            KProc+=KProcZ;
            ENDIFMACRO

                K=KProc;
            F=FProc;

        }
        broadcast(processor(0),K);
        broadcast(processor(0),F);
        broadcast(processor(0),B);
    }

}//EOM"

macro writeReducedSystem()
{
    complex[int] RefmProc(nev), Refm(nev);
    ofstream file1("1_SIMPLE5/2_ModesMatrix/ReH"+iter+".dat");
    ofstream file2("1_SIMPLE5/2_ModesMatrix/ImH"+iter+".dat");
    ofstream file3("1_SIMPLE5/2_ModesMatrix/ReF"+iter+".dat");
    ofstream file4("1_SIMPLE5/2_ModesMatrix/ImF"+iter+".dat");
    ofstream file5("1_SIMPLE5/2_RefCoeff/RefCoeff_Rad/refC"+iter+".dat");
    file1.precision(16);
    file2.precision(16);
    file3.precision(16);
    file4.precision(16);
    for(int m=0; m<nev; m++)
    {
        file3<<real(F[m])<<endl;
        file4<<imag(F[m])<<endl;
        file5<<real(Refm[m])<<"\t"<<imag(Refm[m])<<endl;
        for(int n=0; n<nev; n++)
        {
            file1<<real(B(m,n)+K(m,n))<<endl;
            file2<<imag(B(m,n)+K(m,n))<<endl;
        }
    }
}//EOM"


macro buildReducedSystemPotential()
{
    real[int,int] VXaTh(MaThEmpty.nv,nev), VYaTh(MaThEmpty.nv,nev), VY1aTh(MaThEmpty.nv,nev);
    complex[int] phi0aTh(MaThEmpty.nv);
    complex[int,int] phiMaTh(MaThEmpty.nv,partisize);
    real[int,int] Txx(MaThEmpty.nv,nev), Tyy(MaThEmpty.nv,nev);
    fespace MMh(MaThEmpty,P1);
    MMh AA,BB;
    varf ipx(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.x);
    varf ipy(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.y);

    complex[int,int] KProc(nev,partisize), KProcX(nev,partisize), KProcY(nev,partisize);
    real tmpre, tmpim;
    complex[int] FProcX(partisize), FProcY(partisize), FProc(partisize);

    matrix massMax=ipx(MMh,MMh);
    matrix massMay=ipy(MMh,MMh);

    IFMACRO(dimension,3)
        real[int,int] VZaTh(MaThEmpty.nv,nev), Tzz(MaThEmpty.nv,nev);
    varf ipz(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.z);
    matrix massMaz=ipz(AA,BB);
    complex[int,int] KProcZ(nev,partisize);
    complex[int] FProcZ(partisize);
    ENDIFMACRO

        MMh<complex> phi0Ice;
    MMh<complex>[int] phijIce(nev);
    phi0Ice=phi00;
    phi0aTh=phi0Ice[];
    phi0aTh=phi0aTh*(-1i*omega*gammahat);
    for(int m=0; m<nev; m++)
    {
        MMh vxx=VX[m], vyy=VY[m];
        VXaTh(:,m)=vxx[];
        VYaTh(:,m)=vyy[];
        VY1aTh(:,m)=deltahat*VYaTh(:,m);
        Txx(:,m)=massMax*VXaTh(:,m);
        Tyy(:,m)=massMay*VYaTh(:,m);
        B(m,m)=(ev[m]-rhoi*omega^2);

        IFMACRO(dimension,3)
            VZaTh(:,m)=vzz[];
        Tzz(:,m)=massMaz*VZaTh(:,m);
        ENDIFMACRO
            }

    for(int m=start; m<=stop; m++)
    {
        func fh=0;
        getLaplaceMat(VX[m],VY[m],0);
        LHS=STIMA+(MQ);
        set(LHS,solver=UMFPACK,eps=1e-20);
        phih[]=LHS^-1*RHS[];
        phij[m]=phih;
        phijIce[m]=phih;
        phiMaTh(:,m-start)=phijIce[m][];
        phiMaTh(:,m-start)=phiMaTh(:,m-start)*(1i*omega*gammahat);

        tmpre=phi0aTh.re'*Txx(:,m);
        tmpim=phi0aTh.im'*Txx(:,m);
        FProcX(m-start)=tmpre+1i*tmpim;
        tmpre=phi0aTh.re'*Tyy(:,m);
        tmpim=phi0aTh.im'*Tyy(:,m);
        FProcY(m-start)=tmpre+1i*tmpim;

        IFMACRO(dimension,3)
            tmpre=phi0aTh.re'*Tzz(:,m);
        tmpim=phi0aTh.im'*Tzz(:,m);
        FProcZ(m-start)=tmpre+1i*tmpim;
        ENDIFMACRO

            for(int n=0; n<nev; n++)
            {
                tmpre=VY1aTh(:,n)'*Txx(:,m);
                tmpre=-1*tmpre;
                tmpre+=Txx(:,n)'*phiMaTh(:,m-start).re;
                tmpim=Txx(:,n)'*phiMaTh(:,m-start).im;
                KProcX(n,m-start)=tmpre+1i*tmpim;

                tmpre=VY1aTh(:,n)'*Tyy(:,m);
                tmpre=-1*tmpre;
                tmpre+=Tyy(:,n)'*phiMaTh(:,m-start).re;
                tmpim=Tyy(:,n)'*phiMaTh(:,m-start).im;
                KProcY(n,m-start)=tmpre+1i*tmpim;

                IFMACRO(dimension,3)
                    tmpre=VY1aTh(:,n)'*Tzz(:,m);
                tmpre=-1*tmpre;
                tmpre+=Tzz(:,n)'*phiMaTh(:,m-start).re;
                tmpim=Tzz(:,n)'*phiMaTh(:,m-start).im;
                KProcZ(n,m-start)=tmpre+1i*tmpim;
                ENDIFMACRO

                    }
    }
    FProc=FProcX+FProcY;
    KProc=KProcX+KProcY;
    IFMACRO(dimension,3)
        FProc=FProcX+FProcY+FProcZ;
    KProc=KProcX+KProcY+KProcZ;
    ENDIFMACRO

        int[int] rcounts1=rcounts, dspls1=dspls;
    mpiGatherv(FProc,F,processor(0),rcounts1,dspls1);
    rcounts1=rcounts*nev; dspls1=dspls*nev;
    mpiGatherv(KProc,K,processor(0),rcounts1,dspls1);
}//EOM"

macro getRefCoeff(bInd,phi,Ref){
    complex[int] aa(NModes+1), bb(NModes+1), c(NModes+1);
    for(int m=0; m<NModes+1; m++)
    {
        func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        aa(m) = intN1(ThCavity,bInd,qforder=10)(phi*eigenfunc);
    }
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    int nbv = ThCavity.nv;
    getMat(A, f, g, MM, MMt);
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    complex [int] Mg = MMtinv*g;
    complex [int] Tf = T*f,ctilde(NModes+1);

    bb = T*aa; bb = bb+Mg; bb = bb-Tf;
    c = MMt*bb; c = c - g;
    complex[int,int] AA=A^-1;
    c = AA*c;
    Ref = c[0]/Ap;
}//EOM"


macro getRefModes(bInd,phi,Ref){
    complex [int] aa(NModes+1), bb(NModes+1);
    for(int m=0; m<NModes+1; m++)
    {
        func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        aa[m] = intN1(ThCavity,4,qforder=10)(phi*eigenfunc);
    }
    complex [int] c1(NModes+1);
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    int nbv = ThCavity.nv;
    getMat(A, f, g, MM, MMt);
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    bb = T*aa;
    c1 = MMt*bb;
    complex[int,int] AA=A^-1;
    c1 = c1 - pk;
    c = AA*c1;
    Ref = c[0]/Ap;
}//EOM"
