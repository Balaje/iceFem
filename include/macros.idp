//Import everything from the include folder.
load "lapack"
load "medit"
load "iovtk"

include "getARGV.idp"

include "dispersionFreeSurface.idp"
include "getMatrices.idp"
include "spline.idp"
include "nonLocal.idp"
include "refCoeff.idp"
include "getProperties.idp"

//Domain decomposition module.
macro dimension 2//EOM"
include "macro_ddm.idp"
macro minimalMesh()square(2,2)//EOM
include "ffddm_parameters.idp"
include "ffddm_partitioning.idp"
macro def(u) u//EOM
macro init(u) u//EOM

//List of useful set of macros.
macro grad(u) [dx(u),dy(u)]//EOM" //Gradient
macro div(u,v)(dx(u)+dy(v))//EOM" //Divergence of a vector field
macro epsilon(u,v)[dx(u), dy(v), (dy(u)+dx(v))/sqrt(2.)]//EOM" //Strain tensor components
macro bilinLap(u,v)(dx(u)*dx(v)+dy(u)*dy(v))//EOM"
macro bilinElas(u,v,uu,vv,a,b)(a*div(u,v)*div(uu,vv) + 2*b*epsilon(u,v)'*epsilon(uu,vv))//EOM"
macro ipScalar(u,v)(u*v)//EOM"
macro ipVector(u,v,uu,vv)(u*uu+v*vv)//EOM"

mesh ThIce=square(10,10);
mesh ThCavity=square(10,10);

fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1]);
fespace Wh(ThCavity,P1);

real lambdahat, muhat, rhoi;
real rhow, Ad;
real Lc, tc;
int iter, NModes=3, nev=20;
real LL,HH,dd,tth, ag;
real gammahat, deltahat, densRat;
complex omega, Ap, tt;
bool isUniformIce, isUniformCav;

complex [int] k(NModes+1), kd(NModes+1);
complex [int,int] B(nev,nev), K(nev,nev), AB(nev,nev), Hmat(nev,nev);
complex [int] F(nev);

macro setProblem()
{
  real L = getARGV("-L",20000.), H = getARGV("-H",500.), th = getARGV("-h",200.);
  iter=getARGV("-iter",0);
  real E, nu;
  real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
  real d = rhoi/rhow*th;
  real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
  complex t = Tr+1i*Ti;
  real EI = E*th^3/(12*(1-nu^2));
  Lc = (EI/(rhow*ag))^(1./4.);
  tc = sqrt(rhow*Lc^6/(EI*H));
  omega = 2*pi/t;
  LL = L/Lc;
  HH = H/Lc;
  dd = d/Lc;
  tth = th/Lc;
  tt = t/tc;
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Ap = ag/(1i*omega)*Ad;
  real mu1 = elasCons[0], lambda = elasCons[1];
  muhat = mu1/Lc^2;
  lambdahat = lambda/Lc^2;
  gammahat = rhow/Lc;
  deltahat = rhow*ag/Lc;
  densRat = rhoi/rhow;
}//This is a macro for getting the parameters to set the problem

real iceBegin, iceEnd, cavBegin, cavEnd, cavTop;
macro iceBEDMAP2(nborders, isBuild)
{
  ifstream file("./Meshes/BEDMAP2/iceDat.dat");
  ifstream file1("./Meshes/BEDMAP2/iceCavInt_Breaks.dat");
  ifstream file2("./Meshes/BEDMAP2/iceCavInt_Coeffs.dat");
  ifstream file3("./Meshes/BEDMAP2/iceTop_Breaks.dat");
  ifstream file4("./Meshes/BEDMAP2/iceTop_Coeffs.dat");
  ifstream file5("./Meshes/BEDMAP2/cavBed_Breaks.dat");
  ifstream file6("./Meshes/BEDMAP2/cavBed_Coeffs.dat");

  int npieces, npieces1;
  file>>iceBegin>>iceEnd>>npieces>>cavBegin>>cavEnd>>npieces1>>cavTop;

  real[int,int] coefsBot(npieces,4), coefsTop(npieces,4), coefsCav(npieces1,4);
  real[int] breaksBot(npieces+1), breaksTop(npieces+1), breaksCav(npieces1+1);
  for(int m=0; m<npieces; m++) {
    file2>>coefsBot(m,0)>>coefsBot(m,1)>>coefsBot(m,2)>>coefsBot(m,3);
    file4>>coefsTop(m,0)>>coefsTop(m,1)>>coefsTop(m,2)>>coefsTop(m,3);
  }
  for(int m=0; m<npieces+1; m++) {
    file1>>breaksBot[m];
    file3>>breaksTop[m];
  }
  for(int m=0; m<npieces1; m++)
    file6>>coefsCav(m,0)>>coefsCav(m,1)>>coefsCav(m,2)>>coefsCav(m,3);
  for(int m=0; m<npieces1+1; m++)
    file5>>breaksCav[m];

  real L=abs(iceBegin-iceEnd);
  real H=abs(splineRecon(coefsCav,breaksCav,cavBegin,npieces1));
  real th=abs(splineRecon(coefsTop,breaksTop,iceBegin,npieces)-splineRecon(coefsBot,breaksBot,iceBegin,npieces));
  real d=abs(splineRecon(coefsBot,breaksBot,iceBegin,npieces));
  real E, nu;
  real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
  real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
  complex t = Tr+1i*Ti;
  real EI = E*th^3/(12*(1-nu^2));
  Lc = (EI/(rhow*ag))^(1./4.);  
  tc = sqrt(rhow*Lc^6/(EI*H));
  omega = 2*pi/t;
  LL = L/Lc;
  HH = H/Lc;
  dd = d/Lc;
  tth = th/Lc;
  tt = t/tc;
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Ap = ag/(1i*omega)*Ad;
  real mu1 = elasCons[0], lambda = elasCons[1];
  muhat = mu1/Lc^2;
  lambdahat = lambda/Lc^2;
  gammahat = rhow/Lc;
  deltahat = rhow*ag/Lc;
  densRat = rhoi/rhow;

  if(isBuild)
    {
      if(nborders==4)
        {
          if(mpirank==0)
            {
              if(isNotch)
                {
                  cout<<"Add Notch Option Enabled"<<endl;
                  if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    real lenofIce=abs(iceBegin-iceEnd), crackBegin=iceBegin+0.4*lenofIce, crackEnd=crackBegin+0.01*lenofIce;
                    real crackDepthEnd=0.5*splineRecon(coefsTop,breaksTop,crackEnd,npieces)+0.5*splineRecon(coefsBot,breaksBot,crackEnd,npieces);

                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03a(t=iceEnd,crackEnd){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C03b(t=splineRecon(coefsTop,breaksTop,crackEnd,npieces),crackDepthEnd){x=crackEnd; y=t; label=3;};
                    border C03c(t=crackEnd,crackBegin){x=t; y=crackDepthEnd; label=3;};
                    border C03d(t=crackDepthEnd,splineRecon(coefsTop,breaksTop,crackBegin,npieces)){x=crackBegin; y=t; label=3;};
                    border C03e(t=crackBegin,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};

                    ThIce=buildmesh(C01(5000)+C02(100)+C03a(3000)+C03b(100)+C03c(100)+C03d(100)+C03e(2000)+C04(100));
                  }
                  else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    real lenofIce=abs(iceBegin-iceEnd), crackBegin=iceBegin+0.4*lenofIce, crackEnd=crackBegin+0.01*lenofIce;
                    real crackDepthEnd=0.5*(splineRecon(coefsTop,breaksTop,crackEnd,npieces)+0.5*splineRecon(coefsBot,breaksBot,crackEnd,npieces));

                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03a(t=iceEnd,crackEnd){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C03b(t=splineRecon(coefsTop,breaksTop,crackEnd,npieces),crackDepthEnd){x=crackEnd; y=t; label=3;};
                    border C03c(t=crackEnd,crackBegin){x=t; y=crackDepthEnd; label=3;};
                    border C03d(t=crackDepthEnd,splineRecon(coefsTop,breaksTop,crackBegin,npieces)){x=crackBegin; y=t; label=3;};
                    border C03e(t=crackBegin,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};

                    ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03a(3000)+C03b(100)+C03c(100)+C03d(100)+C03e(2000)+C04(100));
                  }
                }
              else{
                if(abs(cavEnd-iceEnd)<1e-5){
                  cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                  border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                  border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                  border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                  border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                  ThIce=buildmesh(C01(5000)+C02(100)+C03(5000)+C04(100));
                  cout<<"Built Ice-Mesh\n";
                }
                else {
                  cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                  border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                  border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                  border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                  border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                  border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                  ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03(2000)+C04(100));
                  cout<<"Built Ice-Mesh\n";
                }
              }
            }
          else if(mpirank==1){
            cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
            real yy1=splineRecon(coefsCav,breaksCav,cavEnd,npieces1), yy2=splineRecon(coefsBot,breaksBot,cavEnd,npieces);
            border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
            border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),splineRecon(coefsBot,breaksBot,cavEnd,npieces)){x=cavEnd; y=t; label=2;};
            border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
            border S04(t=splineRecon(coefsBot,breaksBot,iceBegin,npieces),splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=iceBegin; y=t; label=4;};
            ThCavity=buildmesh(S01(2000)+S02(100)+S03(2000)+S04(100));
            cout<<"Built Cavity-Mesh"<<endl;
          }

          broadcast(processor(0),ThIce);
          broadcast(processor(1),ThCavity);
        }
      else
        {
          if(mpirank==0)
            {
              if(isNotch)
                {
                  cout<<"Add Notch Option Enabled"<<endl;
                  if(abs(cavEnd-iceEnd)<1e-5)
                    {
                      cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                      real lenofIce=abs(iceBegin-iceEnd), crackBegin=iceBegin+0.4*lenofIce, crackEnd=crackBegin+0.01*lenofIce;
                      real crackDepthEnd=0.5*splineRecon(coefsTop,breaksTop,crackEnd,npieces)+0.5*splineRecon(coefsBot,breaksBot,crackEnd,npieces);

                      border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                      border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                      border C03a(t=iceEnd,crackEnd){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                      border C03b(t=splineRecon(coefsTop,breaksTop,crackEnd,npieces),crackDepthEnd){x=crackEnd; y=t; label=3;};
                      border C03c(t=crackEnd,crackBegin){x=t; y=crackDepthEnd; label=3;};
                      border C03d(t=crackDepthEnd,splineRecon(coefsTop,breaksTop,crackBegin,npieces)){x=crackBegin; y=t; label=3;};
                      border C03e(t=crackBegin,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                      border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};

                      ThIce=buildmesh(C01(5000)+C02(100)+C03a(3000)+C03b(100)+C03c(100)+C03d(100)+C03e(2000)+C04(100));
                    }
                  else
                    {
                      cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                      cout<<"THIS"<<endl;
                      real lenofIce=abs(iceBegin-iceEnd), crackLoc=iceBegin+0.4*lenofIce;                      
                      real crackheight=0.0001*splineRecon(coefsTop,breaksTop,crackLoc,npieces)-0.0001*splineRecon(coefsBot,breaksBot,crackLoc,npieces), crackwidth=0.005*lenofIce;
                      cout<<lenofIce<<endl;

                      border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                      border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                      border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                      border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces) - crackheight*exp(-(t-crackLoc)^2/(2*crackwidth^2)); label=3;};
                      border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};

                      ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03(2000)+C04(100));
                    }
                }
              else
                {
                  if(abs(cavEnd-iceEnd)<1e-5)
                    {
                      cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                      border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                      border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                      border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=3;};
                      border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                      ThIce=buildmesh(C01(500)+C02(100)+C03(500)+C04(100));
                      cout<<"Built Ice-Mesh\n";
                    }
                  else{
                    real lenofIce=abs(iceBegin-iceEnd);
                    real crackheight=tth/2., crackwidth=0.005*lenofIce;
                    real crackLoc=LL/2.;

                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=1;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces) + crackwidth*exp(-(t-crackLoc)^2/(2*crackwidth^2)); label=3;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=4;};
                    ThIce=buildmesh(C01(500)+C01x(100)+C02(100)+C03(500)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                  }
                }
            }
          else if(mpirank==1){
            cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
            border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
            border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),cavTop){x=cavEnd; y=t; label=2;};
            border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
            border S04(t=0,splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=0; y=t; label=4;};
            border S05(t=0,iceBegin){x=t; y=0; label=5;};
            border S06(t=0,splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=6;};
            ThCavity=buildmesh(S01(500)+S02(200)+S03(500)+S04(600)+S05(-500)+S06(-100));
            cout<<"Built Cavity-Mesh"<<endl;
          }

          broadcast(processor(0),ThIce);
          broadcast(processor(1),ThCavity);
        }
      ThIce=movemesh(ThIce,[x*1./Lc,y*1./Lc]);
      ThCavity=movemesh(ThCavity,[x*1./Lc,y*1./Lc]);
      savemesh(ThCavity,"Meshes/cavMeshBEDMAP.msh");
      savemesh(ThIce,"Meshes/iceMeshBEDMAP.msh");
    }
  else
    {
      ThCavity=readmesh("Meshes/cavMeshBEDMAP.msh");
      ThIce=readmesh("Meshes/iceMeshBEDMAP.msh");
    }
}//This is a macro to obtain the ice-cavity profiles from BEDMAP2

macro solveDispersion()
{
  k.resize(NModes+1);
  kd.resize(NModes+1);
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  k = dispersionfreesurface(alpha, NModes, HH);
  k[0] = -k[0];
  kd = dispersionfreesurface(alpha, NModes, HH-dd);
  kd[0] = -kd[0];
}//Macro to solve the dispersion equations

real ix1, iy1, ix2, iy2, ix3, iy3;
real icetopleft=(1-densRat)*tth, icebottomleft=-(densRat)*tth, icebottomright;
isUniformIce=getARGV("-isUniIce",1);
macro setMeshIce(brx, midx, midy)
{
  int N1 = getARGV("-N",3);
  if(isUniformIce==true)
    {
      icetopleft = (1-rhoi/rhow)*tth;
      icebottomleft = -(rhoi/rhow)*tth;
      icebottomright = -(rhoi/rhow)*tth;
      ix2 = 3.7*LL/4;
      iy2 = -(rhoi/rhow)*tth;
    }
  else
    {
      icetopleft = (1-rhoi/rhow)*tth;
      icebottomleft = -(rhoi/rhow)*tth;
      icebottomright = -3.*tth;
      ix2 = midx;
      iy2 = midy;
    }
  ix1 = 0; iy1 = icebottomleft;
  ix3 = LL; iy3 = icebottomright;

  border I01(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=1;};
  border I02(t=iy3,icetopleft) {x=LL; y=t; label=2;};
  border I03(t=LL,0) {x=t; y=icetopleft; label=3;};
  border I04i(t=icetopleft,0) {x=0; y=t; label=4;};
  border I04ii(t=0,icebottomleft){x=0; y=t; label=5;};
  ThIce = buildmesh(I01(LL/tth*N1)+I02(N1)+I03(LL/tth*N1)+I04i(LL/tth*N1)+I04ii(LL/tth*N1));
}//This is a macro for creating the ice mesh using 3 point cubic spline.

isUniformCav=getARGV("-isUniCav",1);
macro setMeshCav(midx, midy, endy)
{
  int N2 = getARGV("-N",3);
  real x1,x2,x3,uy1,y2,y3;
  if(isUniformCav)
    {
      x1=0.; uy1=-HH;
      x2=LL/2; y2=-HH;
      x3=LL; y3=-HH;
    }
  else
    {
      x1=0.; uy1=-HH;
      x2=midx; y2=midy;
      x3=LL; y3=endy;
    }
  border C01(t=0,LL){x = t; y = splineCurve(t,x1,uy1,x2,y2,x3,y3); label=1;};
  border C02(t=y3,iy3) {x=LL; y=t; label=2;};
  border C03(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=3;};
  border C04(t=icebottomleft,uy1) {x=0; y=t; label=4;};
  ThCavity = buildmesh(C01(LL/tth*N2)+C02(N2)+C03(-LL/tth*N2)+C04(N2));
}//This is a macro for creating the cavity Mesh using 3 point cubic spline.

macro refineMesh(){
  if(mpirank==0){
    cout<<"Imported Ice Mesh (proc 0)..."<<endl;
    cout<<"Refining Ice Mesh (proc 0) ..."<<endl;
    cout<<"Ice : Before Refinement, NBV = "<<ThIce.nv<<endl;
    func metricFuncIce=getARGV("-hsize",0.02);
    ThIce=adaptmesh(ThIce,metricFuncIce,IsMetric=1,nbvx=2e6);
    cout<<"Ice : After Refinement, NBV = "<<ThIce.nv<<endl;
    savemesh(ThIce,"Meshes/iceMeshBEDMAP.msh");
    plot(ThIce,wait=1);
  }
  else if(mpirank==1){
    cout<<"Imported Cavity Mesh (proc 1)..."<<endl;
    cout<<"Refining Cavity Mesh (proc 1) ..."<<endl;
    real LCav=abs(cavBegin-cavEnd)/Lc;
    func metricFuncCav=getARGV("-hsize",0.02);
    cout<<"Cavity : Before Refinement, NBV = "<<ThCavity.nv<<endl;
    ThCavity=adaptmesh(ThCavity,metricFuncCav,IsMetric=1,nbvx=2e6);
    cout<<"Cavity : After Refinement, NBV = "<<ThCavity.nv<<endl;
    savemesh(ThCavity,"Meshes/cavMeshBEDMAP.msh");
    plot(ThCavity,wait=1);
  }
  broadcast(processor(0),ThIce);
  broadcast(processor(1),ThCavity);
}//EOM" (Macro to refine mesh).

macro splitMeshSave()
{
  if(mpirank==0)
    system("mkdir MESHES_SPLIT");
  ffddmbuildDmesh(M,ThIce,mpiCommWorld);
  ffddmbuildDmesh(M1,ThCavity,mpiCommWorld);
  ffddmbuildDfespace(Fe,M,real,def,init,P1);
  savemesh(MaTh[mpirank],"MESHES_SPLIT/IceMaTh"+mpirank+".msh");
  savemesh(M1aTh[mpirank],"MESHES_SPLIT/CavityM1aTh"+mpirank+".msh");
  cout<<"Number of verts = "<<mpirank<<"\t"<<MaTh[mpirank].nv<<endl;
  real cpuT=mpiWtime();
  fespace MMh(MaTh[mpirank],P1);
  mesh ThEmptyCav=emptymesh(ThCavity);
  fespace WWh(ThEmptyCav,P1);
  matrix M1xM=interpolate(MMh,WWh,inside=true);
  matrix M2xM=FeRih[mpirank];
  cout<<"Time to interpolate = "<<mpiWtime()-cpuT<<endl;
  ofstream file1("MESHES_SPLIT/M1xM"+mpirank+".dat");
  if(M1xM.nnz>0)
    file1<<M1xM;
  else{
    M1xM(1,1)=1e-9;
    file1<<M1xM;
  }

  ofstream file2("MESHES_SPLIT/M2xM"+mpirank+".dat");
  file2<<M2xM;
}//Macro to SPLIT MESH and WRITE the meshes and matrices to MESHES_SPLIT;

matrix M1xM,M2xM;
mesh MaTh, M1aTh;
macro splitMeshLoad()
{
  ifstream file1("MESHES_SPLIT/M1xM"+mpirank+".dat");
  file1>>M1xM;
  ifstream file2("MESHES_SPLIT/M2xM"+mpirank+".dat");
  file2>>M2xM;
  MaTh=readmesh("MESHES_SPLIT/IceMaTh"+mpirank+".msh");
  M1aTh=readmesh("MESHES_SPLIT/CavityM1aTh"+mpirank+".msh");
}//Macro to LOAD THE SPLIT MESH

macro solveEigen()
{
  Xh [u,v],[uu,vv];
  varf a([u,v],[uu,vv]) = int2d(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + on(2,u=0,v=0);
  varf b([u,v],[uu,vv]) = int2d(ThIce,qft=qf1pTlump)(rhoi*(u*uu + v*vv));
  matrix stima = a(Xh,Xh,solver=Crout,factorize=1);
  matrix massma = b(Xh,Xh,solver=CG,eps=1e-20);
  int kkk = EigenValue(stima,massma,sym=true,sigma=0,value=ev,vector=VX,tol=1e-10);
}//This is a macro for solving the elasticity Eigenvalue problem.


real[int] mu(nev);
macro solveEigenEB()
{
  mu.resize(nev);
  func real[int] EBroots(int nev, real L)
  {
    real[int] RR(nev);
    real xbar = pi/(2.*L);
    RR=0.;
    int count=1;

    real f,difff;
    while(1>=0)
      {
        real tol=1e-9, error=1;
        real r=xbar, rr;
        while(error>tol)
          {
            f=cos(r*L)*cosh(r*L)+1;
            difff=L*cos(r*L)*sinh(r*L)-L*sin(r*L)*cosh(r*L);
            rr=r-f/difff;
            error=abs(r-rr);
            r=rr;
          }

        real eps=1e-10;
        if(abs(r-RR[count-1]) > eps)
          {
            RR[count-1]=r;
            count=count+1;
          }
        xbar=(count-0.5)*pi/L;
        if(count==nev+1)
          break;
      }
    return RR;
  }
  mu=EBroots(nev,LL);
}//This is a marco to compute the eigenmodes of the Euler Bernoulli equation


macro writeEigen()
{
  for(int m=0; m<nev; m++)
    {
      Vh modeX = VX[m];
      Vh modeY = VY[m];
      {
        ofstream file(SolutionDir+"2_Modes/modex"+m+".bb");
        file.precision(16);
        file<<"2 1 1 "<<modeX.n<<" 2 \n";
        for(int p=0; p<modeX[].n; p++)
          file<<modeX[][p]<<endl;
        ofstream file2(SolutionDir+"2_Modes/MODEX"+m+".dat");
        file2.precision(16);
        file2<<modeX[]<<endl;
      }
      {
        ofstream file(SolutionDir+"2_Modes/modey"+m+".bb");
        file.precision(16);
        file<<"2 1 1 "<<modeY.n<<" 2 \n";
        for(int p=0; p<modeY[].n; p++)
          file<<modeY[][p]<<endl;

        ofstream file2(SolutionDir+"2_Modes/MODEY"+m+".dat");
        file2.precision(16);
        file2<<modeY[]<<endl;
      }
    }
}//Macro to write the Eigenfunctions.


matrix<complex> STIMA,BMASSMA;
matrix<complex> LHS;
Wh<complex> RHS,phih;
macro getLaplaceMat(a,b){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the LE modes.

matrix<complex> BMASSMA1;
macro getLaplaceMatBEDMAP2(a,b){
  complex ndOmega = 2*pi/tt;
  complex alpha = HH*ndOmega^2;
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih) + int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  varf bFS(phih,psih) = int1d(ThCavity,5,qforder=10)(alpha*phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bFS(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS, MASS matrices and the RHS vector for the BEDMAP2 problem.

macro getLaplaceMatEB(m,rad){
  Wh<complex> psih;
  func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the EB modes.

macro getLaplaceMatFunc(eta){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
  varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih) + int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*eta*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as before, but for a general 1D function eta

macro getLaplaceMatDBC(a,b){
  Wh<complex> psih;
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
  varf lh(unused,psih) = int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as above but for DBC.


macro getLaplaceMatEBdbc(m,rad){
  Wh<complex> psih;
  func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
  varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
  varf lh(unused,psih) = int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
  varf bMh(phih,psih) = int1d(ThCavity,4,qforder=10)(phih*psih);
  STIMA=ah(Wh,Wh);
  BMASSMA=bMh(Wh,Wh);
  RHS[]=lh(0,Wh);
}//Same as above but for EB DBC.

macro buildReducedSystem(VX,VY,phi0,phij,c0,cc,isForcedFront)
{
  B.resize(nev,nev);
  K.resize(nev,nev);
  AB.resize(nev,nev);
  F.resize(nev);
  func phid = isForcedFront*(Ap*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                             c0[0]*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                             c0[1]*cos(k[1]*(y+HH))/cos(k[1]*HH) +
                             c0[2]*cos(k[2]*(y+HH))/cos(k[2]*HH) +
                             c0[3]*cos(k[3]*(y+HH))/cos(k[3]*HH) );
  for(int m=0; m<nev; m++)
    {

      F[m] = -(1i*omega*gammahat)*(int1d(ThIce,1,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y) ) +
                                   int1d(ThIce,5,qforder=10)( phid*(VX[m]*N.x + VY[m]*N.y) ));
      complex[int] cm=cc(:,m);
      func phiminus = isForcedFront*(Ap*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                                     cm[0]*cos(k[0]*(y+HH))/cos(k[0]*HH) +
                                     cm[1]*cos(k[1]*(y+HH))/cos(k[1]*HH) +
                                     cm[2]*cos(k[2]*(y+HH))/cos(k[2]*HH) +
                                     cm[3]*cos(k[3]*(y+HH))/cos(k[3]*HH));

      for(int n=0; n<nev; n++)
        {
          B(m,n) = (rhoi*ev[m]-rhoi*omega^2)*int2d(ThIce)(VX[m]*VX[n] + VY[m]*VY[n]);
          K(n,m) = int1d(ThIce,1,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y)) +
            int1d(ThIce,5,qforder=10)((-isForcedFront*y*deltahat + phiminus*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y));
          AB(n,m) = 0;
        }
    }
}//Macro to build the reduced system for the linear elasticity case. (Needs to be generalized even further. User should just specify the wetted surface and this should be computed).

macro buildReducedSystemEB(mu, phi0, phij, alpha, beta, gamma)
{
  B.resize(nev,nev);
  K.resize(nev,nev);
  AB.resize(nev,nev);
  F.resize(nev);
  for(int m=0; m<nev; m++)
    {
      func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));

      B(m,m)=(1-gamma*alpha)*(cosh(LL*mu[m])*sin(LL*mu[m]) - cos(LL*mu[m])*sinh(LL*mu[m]) - (cos(LL*mu[m])^2*sinh(2*LL*mu[m]))/2 + (cosh(LL*mu[m])^2*sin(2*LL*mu[m]))/2 - LL*mu[m]*cos(LL*mu[m])^2 + LL*mu[m]*cosh(LL*mu[m])^2 + 2*LL*mu[m]*sin(LL*mu[m])*sinh(LL*mu[m]))/(mu[m]*(cos(LL*mu[m]) + cosh(LL*mu[m]))^2);
      K(m,m)=beta*mu[m]^4*B(m,m);
      F[m]= (1i)*(omega/ag)*int1d(ThCavity,3,qforder=10)(phi0*etaj);

      for(int n=0; n<nev; n++)
        {
          func etak = ((cos(LL*mu[n]) + cosh(LL*mu[n]))*(sin(mu[n]*x) + sinh(mu[n]*x)) - (sin(LL*mu[n]) + sinh(LL*mu[n]))*(cos(mu[n]*x) + cosh(mu[n]*x)))/(cos(LL*mu[n]) + cosh(LL*mu[n]));
          AB(n,m)= -(1i)*(omega/ag)*int1d(ThCavity,3,qforder=10)(phij[m]*etak);
        }
    }
}//Build the reduced system for the Euler Bernoulli case.


matrix<complex> HHmat;
macro solveReducedSystem(){
  matrix<complex> Kmat, Bmat, ABmat;
  Kmat = K;
  Bmat=B;
  ABmat=AB;
  HHmat=Kmat+Bmat+ABmat;
  set(HHmat,solver=sparsesolver,eps=1e-20);
  xi=HHmat^-1*F;
}//Macro to solve the reduced system

func eta = 0;
macro constructEBdisp()
{
  for(int m=0; m<nev; m++)
    {
      func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
      eta = eta + lambda[m]*etaj;
    }
}//Macro to construct the EB solution.


macro writeToMATLAB(uh,Th,solfilename,meshfilename)
{
  savemesh(Th,meshfilename);
  ofstream file(solfilename);
  file.precision(16);
  file<<"2 1 1 "<<uh.n<<" 2 \n";
  for(int m=0; m<uh[].n; m++)
    file<<uh[][m]<<endl;

}//Macro to write the mesh and solution data for MATLAB visualization.

//Macro to build the reduced system (optimized for split mesh)
macro buildReducedSystemOptim(){
  real[int,int] VXaTh(MaTh.nv,nev), VYaTh(MaTh.nv,nev), VY1aTh(MaTh.nv,nev);
  complex[int] phi0aTh(MaTh.nv);
  complex[int,int] phiMaTh(MaTh.nv,nev);

  fespace MMh(MaTh,P1);
  MMh AA,BB;
  varf ip(AA,BB)=int2d(MaTh)(AA*BB);
  varf ipx(AA,BB)=int1d(MaTh,1,qforder=10)(AA*BB*N.x);
  varf ipy(AA,BB)=int1d(MaTh,1,qforder=10)(AA*BB*N.y);

  matrix massMa=ip(MMh,MMh);
  matrix massMax=ipx(MMh,MMh);
  matrix massMay=ipy(MMh,MMh);

  mesh ThCavEmpty=emptymesh(ThCavity);
  fespace WWh(ThCavEmpty,P1);
  WWh<complex> phi00=phi0;
  phi0aTh=M1xM*phi00[];
  phi0aTh=phi0aTh*(-1i*omega*gammahat);
  for(int m=0; m<nev; m++)
    {
      Vh vxx=VX[m],vyy=VY[m];
      VXaTh(:,m)=M2xM*vxx[];
      VYaTh(:,m)=M2xM*vyy[];
      VY1aTh(:,m)=deltahat*VYaTh(:,m);
      WWh<complex> phijj=phij[m];
      phiMaTh(:,m)=M1xM*phijj[];
      phiMaTh(:,m)=phiMaTh(:,m)*(1i*omega*gammahat);
    }

  real[int,int] Tx(MaTh.nv,nev), Ty(MaTh.nv,nev),Txx(MaTh.nv,nev), Tyy(MaTh.nv,nev);
  complex[int,int] BProcX(nev,nev), BProcY(nev,nev), KProcX(nev,nev), KProcY(nev,nev);
  real tmpre, tmpim;
  complex[int] FProcX(nev), FProcY(nev);
  for(int m=0; m<nev; m++)
    {
      Tx(:,m)=massMa*VXaTh(:,m);
      Ty(:,m)=massMa*VYaTh(:,m);
      Txx(:,m)=massMax*VXaTh(:,m);
      Tyy(:,m)=massMay*VYaTh(:,m);

      tmpre=phi0aTh.re'*Txx(:,m);
      tmpim=phi0aTh.im'*Txx(:,m);
      FProcX(m)=tmpre+1i*tmpim;
      tmpre=phi0aTh.re'*Tyy(:,m);
      tmpim=phi0aTh.im'*Tyy(:,m);
      FProcY(m)=tmpre+1i*tmpim;

      for(int n=0; n<nev; n++)
        {
          BProcX(n,m)=VXaTh(:,n)'*Tx(:,m);
          BProcY(n,m)=VYaTh(:,n)'*Ty(:,m);

          tmpre=VY1aTh(:,n)'*Txx(:,m);
          tmpre=-1*tmpre;
          tmpre+=phiMaTh(:,n).re'*Txx(:,m);
          tmpim=phiMaTh(:,n).im'*Txx(:,m);
          KProcX(m,n)=tmpre+1i*tmpim;

          tmpre=VY1aTh(:,n)'*Tyy(:,m);
          tmpre=-1*tmpre;
          tmpre+=phiMaTh(:,n).re'*Tyy(:,m);
          tmpim=phiMaTh(:,n).im'*Tyy(:,m);
          KProcY(m,n)=tmpre+1i*tmpim;
        }
      BProcX(:,m)=(rhoi*ev[m]-rhoi*omega^2)*BProcX(:,m);
      BProcY(:,m)=(rhoi*ev[m]-rhoi*omega^2)*BProcY(:,m);
    }
  FProc=FProcX+FProcY;
  BProc=BProcX+BProcY;
  KProc=KProcX+KProcY;
  mpiReduce(BProc,B,processor(0),mpiSUM);
  mpiReduce(FProc,F,processor(0),mpiSUM);
  mpiReduce(KProc,K,processor(0),mpiSUM);
}//EOM"


matrix IceR1, CavR1, MatInterP, MassMa, MassMaX, MassMaY;
mesh ThIceEmpty, ThCavEmpty;
macro getInterpMatrices(){
  ThIceEmpty=emptymesh(ThIce);
  ThCavEmpty=emptymesh(ThCavity);
  fespace VVh(ThIceEmpty,P1);
  fespace WWh(ThCavEmpty,P1);
  IceR1=interpolate(VVh,Vh,inside=true);
  CavR1=interpolate(WWh,Wh,inside=true);
  MatInterP=interpolate(VVh,WWh,inside=true);

  Vh AA,BB;
  varf ip(AA,BB)=int2d(ThIce)(AA*BB);
  VVh CC,DD;
  varf ip1(CC,DD)=int1d(ThIceEmpty,1,qforder=10)(CC*DD*N.x);
  varf ip2(CC,DD)=int1d(ThIceEmpty,1,qforder=10)(CC*DD*N.y);
  MassMa=ip(Vh,Vh);
  MassMaX=ip1(VVh,VVh);
  MassMaY=ip2(VVh,VVh);
}//EOM"


macro buildReducedSystemNoSplit(macroName)
{
  F.resize(nev);
  B.resize(nev,nev);
  K.resize(nev,nev);
  AB.resize(nev,nev);
  complex[int] FProc(nev), RefmProc(nev), Refm(nev);
  complex[int,int] BProc(nev,nev), KProc(nev,nev);
  complex[int,int] KProcX(nev,nev), KProcY(nev,nev), BProcX(nev,nev), BProcY(nev,nev);;
  complex[int,int] PHIJ(nev,Wh.ndof),PHIJProc(nev,Wh.ndof);
  complex[int] phiVecm(phih.n), cc(NModes+1), pk1(NModes+1);

  real[int,int] VXArr(ThIceEmpty.nv,nev), VYArr(ThIceEmpty.nv,nev);
  complex[int] phi0B=CavR1*phi0[], phi0BIce=MatInterP*phi0B;
  complex[int,int] PHIJProcBIce(nev,ThIceEmpty.nv);

  Vh vxx,vyy;
  for(int m=0; m<nev; m++)
    {
      vxx=VX[m];
      vyy=VY[m];
      VXArr(:,m)=IceR1*vxx[];
      VYArr(:,m)=IceR1*vyy[];
    }

  phi0BIce*=-(1i*omega*gammahat);
  for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
    {
      real cpu1=mpiWtime();
      func fh=0;
      macroName(VX[m],VY[m]);
      LHS=STIMA+(MQ);
      set(LHS,solver=UMFPACK,eps=1e-20);
      phih[]=LHS^-1*RHS[];
      phij[m]=phih;
      PHIJProc(m,:)=phij[m][];
      complex[int] tmpArr=CavR1*PHIJProc(m,:);
      PHIJProcBIce(m,:)=MatInterP*tmpArr;
      PHIJProcBIce(m,:)*=(1i*omega*gammahat);

      real[int] tmpMatrix1(ThIceEmpty.nv), tmpMatrix2(ThIceEmpty.nv);
      tmpMatrix1=MassMaX*VXArr(:,m);
      real tmpre=phi0BIce.re'*tmpMatrix1;
      real tmpim=phi0BIce.im'*tmpMatrix1;
      FProc[m]=tmpre+1i*tmpim;

      tmpMatrix2=MassMaY*VYArr(:,m);
      tmpre=phi0BIce.re'*tmpMatrix2;
      tmpim=phi0BIce.im'*tmpMatrix2;
      FProc[m]+=tmpre+1i*tmpim;

      Vh vxm=VX[m], vym=VY[m];
      for(int n=0; n<nev; n++)
        {
          Vh vxn=VX[n], vyn=VY[n];
          real[int] tmp(ThIce.nv);

          tmp=MassMa*vxm[];
          BProcX(n,m)=vxn[]'*tmp;
          tmp=MassMa*vym[];
          BProcY(n,m)=vyn[]'*tmp;

          tmpMatrix1=MassMaX*VXArr(:,n);
          tmpre=VYArr(:,m)'*tmpMatrix1;
          tmpre=-deltahat*tmpre;
          tmpre+=PHIJProcBIce(m,:).re'*tmpMatrix1;
          tmpim=PHIJProcBIce(m,:).im'*tmpMatrix1;
          KProcX(n,m)=tmpre+1i*tmpim;

          tmpMatrix2=MassMaY*VYArr(:,n);
          tmpre=VYArr(:,m)'*tmpMatrix2;
          tmpre=-deltahat*tmpre;
          tmpre+=PHIJProcBIce(m,:).re'*tmpMatrix2;
          tmpim=PHIJProcBIce(m,:).im'*tmpMatrix2;
          KProcY(n,m)=tmpre+1i*tmpim;
        }

      BProcX(:,m)=(rhoi*ev[m]-rhoi*omega^2)*BProcX(:,m);
      BProcY(:,m)=(rhoi*ev[m]-rhoi*omega^2)*BProcY(:,m);

      if(mpirank==0)
        cout<<"P: "<<mpirank<<" S: "<<mpiWtime()-cpu1<<"s "<<endl;

      pk1=0.;
      phiVecm = phij[m][];
      RefmProc[m] = getRefModes(ThCavity, NModes, kd, k, phiVecm, HH, dd, Ap, cc, pk1);
    }
  mpiReduce(FProc,F,processor(0),mpiSUM);
  BProc=BProcX+BProcY;
  KProc=KProcX+KProcY;
  mpiReduce(BProc,B,processor(0),mpiSUM);
  mpiReduce(KProc,K,processor(0),mpiSUM);
}//EOM" Build reduced system without splitting. Obtains the radiation potential and constructs the system.

/*
//Come back to it in the future
macro reduceBasisMatrix(A,B,C,X)
{
matrix Ctemp=C;
matrix Atemp=A;
X=B*Ctemp;
X=Atemp'*X;
}//EOM

macro reduceBasisMatrixComplex(A,B,C,X)
{
matrix Ctemp=C;
matrix<complex> Ctemp1=Ctemp;
matrix<complex> Atemp=A, Btemp=B;
X=Btemp*Ctemp1;
X=Atemp*X;
}//EOM

macro reduceBasisVector(Avec,B,C,X)
{
matrix Ctemp=C;
matrix X1=B*Ctemp;
X=X1'*Avec;
}//EOM

macro myMpiReduce(XProc,X){
real[int,int] smallVec(nev,nev);
smallVec=1e-2;
X=smallVec;
matrix X1=smallVec;
XProc+=X1;
mpiReduce(XProc,X,processor(0),mpiSUM);
X-=mpisize*X1;
}//EOM" (Variation of the mpiReduce function to handle sparse matrices). Gather By default to processor(0)

macro myMpiReduceComplex(XProc,X){
complex[int,int] smallVec(nev,nev);
smallVec=1e-2;
X=smallVec;
matrix<complex> X1=smallVec;
XProc+=X1;
mpiReduce(XProc,X,processor(0),mpiSUM);
X-=mpisize*X1;
}//EOM" (Variation of the mpiReduce function to handle sparse matrices). Gather By default to processor(0)
*/
