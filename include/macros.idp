//Import everything from the include folder.
load "lapack"
load "medit"
load "iovtk"
include "getARGV.idp"
include "functions.idp"


include "macro_ddm.idp"
include "ffddm_parameters.idp"
include "ffddm_partitioning.idp"

macro def(u) u//EOM
macro init(u) u//EOM

string SolutionDir;

//List of useful set of macros.
IFMACRO(dimension,2)
macro grad(u) [dx(u),dy(u)]//EOM" //Gradient
macro div(u,v)(dx(u)+dy(v))//EOM" //Divergence of a vector field
macro epsilon(u,v)[dx(u), dy(v), (dy(u)+dx(v))/sqrt(2.)]//EOM" //Strain tensor components
cout<<"Dimension : 2"<<endl;
macro minimalMesh()square(2,2)//EOM
    meshN ThIce=minimalMesh;
meshN ThCavity=minimalMesh;
IFMACRO(fspace,1)
fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1]);
fespace Wh(ThCavity,P1);
ENDIFMACRO
IFMACRO(fspace,2)
fespace Vh(ThIce,P2);
fespace Xh(ThIce,[P2,P2]);
fespace Wh(ThCavity,P2);
ENDIFMACRO
ENDIFMACRO

IFMACRO(dimension,3)
macro grad(u) [dx(u),dy(u),dz(u)]//EOM" //Gradient
macro epsilon(u,v,w)[dx(u),dy(v),dz(w),1/sqrt(2.)*(dy(u)+dx(v)),1/sqrt(2.)*(dz(u)+dx(w)),1/sqrt(2.)*(dz(v)+dy(w))]//Eom"
macro div(u,v,w)(dx(u)+dy(v)+dz(w))//Eom"
cout<<"Dimension : 3"<<endl;
macro minimalMesh()cube(1,1,1)//EOM
    meshN ThIce=minimalMesh;
meshN ThCavity=minimalMesh;
IFMACRO(fspace,1)
fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1,P1]);
fespace Wh(ThCavity,P1);
ENDIFMACRO
IFMACRO(fspace,2)
fespace Vh(ThIce,P2);
fespace Xh(ThIce,[P2,P2,P2]);
fespace Wh(ThCavity,P2);
ENDIFMACRO
ENDIFMACRO


real lambdahat, muhat, rhoi;
real rhow, Ad;
real Lc, tc;
int NModes=3, nev=getARGV("-nev",16);
real LL,HH,dd,tth, ag;
real gammahat, deltahat, densRat;
complex omega, Ap, tt, alpha;
bool isUniformIce, isUniformCav;
string iter=getARGV("-iter","0");

complex RefC, RefT;
complex[int] Refc(nev), Reft(nev);

complex [int] k(NModes+1), kd(NModes+1);
complex [int,int] B(nev,nev), K(nev,nev), AB(nev,nev), Hmat(nev,nev);
complex [int] F(nev);

macro setProblem()
{
    real L = getARGV("-L",20000.), H = getARGV("-H",500.), th = getARGV("-h",200.);
    real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
    complex t = Tr+1i*Ti;
    real E, nu;
    real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
    real EI = E*th^3/(12*(1-nu^2));
    Lc = (EI/(rhow*ag))^(1./4.);
    tc = sqrt(rhow*Lc^6/(EI*H));    
    real d = rhoi/rhow*th;
    omega = 2*pi/t;
    LL = L/Lc;
    HH = H/Lc;
    dd = d/Lc;
    tth = th/Lc;
    tt = t/tc;
    complex ndOmega = 2*pi/tt;
    alpha = HH*ndOmega^2;
    Ap = ag/(1i*omega)*Ad;
    real mu1 = elasCons[0], lambda = elasCons[1];
    muhat = mu1/Lc^2;
    lambdahat = lambda/Lc^2;
    gammahat = rhow/Lc;
    deltahat = rhow*ag/Lc;
    densRat = rhoi/rhow;
}//This is a macro for getting the parameters to set the problem

macro setupWorkingDir(DirName) system("./genDir.sh "+DirName);//EOM"

real iceBegin, iceEnd, cavBegin, cavEnd, cavTop;
macro iceBEDMAP2(nborders, isBuild)
{
    IFMACRO(dimension,3)
        cout<<"dimension should be 2 to use BEDMAP2 "<<endl;
    exit(0);
    ENDIFMACRO
        nev=getARGV("-nev",16);
    ifstream file("./Meshes/BEDMAP2/iceDat.dat");
    ifstream file1("./Meshes/BEDMAP2/iceCavInt_Breaks.dat");
    ifstream file2("./Meshes/BEDMAP2/iceCavInt_Coeffs.dat");
    ifstream file3("./Meshes/BEDMAP2/iceTop_Breaks.dat");
    ifstream file4("./Meshes/BEDMAP2/iceTop_Coeffs.dat");
    ifstream file5("./Meshes/BEDMAP2/cavBed_Breaks.dat");
    ifstream file6("./Meshes/BEDMAP2/cavBed_Coeffs.dat");

    int npieces, npieces1;
    file>>iceBegin>>iceEnd>>npieces>>cavBegin>>cavEnd>>npieces1>>cavTop;

    real[int,int] coefsBot(npieces,4), coefsTop(npieces,4), coefsCav(npieces1,4);
    real[int] breaksBot(npieces+1), breaksTop(npieces+1), breaksCav(npieces1+1);
    for(int m=0; m<npieces; m++) {
        file2>>coefsBot(m,0)>>coefsBot(m,1)>>coefsBot(m,2)>>coefsBot(m,3);
        file4>>coefsTop(m,0)>>coefsTop(m,1)>>coefsTop(m,2)>>coefsTop(m,3);
    }
    for(int m=0; m<npieces+1; m++) {
        file1>>breaksBot[m];
        file3>>breaksTop[m];
    }
    for(int m=0; m<npieces1; m++)
        file6>>coefsCav(m,0)>>coefsCav(m,1)>>coefsCav(m,2)>>coefsCav(m,3);
    for(int m=0; m<npieces1+1; m++)
        file5>>breaksCav[m];

    real L=abs(iceBegin-iceEnd);
    real H=abs(splineRecon(coefsCav,breaksCav,cavBegin,npieces1));
    real th=abs(splineRecon(coefsTop,breaksTop,iceBegin,npieces)-splineRecon(coefsBot,breaksBot,iceBegin,npieces));
    real d=abs(splineRecon(coefsBot,breaksBot,iceBegin,npieces));
    real Tr = getARGV("-Tr",200.), Ti = getARGV("-Ti",0.);
    complex t = Tr+1i*Ti;
    real E, nu;
    real[int] elasCons = getProps(E, nu, rhoi, rhow, ag, Ad);
    real EI = E*th^3/(12*(1-nu^2));
    Lc = (EI/(rhow*ag))^(1./4.);
    tc = sqrt(rhow*Lc^6/(EI*H));
    omega = 2*pi/t;
    LL = L/Lc;
    HH = H/Lc;
    dd = d/Lc;
    tth = th/Lc;
    tt = t/tc;
    complex ndOmega = 2*pi/tt;
    alpha = HH*ndOmega^2;
    Ap = ag/(1i*omega)*Ad;
    real mu1 = elasCons[0], lambda = elasCons[1];
    muhat = mu1/Lc^2;
    lambdahat = lambda/Lc^2;
    gammahat = rhow/Lc;
    deltahat = rhow*ag/Lc;
    densRat = rhoi/rhow;

    if(isBuild)
    {
        if(nborders==4)
        {
            if(mpirank==0)
            {
                if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(5000)+C02(100)+C03(5000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
                else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(2000)+C01x(2000)+C02(100)+C03(2000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
            }
            else if(mpirank==1){
                cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
                real yy1=splineRecon(coefsCav,breaksCav,cavEnd,npieces1), yy2=splineRecon(coefsBot,breaksBot,cavEnd,npieces);
                border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
                border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),splineRecon(coefsBot,breaksBot,cavEnd,npieces)){x=cavEnd; y=t; label=1;};
                border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                border S04(t=splineRecon(coefsBot,breaksBot,iceBegin,npieces),splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=iceBegin; y=t; label=4;};
                ThCavity=buildmesh(S01(2000)+S02(100)+S03(2000)+S04(100));
                cout<<"Built Cavity-Mesh"<<endl;
            }
            broadcast(processor(0),ThIce);
            broadcast(processor(1),ThCavity);
        }
        else
        {
            if(mpirank==0)
            {
                if(abs(cavEnd-iceEnd)<1e-5){
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    border C01(t=iceBegin,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=3;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(500)+C02(100)+C03(500)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
                else{
                    cout<<"Begin Ice-Mesh. Proc "<<mpirank<<endl;
                    real widthFrac=getARGV("-notchWidth",0.005), heightFrac=getARGV("-notchHeight",0.0);
                    real icelen=abs(iceBegin-iceEnd), crackloc=iceBegin+0.35*icelen, crackwidth=icelen*widthFrac;
                    real crackheight=heightFrac*(splineRecon(coefsTop,breaksTop,crackloc,npieces)-splineRecon(coefsBot,breaksBot,crackloc,npieces));
                    cout<<"Notch Option Enabled. Height fraction="<<heightFrac<<endl;
                    border C01(t=iceBegin,cavEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
                    border C01x(t=cavEnd,iceEnd){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces); label=2;};
                    border C02(t=splineRecon(coefsBot,breaksBot,iceEnd,npieces),splineRecon(coefsTop,breaksTop,iceEnd,npieces)){x=iceEnd; y=t; label=2;};
                    border C03(t=iceEnd,iceBegin){x=t; y=splineRecon(coefsTop,breaksTop,t,npieces)-0*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=1;};
                    border C04(t=splineRecon(coefsTop,breaksTop,iceBegin,npieces),splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                    ThIce=buildmesh(C01(5000)+C01x(1000)+C02(100)+C03(5000)+C04(100));
                    cout<<"Built Ice-Mesh\n";
                }
            }
            else if(mpirank==1){
                cout<<"Begin Cavity-Mesh. Proc "<<mpirank<<endl;
                real widthFrac=getARGV("-notchWidth",0.005), heightFrac=getARGV("-notchHeight",0.0);
                real icelen=abs(iceBegin-iceEnd), crackloc=iceBegin+0.35*icelen, crackwidth=icelen*widthFrac;
                real crackheight=heightFrac*(splineRecon(coefsTop,breaksTop,crackloc,npieces)-splineRecon(coefsBot,breaksBot,crackloc,npieces));
                cout<<"Notch Option Enabled. Height fraction="<<heightFrac<<endl;
                border S01(t=cavBegin,cavEnd){x=t; y=splineRecon(coefsCav,breaksCav,t,npieces1); label=1;};
                border S02(t=splineRecon(coefsCav,breaksCav,cavEnd,npieces1),cavTop){x=cavEnd; y=t; label=1;};
                border S03(t=cavEnd,iceBegin){x=t; y=splineRecon(coefsBot,breaksBot,t,npieces)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
                border S04(t=0,splineRecon(coefsCav,breaksCav,cavBegin,npieces1)){x=0; y=t; label=4;};
                border S05(t=0,iceBegin){x=t; y=0; label=2;};
                border S06(t=0,splineRecon(coefsBot,breaksBot,iceBegin,npieces)){x=iceBegin; y=t; label=1;};
                ThCavity=buildmesh(S01(500)+S02(200)+S03(500)+S04(600)+S05(-500)+S06(-100));
                cout<<"Built Cavity-Mesh"<<endl;
            }

            broadcast(processor(0),ThIce);
            broadcast(processor(1),ThCavity);
        }
        ThIce=movemesh(ThIce,[x*1./Lc,y*1./Lc]);
        ThCavity=movemesh(ThCavity,[x*1./Lc,y*1./Lc]);
        savemesh(ThCavity,SolutionDir+"2_Modes/cavMesh.msh");
        savemesh(ThIce,SolutionDir+"2_Modes/iceMesh.msh");        
    }
    else
    {
        ThCavity=readmeshN(SolutionDir+"2_Modes/cavMesh.msh");
        ThIce=readmeshN(SolutionDir+"2_Modes/iceMesh.msh");
    }
}//This is a macro to obtain the ice-cavity profiles from BEDMAP2

//Routine to construct linearly thickening ice-shelf with
//1) Droughts (0,d1), (L,d2);
//2) Freeboards (0,f1), (L,f2);
//In non-dimensional units.
macro setLinearThickeningIce(draft1, draft2, free1, free2)
{
    int N1 = getARGV("-N",3);
    IFMACRO(dimension,3)
    if(mpirank==0)
    cout<<"Dimension should be 2 to use this routine"<<endl;
    exit(0);
    ENDIFMACRO
    dd=abs(draft1);
    real slope1=(free2-free1)/LL, slope2=(draft2-draft1)/LL;
    real intercept1=free1, intercept2=draft1;    
    border I01(t=0,LL) {x=t; y=slope2*t+intercept2; label=3;};
    border I02(t=draft2,free2) {x=LL; y=t; label=2;};
    border I03(t=LL,0) {x=t; y=slope1*t+intercept1; label=1;};
    border I04(t=free1,draft1) {x=0; y=t; label=1;};    
    ThIce = buildmesh(I01(LL/tth*N1)+I02(N1)+I03(LL/tth*N1)+I04(N1));   
}//EOM"

macro setLinearThickeningCavity(Height1, Height2, draft1, draft2)
{
    int N1 = getARGV("-N",3);
    IFMACRO(dimension,3)
    if(mpirank==0)
    cout<<"Dimension should be 2 to use this routine"<<endl;
    exit(0);
    ENDIFMACRO        
    real slope1=(draft2-draft1)/LL, slope2=(Height2-Height1)/LL;
    real intercept1=draft1, intercept2=Height1;
    border C01(t=0,LL) {x=t; y=slope2*t+intercept2+0*sin(pi*x/LL)*x/LL; label=1;};
    border C02(t=Height2,draft2) {x=LL; y=t; label=6;};
    border C03(t=LL,0) {x=t; y=slope1*t+intercept1; label=3;};
    border C04(t=draft1,Height1) {x=0; y=t; label=4;};
    ThCavity = buildmesh(C01(LL/tth*N1)+C02(N1)+C03(LL/tth*N1)+C04(LL/tth*N1));    
}//EOM"

macro solveDispersion()
{
    k.resize(NModes+1);
    kd.resize(NModes+1);    
    complex alpha = Lc*omega^2/ag;    
    k = dispersionfreesurface(alpha, NModes, HH);
    k[0] = -k[0];
    kd = dispersionfreesurface(alpha, NModes, HH-dd);
    kd[0] = -kd[0];
}//Macro to solve the dispersion equations

real ix1, iy1, ix2, iy2, ix3, iy3;
real icetopleft=(1-densRat)*tth, icebottomleft=-(densRat)*tth, icebottomright;
isUniformIce=getARGV("-isUniIce",1);
macro setMeshIce(brx, midx, midy)
{
    int N1 = getARGV("-N",3);
    IFMACRO(dimension,3)
        int[int] lb1=[3,2,1,1,1,1];
    ThIce=cube(LL/tth*N1,N1,N1,[LL*x,-dd+(tth)*y,tth*z],label=lb1);
    ENDIFMACRO

        IFMACRO(dimension,2)
        if(isUniformIce==true)
        {
            icetopleft = (1-rhoi/rhow)*tth;
            icebottomleft = -(rhoi/rhow)*tth;
            icebottomright = -(rhoi/rhow)*tth;
            ix2 = 3.7*LL/4;
            iy2 = -(rhoi/rhow)*tth;
        }
        else
        {
            icetopleft = (1-rhoi/rhow)*tth;
            icebottomleft = -(rhoi/rhow)*tth;
            icebottomright = -3.*tth;
            ix2 = midx;
            iy2 = midy;
        }
    ix1 = 0; iy1 = icebottomleft;
    ix3 = LL; iy3 = icebottomright;
    real widthFrac=getARGV("-notchWidth",0.005);
    real heightFrac=getARGV("-notchHeight",0.0);
    real crackheight=heightFrac*tth;
    real crackwidth=widthFrac*LL;
    real crackloc=getARGV("-notchLoc",0.5)*LL;
    border I01(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
    border I02(t=iy3,icetopleft) {x=LL; y=t; label=2;};
    border I03(t=LL,0) {x=t; y=icetopleft-0*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=1;};
    border I04(t=icetopleft,icebottomleft) {x=0; y=t; label=1;};
    ThIce = buildmesh(I01(LL/tth*N1)+I02(N1)+I03(LL/tth*N1)+I04(LL/tth*N1));
    ENDIFMACRO
        }//This is a macro for creating the ice mesh using 3 point cubic spline.

isUniformCav=getARGV("-isUniCav",1);
macro setMeshCav(midx, midy, endy)
{
    int N2 = getARGV("-N",3);
    IFMACRO(dimension,3)
        int[int] lb2=[1,1,3,4,1,1];
    ThCavity=cube(LL/tth*N2,N2,N2,[LL*x,-HH+(HH-dd)*y,tth*z],label=lb2);
    ENDIFMACRO

        IFMACRO(dimension,2)
        real x1,x2,x3,uy1,y2,y3;
    if(isUniformCav)
    {
        x1=0.; uy1=-HH;
        x2=LL/2; y2=-HH;
        x3=LL; y3=-HH;
    }
    else
    {
        x1=0.; uy1=-HH;
        x2=midx; y2=midy;
        x3=LL; y3=endy;
    }
    real widthFrac=getARGV("-notchWidth",0.005);
    real heightFrac=getARGV("-notchHeight",0.0);
    real crackheight=heightFrac*tth;
    real crackwidth=widthFrac*LL;
    real crackloc=getARGV("-notchLoc",0.5)*LL;;
    border C01(t=0,LL){x = t; y = splineCurve(t,x1,uy1,x2,y2,x3,y3); label=1;};
    border C02(t=y3,iy3) {x=LL; y=t; label=1;};
    border C03(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3)+1*crackheight*exp(-(t-crackloc)^2/(2*crackwidth^2)); label=3;};
    border C04(t=icebottomleft,uy1) {x=0; y=t; label=4;};
    ThCavity = buildmesh(C01(LL/tth*N2)+C02(N2)+C03(-LL/tth*N2)+C04(N2));
    ENDIFMACRO
        }//This is a macro for creating the cavity Mesh using 3 point cubic spline.

macro nonDimensionalMesh(){
    ThIce=movemesh(ThIce,[x/Lc,y/Lc]);    
    ThCavity=movemesh(ThCavity,[x/Lc,y/Lc]);
}


//MACROS to import sample 3D meshes
macro setMeshIceCav3d()
{
    ThIce = readmesh3("MESHES/boat.mesh");
    ThCavity = readmesh3("MESHES/water.mesh");
    ThIce = movemesh(ThIce,[x/Lc,y/Lc,z/Lc]);
    ThCavity = movemesh(ThCavity,[x/Lc,y/Lc,z/Lc]);
    if(mpirank==0){
        cout<<"Number of Ice Vertices = "<<ThIce.nv<<endl;
        cout<<"Number of Cavity Vertices = "<<ThCavity.nv<<endl;
    }
}//EOM"


//Solve for the in--vacuo mode.
//Set the boundary 2-for clamped condition.
macro solveEigen()
{
    IFMACRO(dimension,2)
        if(mpirank==0){
            Xh [u,v],[uu,vv];
            varf a([u,v],[uu,vv]) = intN(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + on(2,u=0,v=0);
            varf b([u,v],[uu,vv]) = intN(ThIce,qft=qf1pTlump)((u*uu + v*vv));
            matrix stima = a(Xh,Xh,solver=Crout,factorize=1);
            matrix massma = b(Xh,Xh,solver=CG,eps=1e-20);
            int kkk = EigenValue(stima,massma,sym=true,sigma=0,value=ev,vector=VX,tol=1e-10);
        }
    ENDIFMACRO
        IFMACRO(dimension,3)
        if(mpirank==0){
            Xh [u,v,w],[uu,vv,ww];
            varf a([u,v,w],[uu,vv,ww]) = intN(ThIce,qforder=1)(lambdahat*div(u,v,w)*div(uu,vv,ww) + 2*muhat*epsilon(u,v,w)'*epsilon(uu,vv,ww)) + on(2,u=0,v=0,w=0);
            varf b([u,v,w],[uu,vv,ww]) = intN(ThIce,qforder=1)((u*uu + v*vv + w*ww));
            matrix stima = a(Xh,Xh,solver=sparsesolver);
            matrix massma = b(Xh,Xh,solver=sparsesolver);
            int kkk = EigenValue(stima,massma,value=ev,vector=VX,tol=1e-10);
        }
    ENDIFMACRO
        for(int m=0; m<nev; m++){            
            broadcast(processor(0),VX[m][]);
        }
    broadcast(processor(0),ev);
}//This is a macro for solving the elasticity Eigenvalue problem.

macro writeEigen(isVtk, isDat)
{
    int[int] Order1=[1,1];
    ofstream fileEigen(SolutionDir+"/2_Modes/eval.dat");
    for(int m=0; m<nev; m++)
    {
        fileEigen<<ev[m]<<endl;
        if(isVtk)
        {
            Vh modeX=VX[m],modeY=VY[m];
            IFMACRO(dimension,2)
                savevtk(SolutionDir+"2_Modes/Modes"+m+".vtk",ThIce,[modeX,modeY],dataname="ReMode",order=Order1);
            ENDIFMACRO

                IFMACRO(dimension,3)
                int[int] Order1=[1,1,1];
            Vh modeZ=VZ[m];
            savevtk(SolutionDir+"2_Modes/Modes"+m+".vtu",ThIce,[modeX,modeY,modeZ],dataname="ReMode",order=Order1);
            ENDIFMACRO
                }
        if(isDat)
        {
            Vh modeX=VX[m], modeY=VY[m];
            ofstream fileX(SolutionDir+"2_Modes/ModesX"+m+".dat");
            fileX<<modeX[];
            ofstream fileY(SolutionDir+"2_Modes/ModesY"+m+".dat");
            fileY<<modeY[];
            IFMACRO(dimension,3)
                Vh modeZ=VZ[m];
                ofstream fileZ(SolutionDir+"2_Modes/ModesZ"+m+".dat");
                fileZ<<modeZ[];
            ENDIFMACRO
                }
    }
}//Macro to write the Eigenfunctions to a file.

macro readEigen()
{
    if(mpirank==0){
        ifstream fileEigen(SolutionDir+"2_Modes/eval.dat");
        for(int m=0; m<nev; m++)
        {
            fileEigen>>ev[m];
            ifstream fileX(SolutionDir+"2_Modes/ModesX"+m+".dat");
            fileX>>VX[m][];
            ifstream fileY(SolutionDir+"2_Modes/ModesY"+m+".dat");
            fileY>>VY[m][];
        }
    }
    broadcast(processor(0),ev);
    for(int m=0; m<nev; m++)
        broadcast(processor(0),VX[m][]);
}//EOM To read eigenfunctions from a file"


macro refineMesh(){
    if(mpirank==0){
        real widthFrac=getARGV("-notchWidth",0.005);
        real heightFrac=getARGV("-notchHeight",0.0);
        real crackheight=heightFrac*tth;
        real crackwidth=widthFrac*LL;
        real crackloc=getARGV("-notchLoc",0.5)*LL;
        cout<<"Imported Ice Mesh (proc 0)..."<<endl;
        cout<<"Refining Ice Mesh (proc 0) ..."<<endl;
        cout<<"Ice : Before Refinement, NBV = "<<ThIce.nv<<endl;
        int isUniformRef=getARGV("-isUniRef",1);
        if(!isUniformRef){
            real metricFuncIce=getARGV("-hsize",0.02);
            ThIce=adaptmesh(ThIce,metricFuncIce*(0.1*tth-splineCurve(x,0,-0.9*tth,LL/2,-0.9*tth,LL,-0.9*tth)-1*crackheight*exp(-(x-crackloc)^2/(2*crackwidth^2))),IsMetric=1,nbvx=2e6);
        }
        else if(isUniformRef){
            real metricFuncIce=getARGV("-hsize",0.02);
            ThIce=adaptmesh(ThIce,metricFuncIce,IsMetric=1,nbvx=2e6);
        }
        cout<<"Ice : After Refinement, NBV = "<<ThIce.nv<<endl;
        savemesh(ThIce,SolutionDir+"2_Modes/iceMesh.msh");                
        plot(ThIce,wait=1);
    }
    else if(mpirank==1){
        real widthFrac=getARGV("-notchWidth",0.005);
        real heightFrac=getARGV("-notchHeight",0.0);
        real crackheight=heightFrac*tth;
        real crackwidth=widthFrac*LL;
        real crackloc=getARGV("-notchLoc",0.5)*LL;
        cout<<"Imported Cavity Mesh (proc 1)..."<<endl;
        cout<<"Refining Cavity Mesh (proc 1) ..."<<endl;
        cout<<"Cavity : Before Refinement, NBV = "<<ThCavity.nv<<endl;
        real LCav=abs(cavBegin-cavEnd)/Lc;
        int isUniformRef=getARGV("-isUniRef",1);
        if(!isUniformRef){
            real metricFuncCav=getARGV("-hsize",0.01);
            ThCavity=adaptmesh(ThCavity,0.5*metricFuncCav*(0.1*tth-splineCurve(x,0,-HH,LL/2,-HH,LL,-HH)-1*crackheight*exp(-(x-crackloc)^2/(2*crackwidth^2))),IsMetric=1,nbvx=2e6);
        }
        else if(isUniformRef){
            real metricFuncCav=getARGV("-hsize",0.01);
            ThCavity=adaptmesh(ThCavity,metricFuncCav,IsMetric=1,nbvx=2e6);
        }
        cout<<"Cavity : After Refinement, NBV = "<<ThCavity.nv<<endl;
        savemesh(ThCavity,SolutionDir+"2_Modes/cavMesh.msh");        
        plot(ThCavity,wait=1);
    }        
    broadcast(processor(0),ThIce);
    broadcast(processor(1),ThCavity);
}//EOM" (Macro to refine mesh).


IFMACRO(dimension,3)
bool isSplit = getARGV("-isSplit",0);
int[int] lbls=[3];
meshN MaThEmpty=ThIce;
meshN ThEmptyIce=ThIce;
meshN MaTh1=ThIce;
meshN ThEmptyCav=ThCavity;
fespace VhBdy(MaThEmpty,P1);
fespace WhBdy(ThEmptyCav,P1);
macro splitMesh(isSplit)
{
    if(isSplit){
        ffddmbuildDmesh(M,ThIce,mpiCommWorld);
        ffddmbuildDfespace(Fe,M,real,def,init,P1);
        MaThEmpty=MaTh[mpirank];
        MaTh1=MaTh[mpirank];
        if(mpirank==0)
            cout<<"Splitting on ... "<<endl;
        ThEmptyIce=ThIce;
        ThEmptyCav=ThCavity;
    }
    else
    {
        if(mpirank==0)
            cout<<"Splitting off ... "<<endl;
        MaThEmpty=ThIce;
        ThEmptyIce=ThIce;
        ThEmptyCav=ThCavity;
        MaTh1=ThIce;
    }
    if(mpirank==0){
        cout<<"Number of ice    boundary DOFs = "<<ThEmptyIce.nv<<endl;
        cout<<"Number of cavity boundary DOFs = "<<ThEmptyCav.nv<<endl;
    }
    cout<<"Number of boundary DOFs in Processor "<<mpirank<<" = "<<MaThEmpty.nv<<endl;
}//EOM" Split Mesh
ENDIFMACRO
//

IFMACRO(dimension,2)
bool isSplit = getARGV("-isSplit",0);
meshN MaThEmpty=emptymesh(ThIce);
meshN MaTh1=ThIce;
meshN ThEmptyIce=emptymesh(ThIce);
meshN ThEmptyCav=emptymesh(ThCavity);
fespace VhBdy(MaThEmpty,P1);
fespace WhBdy(ThEmptyCav,P1);
searchMethod = 2;
macro splitMesh(isSplit)
{
    if(isSplit){
        ffddmbuildDmesh(M,ThIce,mpiCommWorld);
        ffddmbuildDfespace(Fe,M,real,def,init,P1);
        MaThEmpty=emptymesh(MaTh[mpirank]);
        MaTh1=MaTh[mpirank];
        fespace MMh(MaThEmpty,P1);
        if(mpirank==0)
            cout<<"Splitting on ..."<<endl;
        ThEmptyIce=emptymesh(ThIce);
        ThEmptyCav=emptymesh(ThCavity);
    }
    else
    {
        if(mpirank==0)
            cout<<"Splitting off ..."<<endl;
        MaThEmpty=emptymesh(ThIce);
        ThEmptyIce=emptymesh(ThIce);
        ThEmptyCav=emptymesh(ThCavity);
        MaTh1=ThIce;
    }
}//Macro to SPLIT MESH
ENDIFMACRO

real[int] mu(nev);
macro solveEigenEB()
{
    mu.resize(nev);
    func real[int] EBroots(int nev, real L)
    {
        real[int] RR(nev);
        real xbar = pi/(2.*L);
        RR=0.;
        int count=1;

        real f,difff;
        while(1>=0)
        {
            real tol=1e-9, error=1;
            real r=xbar, rr;
            while(error>tol)
            {
                f=cos(r*L)+2*exp(-r*L)/(1+exp(-r*L));
                difff=(2*L*exp(-2*L*r))/(exp(-L*r) + 1)^2 - (2*L*exp(-L*r))/(exp(-L*r) + 1) - L*sin(L*r);
                rr=r-f/difff;
                error=abs(r-rr);
                r=rr;
            }

            real eps=1e-10;
            if(abs(r-RR[count-1]) > eps)
            {
                RR[count-1]=r;
                count=count+1;
            }
            xbar=(count-0.5)*pi/L;
            if(count==nev+1)
                break;
        }
        return RR;
    }
    mu=EBroots(nev,LL);
}//This is a marco to compute the eigenmodes of the Euler Bernoulli equation

macro getMat(A, f, g, MM, MMt){
    func complex innerproduct(complex k, complex kappa, real H, real d)
    {
        if(abs(k-kappa) >= 1e-7)
            return ( (kappa*sin(kappa*(H-d))*cos(k*(H-d)) - k*cos(kappa*(H-d))*sin(k*(H-d)))/(kappa^2-k^2) );
        else
            return ( (H-d)/2 + sin(2*k*(H-d))/(4*k)  );
    }
    A = 0.; MM = 0.; MMt = 0.; f = 0.; g = 0.;
    for(int m=0; m<NModes+1; m++)
    {
        A(m,m) = k[m]*0.5*(cos(k[m]*HH)*sin(k[m]*HH) + k[m]*HH)/(k[m]*(cos(k[m]*HH))^2);
        f(m) = Ap*innerproduct(k[0], kd[m], HH, dd)/(cos(kd[m]*(HH-dd))*cos(k[0]*(HH)));
        for(int n=0; n<NModes+1; n++)
        {
            MM(m,n) = innerproduct(k[n], kd[m], HH, dd)/(cos(kd[m]*(HH-dd))*cos(k[n]*(HH)));
            MMt(n,m) = MM(m,n);
        }
    }
    g(0) = -Ap*A(0,0);
}//EOM"

//Non-local boundary condition and the velocity potential problem.
//Label - 3, Wetted Surface
//Label - 4, Inlet boundary
//Label - 5, Ocean surface (if any)
macro getQphi(bInd,MQ){
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    int nbv = ThCavity.nv;
    getMat(A, f, g, MM, MMt);
    complex [int,int] pp(NModes+1,Wh.ndof), ppt(Wh.ndof,NModes+1);
    pp = 0;
    ppt = 0;
    for(int m=0; m<NModes+1; m++)
    {
        IFMACRO(dimension,2)
            func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        ENDIFMACRO
            IFMACRO(dimension,3)
            func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        ENDIFMACRO

        varf boundaryip(unused,vh) = intN1(ThCavity,bInd,qforder=10)(eigenfunc*vh);
        Wh<complex> ph;
        ph[] = boundaryip(0,Wh);
        pp(m,:) = ph[];
        ppt(:,m) = ph[];
    }
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    complex [int,int] tP = T*pp;
    matrix<complex> ttP=tP;
    matrix<complex> pt=ppt;
    MQ=pt*ttP;
}//EOM to compute Qphi"

complex[int] ctilde(NModes+1);
macro getChi(chi1){
    ctilde.resize(NModes+1);
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    getMat(A, f, g, MM, MMt);
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    complex [int] Mg = MMtinv*g;
    complex [int] Tf = T*f;
    ctilde = Mg - Tf;
    
    for(int m=0; m<NModes+1; m++)
        chi1=chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
}//EOM to compute ctilde"

matrix<complex> STIMA,BMASSMA;
matrix<complex> LHS;
Wh<complex> RHS,phih;

macro getLaplaceMat(a,b,c){
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    IFMACRO(dimension,2)
        varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(-fh*psih)+ intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih);
    ENDIFMACRO
        IFMACRO(dimension,3)
        varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(-fh*psih)+ intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y+c*N.z)*psih);
    ENDIFMACRO
        varf bMh(phih,psih) = intN1(ThCavity,2,qforder=10)(phih*psih);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the LE modes.

macro getLaplaceMatEB(m,rad){
    Wh<complex> psih;
    func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
        
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(fh*psih*N.x)+ int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih*N.x);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Macro to compute the STIFFNESS,MASS matrices and the RHS vector for the EB modes.

macro getLaplaceMatFunc(eta){
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih));
    varf lh(unused,psih) = intN1(ThCavity,4,qforder=10)(fh*psih*N.x) + int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*eta*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih*N.x);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Same as before, but for a general 1D function eta

macro getLaplaceMatDBC(a,b){
    Wh<complex> psih;
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
    varf lh(phih,psih) = intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*(a*N.x+b*N.y)*psih) + on(4,phih=fh);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih*N.x);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Same as above but for DBC.


macro getLaplaceMatEBdbc(m,rad){
    Wh<complex> psih;
    func etaj = rad*((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
    varf ah(phih,psih) = intN(ThCavity)(grad(phih)'*grad(psih)) + on(4,phih=fh);
    varf lh(unused,psih) = intN1(ThCavity,3,qforder=10)(-1i*omega*Lc*etaj*psih);
    varf bMh(phih,psih) = intN1(ThCavity,4,qforder=10)(phih*psih);
    STIMA=ah(Wh,Wh);
    BMASSMA=bMh(Wh,Wh);
    RHS[]=lh(0,Wh);
}//Same as above but for EB DBC.

int[int] rcounts(mpisize), dspls(mpisize);
int parti, rem, start, stop, partisize;
macro buildParti(len){
    parti = len/mpisize;
    rem = len%mpisize;
    if(mpirank < rem){
        start=mpirank*(parti+1);
        stop=start+parti;
    }
    else{
        start=mpirank*parti+rem;
        stop=start+(parti-1);
    }
    partisize=stop-start+1;
    int[int] dsplsProc(mpisize), rcountsProc(mpisize);
    rcountsProc[mpirank]=((stop-start)+1);
    dsplsProc[mpirank]=start;
    mpiAllReduce(dsplsProc,dspls,mpiCommWorld,mpiSUM);
    mpiAllReduce(rcountsProc,rcounts,mpiCommWorld,mpiSUM);
}//EOM to build partition


macro buildReducedSystem(VX,VY,phi0,phij)
{
    B.resize(nev,nev);
    K.resize(nev,nev);
    AB.resize(nev,nev);
    F.resize(nev);
    for(int m=0; m<nev; m++)
    {

        IFMACRO(dimension,2)
            F[m] = -(1i*omega*gammahat)*(intN1(ThIce,3,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y) ));
        ENDIFMACRO
            IFMACRO(dimension,3)
            F[m] = -(1i*omega*gammahat)*(intN1(ThIce,3,qforder=10)( phi0*(VX[m]*N.x + VY[m]*N.y + VZ[m]*N.z) ));
        ENDIFMACRO

            for(int n=0; n<nev; n++)
            {
                B(m,n) = (ev[m]-rhoi*omega^2)*intN(ThIce)(VX[m]*VX[n] + VY[m]*VY[n]);

                IFMACRO(dimension,2)
                    K(n,m) = intN1(ThIce,3,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y));
                ENDIFMACRO
                    IFMACRO(dimension,3)
                    K(n,m) = intN1(ThIce,3,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y+Vz[n]*N.z));
                ENDIFMACRO

                    AB(n,m) = 0;                
            }
    }
}//Macro to build the reduced system for the linear elasticity case. (Needs to be generalized even further. User should just specify the wetted surface and this should be computed).

macro buildReducedSystemEB(mu, phi0, phij, alpha, beta, gamma)
{
    B.resize(nev,nev);
    K.resize(nev,nev);
    AB.resize(nev,nev);
    F.resize(nev);
    for(int m=0; m<nev; m++)
    {
        func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));

        B(m,m)=(1-gamma*alpha)*(cosh(LL*mu[m])*sin(LL*mu[m]) - cos(LL*mu[m])*sinh(LL*mu[m]) - (cos(LL*mu[m])^2*sinh(2*LL*mu[m]))/2 + (cosh(LL*mu[m])^2*sin(2*LL*mu[m]))/2 - LL*mu[m]*cos(LL*mu[m])^2 + LL*mu[m]*cosh(LL*mu[m])^2 + 2*LL*mu[m]*sin(LL*mu[m])*sinh(LL*mu[m]))/(mu[m]*(cos(LL*mu[m]) + cosh(LL*mu[m]))^2);
        K(m,m)=beta*mu[m]^4*B(m,m);
        F[m]= (1i)*(omega/ag)*intN1(ThCavity,3,qforder=10)(phi0*etaj);

        for(int n=0; n<nev; n++)
        {
            func etak = ((cos(LL*mu[n]) + cosh(LL*mu[n]))*(sin(mu[n]*x) + sinh(mu[n]*x)) - (sin(LL*mu[n]) + sinh(LL*mu[n]))*(cos(mu[n]*x) + cosh(mu[n]*x)))/(cos(LL*mu[n]) + cosh(LL*mu[n]));
            AB(n,m)= -(1i)*(omega/ag)*intN1(ThCavity,3,qforder=10)(phij[m]*etak);
        }
    }
}//Build the reduced system for the Euler Bernoulli case.


matrix<complex> HHmat;
complex[int] xi(nev);
macro solveReducedSystem(){
    xi.resize(nev);
    if(mpirank==0){
        matrix<complex> Kmat, Bmat, ABmat;
        Kmat = K;
        Bmat=B;
        ABmat=AB;        
        HHmat=Kmat+Bmat+ABmat;
        set(HHmat,solver=UMFPACK,eps=1e-20);        
        xi=HHmat^-1*F;        
        ofstream file1(SolutionDir+"/2_ModesMatrix/lambdaj"+iter+".dat");
        file1.precision(8);
        for(int m=0; m<nev; m++)
            file1<<real(xi[m])<<"\t"<<imag(xi[m])<<endl;
    }
    broadcast(processor(0),xi);    
}//Macro to solve the reduced system

func eta = 0;
macro constructEBdisp()
{
    for(int m=0; m<nev; m++)
    {
        func etaj = ((cos(LL*mu[m]) + cosh(LL*mu[m]))*(sin(mu[m]*x) + sinh(mu[m]*x)) - (sin(LL*mu[m]) + sinh(LL*mu[m]))*(cos(mu[m]*x) + cosh(mu[m]*x)))/(cos(LL*mu[m]) + cosh(LL*mu[m]));
        eta = eta + lambda[m]*etaj;
    }
}//Macro to construct the EB solution.


macro writeToMATLAB(uh,Th,meshfilename)
{
    savemesh(Th,meshfilename+".msh");
    ofstream file(meshfilename);
    file.precision(16);
    file<<"2 1 1 "<<uh.n<<" 2 \n";
    for(int m=0; m<uh[].n; m++)
        file<<uh[][m]<<endl;

}//Macro to write the mesh and solution data for MATLAB visualization.

//Macro to build the reduced system (optimized for split mesh)
macro buildReducedSystemOptim(){
    K.resize(nev,nev);
    B.resize(nev,nev);
    AB.resize(nev,nev);
    F.resize(nev);
    
    complex[int] FProc(nev);
    complex[int,int] BProc(nev,nev), KProc(nev,nev), BProcX(nev,nev), BProcY(nev,nev);
    real[int,int] VXaTh(MaThEmpty.nv,nev), VYaTh(MaThEmpty.nv,nev), VY1aTh(MaThEmpty.nv,nev);
    real[int,int] VX2aTh(MaTh1.nv,nev), VY2aTh(MaTh1.nv,nev);

    IFMACRO(dimension,3)
        real[int,int] VZaTh(MaThEmpty.nv,nev), VZ2aTh(MaTh1.nv,nev);
    ENDIFMACRO

    complex[int] phi0aTh(MaThEmpty.nv);
    complex[int,int] phiMaTh(MaThEmpty.nv,nev);

    fespace MMh(MaThEmpty,P1);
    fespace M2h(MaTh1,P1);    
    MMh AA,BB;
    M2h CC,DD;
    varf ipx(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.x);
    varf ipy(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.y);
    varf ipMass(CC,DD)=intN(MaTh1)(CC*DD);

    IFMACRO(dimension,3)
        varf ipz(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.z);
    ENDIFMACRO

    MMh<complex> phi0Ice, phijIce;
    matrix massMax=ipx(MMh,MMh);
    matrix massMay=ipy(MMh,MMh);
    matrix massMa=ipMass(M2h,M2h);

    IFMACRO(dimension,3)
        matrix massMaz=ipz(MMh,MMh);
    ENDIFMACRO

        phi0Ice=phi00;
    phi0aTh=phi0Ice[];
    phi0aTh=phi0aTh*(-1i*omega*gammahat);

    for(int m=0; m<nev; m++)
    {
        MMh vxx=VX[m],vyy=VY[m];
        M2h vx2=VX[m],vy2=VY[m];

        IFMACRO(dimension,3)
            M2h vz2=VZ[m];
            MMh vzz=VZ[m];
        VZaTh(:,m)=vzz[];
        VZ2aTh(:,m)=vz2[];
        ENDIFMACRO

        VXaTh(:,m)=vxx[];
        VYaTh(:,m)=vyy[];
        
        VX2aTh(:,m)=vx2[];
        VY2aTh(:,m)=vy2[];

        VY1aTh(:,m)=deltahat*VYaTh(:,m);
        phijIce=phijj[m];
        phiMaTh(:,m)=phijIce[];
        phiMaTh(:,m)=phiMaTh(:,m)*(1i*omega*gammahat);
    }

    real[int,int] Txx(MaThEmpty.nv,nev), Tyy(MaThEmpty.nv,nev), TX(MaTh1.nv,nev), TY(MaTh1.nv,nev);
    complex[int,int] KProcX(nev,nev), KProcY(nev,nev);
    complex[int] FProcX(nev), FProcY(nev);

    IFMACRO(dimension,3)
        real[int,int] Tzz(MaThEmpty.nv,nev), TZ(MaTh1.nv,nev);
    complex[int,int] KProcZ(nev,nev), BProcZ(nev,nev);
    complex[int] FProcZ(nev);
    ENDIFMACRO

    real tmpre, tmpim;
    for(int m=0; m<nev; m++)
    {
        Txx(:,m)=massMax*VXaTh(:,m);
        Tyy(:,m)=massMay*VYaTh(:,m);

        TX(:,m)=massMa*VX2aTh(:,m);
        TY(:,m)=massMa*VY2aTh(:,m);

        tmpre=phi0aTh.re'*Txx(:,m);
        tmpim=phi0aTh.im'*Txx(:,m);
        FProcX(m)=tmpre+1i*tmpim;
        tmpre=phi0aTh.re'*Tyy(:,m);
        tmpim=phi0aTh.im'*Tyy(:,m);
        FProcY(m)=tmpre+1i*tmpim;

        IFMACRO(dimension,3)
        TZ(:,m)=massMa*VZ2aTh(:,m);    
        Tzz(:,m)=massMaz*VZaTh(:,m);
        tmpre=phi0aTh.re'*Tzz(:,m);
        tmpim=phi0aTh.im'*Tzz(:,m);
        FProcZ(m)=tmpre+1i*tmpim;
        ENDIFMACRO        

        for(int n=0; n<nev; n++)
        {
            BProcX(m,n)=VX2aTh(:,n)'*TX(:,m);
            BProcY(m,n)=VY2aTh(:,n)'*TY(:,m);
            
            tmpre=VY1aTh(:,n)'*Txx(:,m);
            tmpre=-1*tmpre;
            tmpre+=phiMaTh(:,n).re'*Txx(:,m);
            tmpim=phiMaTh(:,n).im'*Txx(:,m);
            KProcX(m,n)=tmpre+1i*tmpim;

            tmpre=VY1aTh(:,n)'*Tyy(:,m);
            tmpre=-1*tmpre;
            tmpre+=phiMaTh(:,n).re'*Tyy(:,m);
            tmpim=phiMaTh(:,n).im'*Tyy(:,m);
            KProcY(m,n)=tmpre+1i*tmpim;

            IFMACRO(dimension,3)
            BProcZ(m,n)=VZ2aTh(:,n)'*TZ(:,m);
            tmpre=VY1aTh(:,n)'*Tzz(:,m);
            tmpre=-1*tmpre;
            tmpre+=phiMaTh(:,n).re'*Tzz(:,m);
            tmpim=phiMaTh(:,n).im'*Tzz(:,m);
            KProcZ(m,n)=tmpre+1i*tmpim;
            ENDIFMACRO
        }

        BProcX(:,m)=(ev[m]-rhoi*omega^2)*BProcX(:,m);
        BProcY(:,m)=(ev[m]-rhoi*omega^2)*BProcY(:,m);
        
        IFMACRO(dimension,3)
            BProcZ(:,m)=(ev[m]-rhoi*omega^2)*BProcZ(m,:);
        ENDIFMACRO
    }
    FProc=FProcX+FProcY;
    KProc=KProcX+KProcY;
    BProc=BProcX+BProcY;    
    IFMACRO(dimension,3)
    FProc+=FProcZ;
    KProc+=KProcZ;
    BProc+=BProcZ;
    ENDIFMACRO
    if(isSplit){
        mpiAllReduce(BProc,B,mpiCommWorld,mpiSUM);
        mpiAllReduce(FProc,F,mpiCommWorld,mpiSUM);
        mpiAllReduce(KProc,K,mpiCommWorld,mpiSUM);        
    }
    else
    {        
        K=KProc;
        F=FProc;
        B=BProc;                
    }        

}//EOM"

/*Store the variables
1) - RefC (Diffraction Reflection Coefficient)
2) - RefT (Diffraction Transmission Coefficient)
3) - Refc (Radiation Reflection Coefficients)
4) - Reft (Radiation Transmission Coefficients)
5) - H (Scattering matrix)
6) - F (RHS Forcing vector)
to the disk
*/
macro writeReducedSystem()
{
    ofstream file1(SolutionDir+"2_ModesMatrix/ReH"+iter+".dat");
    ofstream file2(SolutionDir+"2_ModesMatrix/ImH"+iter+".dat");
    ofstream file3(SolutionDir+"2_ModesMatrix/ReF"+iter+".dat");
    ofstream file4(SolutionDir+"2_ModesMatrix/ImF"+iter+".dat");
    ofstream file5(SolutionDir+"2_RefCoeff/RefCoeff_Rad/refC"+iter+".dat");
    ofstream file6(SolutionDir+"2_RefCoeff/RefCoeff_Rad/refT"+iter+".dat");
    ofstream file7(SolutionDir+"2_RefCoeff/RefCoeff_Dif/refC"+iter+".dat");
    ofstream file8(SolutionDir+"2_RefCoeff/RefCoeff_Dif/refT"+iter+".dat");    
    file1.precision(16);
    file2.precision(16);
    file3.precision(16);
    file4.precision(16);
    file5.precision(16);
    file6.precision(16);
    file7.precision(16);
    file8.precision(16);


    file7<<real(RefC)<<"\t"<<imag(RefC)<<endl;
    file8<<real(RefT)<<"\t"<<imag(RefT)<<endl;
    for(int m=0; m<nev; m++)
    {
        file3<<real(F[m])<<endl;
        file4<<imag(F[m])<<endl;
        file5<<real(Refc[m])<<"\t"<<imag(Refc[m])<<endl;
        file6<<real(Reft[m])<<"\t"<<imag(Reft[m])<<endl;
        for(int n=0; n<nev; n++)
        {
            file1<<real(B(m,n)+K(m,n))<<endl;
            file2<<imag(B(m,n)+K(m,n))<<endl;
        }
    }
}//EOM"


macro buildReducedSystemPotential()
{
    real[int,int] VXaTh(MaThEmpty.nv,nev), VYaTh(MaThEmpty.nv,nev), VY1aTh(MaThEmpty.nv,nev);
    complex[int] phi0aTh(MaThEmpty.nv);
    complex[int,int] phiMaTh(MaThEmpty.nv,partisize);
    real[int,int] Txx(MaThEmpty.nv,nev), Tyy(MaThEmpty.nv,nev);
    fespace MMh(MaThEmpty,P1);
    MMh AA,BB;
    varf ipx(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.x);
    varf ipy(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.y);

    complex[int,int] KProc(nev,partisize), KProcX(nev,partisize), KProcY(nev,partisize);
    real tmpre, tmpim;
    complex[int] FProcX(partisize), FProcY(partisize), FProc(partisize);

    matrix massMax=ipx(MMh,MMh);
    matrix massMay=ipy(MMh,MMh);

    IFMACRO(dimension,3)
        real[int,int] VZaTh(MaThEmpty.nv,nev), Tzz(MaThEmpty.nv,nev);
    varf ipz(AA,BB)=intN1(MaThEmpty,3,qforder=10)(AA*BB*N.z);
    matrix massMaz=ipz(AA,BB);
    complex[int,int] KProcZ(nev,partisize);
    complex[int] FProcZ(partisize);
    ENDIFMACRO

        MMh<complex> phi0Ice;
    MMh<complex>[int] phijIce(nev);
    phi0Ice=phi00;
    phi0aTh=phi0Ice[];
    phi0aTh=phi0aTh*(-1i*omega*gammahat);
    for(int m=0; m<nev; m++)
    {
        MMh vxx=VX[m], vyy=VY[m];
        VXaTh(:,m)=vxx[];
        VYaTh(:,m)=vyy[];
        VY1aTh(:,m)=deltahat*VYaTh(:,m);
        Txx(:,m)=massMax*VXaTh(:,m);
        Tyy(:,m)=massMay*VYaTh(:,m);
        B(m,m)=(rhoi*ev[m]-rhoi*omega^2);

        IFMACRO(dimension,3)
            VZaTh(:,m)=vzz[];
        Tzz(:,m)=massMaz*VZaTh(:,m);
        ENDIFMACRO
            }

    for(int m=start; m<=stop; m++)
    {
        func fh=0;
        getLaplaceMat(VX[m],VY[m],0);
        LHS=STIMA+(MQ);
        set(LHS,solver=UMFPACK,eps=1e-20);
        phih[]=LHS^-1*RHS[];
        phij[m]=phih;
        phijIce[m]=phih;
        phiMaTh(:,m-start)=phijIce[m][];
        phiMaTh(:,m-start)=phiMaTh(:,m-start)*(1i*omega*gammahat);

        tmpre=phi0aTh.re'*Txx(:,m);
        tmpim=phi0aTh.im'*Txx(:,m);
        FProcX(m-start)=tmpre+1i*tmpim;
        tmpre=phi0aTh.re'*Tyy(:,m);
        tmpim=phi0aTh.im'*Tyy(:,m);
        FProcY(m-start)=tmpre+1i*tmpim;

        IFMACRO(dimension,3)
            tmpre=phi0aTh.re'*Tzz(:,m);
        tmpim=phi0aTh.im'*Tzz(:,m);
        FProcZ(m-start)=tmpre+1i*tmpim;
        ENDIFMACRO

            for(int n=0; n<nev; n++)
            {
                tmpre=VY1aTh(:,n)'*Txx(:,m);
                tmpre=-1*tmpre;
                tmpre+=Txx(:,n)'*phiMaTh(:,m-start).re;
                tmpim=Txx(:,n)'*phiMaTh(:,m-start).im;
                KProcX(n,m-start)=tmpre+1i*tmpim;

                tmpre=VY1aTh(:,n)'*Tyy(:,m);
                tmpre=-1*tmpre;
                tmpre+=Tyy(:,n)'*phiMaTh(:,m-start).re;
                tmpim=Tyy(:,n)'*phiMaTh(:,m-start).im;
                KProcY(n,m-start)=tmpre+1i*tmpim;

                IFMACRO(dimension,3)
                    tmpre=VY1aTh(:,n)'*Tzz(:,m);
                tmpre=-1*tmpre;
                tmpre+=Tzz(:,n)'*phiMaTh(:,m-start).re;
                tmpim=Tzz(:,n)'*phiMaTh(:,m-start).im;
                KProcZ(n,m-start)=tmpre+1i*tmpim;
                ENDIFMACRO

                    }
    }
    FProc=FProcX+FProcY;
    KProc=KProcX+KProcY;
    IFMACRO(dimension,3)
        FProc=FProcX+FProcY+FProcZ;
    KProc=KProcX+KProcY+KProcZ;
    ENDIFMACRO

        int[int] rcounts1=rcounts, dspls1=dspls;
    mpiGatherv(FProc,F,processor(0),rcounts1,dspls1);
    rcounts1=rcounts*nev; dspls1=dspls*nev;
    mpiGatherv(KProc,K,processor(0),rcounts1,dspls1);
}//EOM"

macro getRefCoeff(bInd,phi,Ref){
    complex[int] aa(NModes+1), bb(NModes+1), c(NModes+1);
    for(int m=0; m<NModes+1; m++)
    {
        func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        aa(m) = intN1(ThCavity,bInd,qforder=10)(phi*eigenfunc);
    }
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    int nbv = ThCavity.nv;
    getMat(A, f, g, MM, MMt);
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    complex [int] Mg = MMtinv*g;
    complex [int] Tf = T*f,ctilde(NModes+1);

    bb = T*aa; bb = bb+Mg; bb = bb-Tf;
    c = MMt*bb; c = c - g;
    complex[int,int] AA=A^-1;
    c = AA*c;
    Ref = c[0]/Ap;
}//EOM"


macro getRefModes(bInd,phi,Ref){
    complex [int] aa(NModes+1), bb(NModes+1);
    for(int m=0; m<NModes+1; m++)
    {
        func eigenfunc = cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
        aa[m] = intN1(ThCavity,bInd,qforder=10)(phi*eigenfunc);
    }
    complex [int] c1(NModes+1);
    complex [int] f(NModes+1), g(NModes+1), c(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1);
    int nbv = ThCavity.nv;
    getMat(A, f, g, MM, MMt);
    complex [int,int] MMinv = MM^-1;
    complex [int,int] MMtinv = MMt^-1;
    complex [int,int] TT = (MMtinv*A);
    complex [int,int] T = TT*MMinv;
    bb = T*aa;
    c1 = MMt*bb;
    complex[int,int] AA=A^-1;
    c = AA*c1;
    Ref = c[0]/Ap;
}//EOM"

macro readFile(rows,cols,filename,array){
    ifstream file(filename);
    for(int m=0; m<rows; m++)
        for(int n=0; n<cols; n++)
            file>>array(m,n);
}//Macro to read files.EOM"

int nfreq=getARGV("-nfreq",199);
complex[int,int] UXT(Vh.ndof,nfreq), UYT(Vh.ndof,nfreq);
macro constructFineSpace(nfreq,extractIndx,dIndx,dIndy){
    ThCavity=readmeshN(SolutionDir+"2_Modes/cavMesh.msh");
    ThIce=readmeshN(SolutionDir+"2_Modes/iceMesh.msh");   
    UXT.resize(Vh.ndof,nfreq);
    UYT.resize(Vh.ndof,nfreq);    
    complex[int,int] mx(nev,Vh.ndof), my(nev,Vh.ndof);
    real[int] tmp(Vh.ndof);
    for(int m=0; m<nev; m++)
    {        
        ifstream filex(SolutionDir+"2_Modes/MODESX"+m+".dat");
        filex>>tmp;
        mx(m,:).re=tmp;
        ifstream filey(SolutionDir+"2_Modes/MODESY"+m+".dat");
        filey>>tmp;
        my(m,:).re=tmp;
    }

    complex[int,int] lambdaRe(nfreq,nev), lambdaIm(nfreq,nev);
    readFile(nfreq,nev,SolutionDir+"2_ModesMatrix/Interpolated_L/lambdaRe.dat",lambdaRe);
    readFile(nfreq,nev,SolutionDir+"2_ModesMatrix/Interpolated_L/lambdaIm.dat",lambdaIm);
    complex[int,int] lambda=lambdaIm;
    lambda*=1i;
    lambda+=lambdaRe;
    Vh<complex> ux,uy;
    complex[int,int] UX(nfreq,Vh.ndof), UY(nfreq,Vh.ndof);
    UX=lambda*mx;
    UY=lambda*my;
    UXT=UX';
    UYT=UY';
    UXT=conj(UXT);
    UYT=conj(UYT);
    if(extractIndx>=0){        
        dIndx=UXT(:,extractIndx);
        dIndy=UYT(:,extractIndx);
        int[int] Order=[1,1];
        savevtk(SolutionDir+"/reconDisp"+iter+".vtu",ThIce,[real(dispX),real(dispY)],[imag(dispX),imag(dispY)], dataname="ReDisp ImDisp",order=Order);
    }
    else{
        dIndx=0;
        dIndy=0;
    }
}//EOM"
