//Simple example to demonstrate the ice-shelf toolbox;
//Invoking Domain decomposition technique.

verbosity=0.;
real cpu=mpiWtime();
bool debug=true;
string SolutionDir="1_SIMPLE5/";

include "macros.idp"

macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM (Macro to define the stress tensor)"

//Sets up an example problem. Can control input using CMD line args.
//For a detailed list of default args. Refer the manual.
nev=64;
setProblem;

//Solve the dispersion equation -k tan(k h) = \alpha. -k tan(k (h-d)) = \alpha
solveDispersion;

real starttime=mpiWtime();
//Build the meshes.
real botRight=-3.*tth, midPX=3.7*LL/4, midPY=-2.5*tth;
setMeshIce(botRight, midPX, midPY);
real midx=LL/2., midy=-0.5*HH, endy=-HH;
setMeshCav(midx, midy, endy);
refineMesh;//Refine Mesh.
splitMesh(isSplit);//Split Mesh for domain decomposition
real endtime=mpiWtime();
cout<<"Proc "<<mpirank<<"\t\t\t Mesh construction Time "<<endtime-starttime<<" s"<<endl;

Xh[int][VX,VY](nev); //Define an array of fe-function to store in-vacuo modes.
real[int] ev(nev); //Define a real array for the eigenvalues.
real eigenStartTime=mpiWtime();
solveEigen;
real eigenEndTime=mpiWtime();
cout<<"Proc "<<mpirank<<"\t\t\t Time to solve Eigenvalue "<<eigenEndTime-eigenStartTime<<" s"<<endl;
//readEigen;


//  2) Get the Non-local boundary condition
matrix<complex> MQ;
complex[int] ctilde(NModes+1);
Wh<complex> chi1;
MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
for(int m=0; m<NModes+1; m++)
  chi1 = chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

//Get the emptymesh and the solution on the boundary.


if(mpirank==0){
  cout<<"Number of ice    boundary DOFs = "<<ThEmptyIce.nv<<endl;
  cout<<"Number of cavity boundary DOFs = "<<ThEmptyCav.nv<<endl;
 }

//  3) Solve for the diffraction potential.
Wh<complex> phi0;
func fh=chi1;//Store in fh, the right-hand side function on the ocean-cavity interface.
getLaplaceMat(0,0);
LHS=STIMA+(MQ);
set(LHS,solver=UMFPACK,eps=1e-20);
phih[]=LHS^-1*RHS[];
phi0=phih;//Store in phi0;

//Interpolate to boundary.
WhBdy<complex> phi00=phi0;

//Solve for radiation potential.
int parti = nev/mpisize;

Wh<complex>[int] phij(nev);
//Define array of boundary functions.
WhBdy<complex>[int] phijj(nev);


F.resize(nev);
B.resize(nev,nev);
K.resize(nev,nev);
AB.resize(nev,nev);


complex[int,int] PHIJ(nev,WhBdy.ndof),PHIJProc(nev,WhBdy.ndof);
complex[int] phiVecm(phih.n), cc(NModes+1), pk1(NModes+1);

real potStartTime=mpiWtime();
for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    func fh=0;
    getLaplaceMat(VX[m],VY[m]);
    LHS=STIMA+(MQ);
    set(LHS,solver=UMFPACK,eps=1e-20);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih; //Leave the bulk as it is. This will not be used in constructing the matrices.

    //Interpolate on the BOUNDARY alone and store in matrix. This will be used in the construction of the matrices
    phijj[m]=phih;
    PHIJProc(m,:)=phijj[m][];
  }
mpiAllReduce(PHIJProc,PHIJ,mpiCommWorld,mpiSUM); //Collect on all cpus.
real potEndTime=mpiWtime();
cout<<"Proc "<<mpirank<<"\t\t\t Solving potentials took "<<potEndTime-potStartTime<<" s"<<endl;

//Unpack and set to phij locally in all procs (Only boundary)
for(int m=0; m<nev; m++)
  phijj[m][]=PHIJ(m,:);

real cpu1=mpiWtime();
buildReducedSystemOptim;
//buildReducedSystem(VX,VY,phi0,phij);
cout<<"No of vertices: "<<MaThEmpty.nv<<"\t Time in processor "<<mpirank<<" = "<<mpiWtime()-cpu1<<"\t s"<<endl;

//Solve the reduced system;
solveReducedSystem;

//Compute the solution.
Vh <complex> etax, etay, etaxProc, etayProc;
Wh<complex> phi, phiProc;
for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
  }

mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0){
  //Compute the reflection coefficient.
  cout<<"\n\n\n";
  cout<<"Non-Dim parameter Lc,Tc = "<<Lc<<","<<tc<<endl;
  phi=phi+phi0;
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;
  cout<<"Total Time = "<<mpiWtime()-cpu<<endl;
  mesh ThNewIce=movemesh(ThIce,[x+real(etax),y+real(etay)]);
  Wh rphi=real(phi);

  //Write data to MATLAB
  //iter could be used to index the solution.
  Vh ux=real(etax), uy=real(etay);
  int[int] Order=[1,1];
  savevtk("1_SIMPLE5/sol1_"+iter+".vtk",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
  savevtk("1_SIMPLE5/sol2_"+iter+".vtk",ThIce,[real(Sigma(etax,etay)[0]), real(Sigma(etax,etay)[1]), real(Sigma(etax,etay)[2])],[imag(Sigma(etax,etay)[0]), imag(Sigma(etax,etay)[1]), imag(Sigma(etax,etay)[2])],dataname="ReSigma ImSigma",order=Order);
  savevtk("1_SIMPLE5/solCavity"+iter+".vtk",ThCavity,[real(phi),imag(phi)],dataname="RePhi ImPhi",order=Order);

  writeEigen(1,1);
 }
