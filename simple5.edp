//Simple example to demonstrate the ice-shelf toolbox;
//Invoking Domain decomposition technique.

verbosity=0.;
real cpu=mpiWtime();
bool debug=true;
string SolutionDir="1_SIMPLE5/";

include "macros.idp"

macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM (Macro to define the stress tensor)"

//Sets up an example problem. Can control input using CMD line args.
//For a detailed list of default args. Refer the manual.
nev=64;
setProblem;

//Solve the dispersion equation -k tan(k h) = \alpha. -k tan(k (h-d)) = \alpha
solveDispersion;

//Build the meshes.
real botRight=-3.*tth, midPX=3.7*LL/4, midPY=-2.5*tth;
setMeshIce(botRight, midPX, midPY);
real midx=LL/2., midy=-0.5*HH, endy=-HH;
setMeshCav(midx, midy, endy);

//Refine Mesh.
refineMesh;

//Split Mesh for domain decomposition
bool isSplit = getARGV("-isSplit",1);
if(isSplit)
  splitMeshSave;

Xh[int][VX,VY](nev); //Define an array of fe-function to store in-vacuo modes.
real[int] ev(nev); //Define a real array for the eigenvalues.
solveEigen;

//  2) Get the Non-local boundary condition
matrix<complex> MQ;
complex[int] ctilde(NModes+1);
Wh<complex> chi1;
MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
for(int m=0; m<NModes+1; m++)
  chi1 = chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

//Get the emptymesh and the solution on the boundary.
mesh ThEmptyCav=emptymesh(ThCavity);
fespace WhBdy(ThEmptyCav,P1);
if(mpirank==0)
  cout<<"Number of cavity boundary DOFs = "<<WhBdy.ndof<<endl;

//  3) Solve for the diffraction potential.
Wh<complex> phi0;
func fh=chi1;//Store in fh, the right-hand side function on the ocean-cavity interface.
getLaplaceMat(0,0);
LHS=STIMA+(MQ);
set(LHS,solver=UMFPACK,eps=1e-20);
phih[]=LHS^-1*RHS[];
phi0=phih;//Store in phi0;

//Interpolate to boundary.
WhBdy<complex> phi00=phi0;

/*
  if(mpirank==0)
  {
  complex[int] phiVec(phi0.n), c(NModes+1);
  phiVec=phi0[];
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c);
  //Write the reflection coefficient to a file.
  ofstream file("1_SIMPLE5/2_RefCoeff/RefCoeff_Dif/refC"+iter+".dat");
  file.precision(16);
  file<<real(Ref)<<"\t"<<imag(Ref)<<endl;
  }
*/

//Solve for radiation potential.
int parti = nev/mpisize;

Wh<complex>[int] phij(nev);
//Define array of boundary functions.
WhBdy<complex>[int] phijj(nev);

F.resize(nev);
B.resize(nev,nev);
K.resize(nev,nev);
AB.resize(nev,nev);
complex[int] FProc(nev), RefmProc(nev), Refm(nev);
complex[int,int] BProc(nev,nev), KProc(nev,nev);
complex[int,int] PHIJ(nev,WhBdy.ndof),PHIJProc(nev,WhBdy.ndof);
complex[int] phiVecm(phih.n), cc(NModes+1), pk1(NModes+1);

for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    real cpu1=mpiWtime();
    func fh=0;
    getLaplaceMat(VX[m],VY[m]);
    LHS=STIMA+(MQ);
    set(LHS,solver=UMFPACK,eps=1e-20);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih; //Leave the bulk as it is. This will not be used in constructing the matrices.

    //Interpolate on the BOUNDARY alone and store in matrix. This will be used in the construction of the matrices
    phijj[m]=phih;
    PHIJProc(m,:)=phijj[m][];

    //Compute the radiation reflection coefficients
    /*
      pk1=0.;
      phiVecm = phij[m][];
      RefmProc[m] = getRefModes(ThCavity, NModes, kd, k, phiVecm, HH, dd, Ap, cc, pk1);
    */
    if(mpirank==0)
      cout<<"P: "<<mpirank<<" S: "<<mpiWtime()-cpu1<<"s "<<endl;
  }
real cpuComm=mpiWtime();
mpiAllReduce(PHIJProc,PHIJ,mpiCommWorld,mpiSUM); //Collect on all cpus.
cout<<"P: "<<mpirank<<" C: "<<mpiWtime()-cpuComm<<endl;
//mpiReduce(RefmProc,Refm,processor(0),mpiSUM);

//Unpack and set to phij locally in all procs (Only boundary)
for(int m=0; m<nev; m++){
  phijj[m][]=PHIJ(m,:);
 }

//Load the split mesh.
splitMeshLoad;

real cpu1=mpiWtime();
buildReducedSystemOptim;
//buildReducedSystem(VX,VY,phi0,phij);
cout<<"No of vertices: "<<MaThEmpty.nv<<"\t Time in processor "<<mpirank<<" = "<<mpiWtime()-cpu1<<"\t s"<<endl;

if(mpirank==0) //Write the matrices to a file.
  {
    ofstream file1("1_SIMPLE5/2_ModesMatrix/ReH"+iter+".dat");
    ofstream file2("1_SIMPLE5/2_ModesMatrix/ImH"+iter+".dat");
    ofstream file3("1_SIMPLE5/2_ModesMatrix/ReF"+iter+".dat");
    ofstream file4("1_SIMPLE5/2_ModesMatrix/ImF"+iter+".dat");
    ofstream file5("1_SIMPLE5/2_RefCoeff/RefCoeff_Rad/refC"+iter+".dat");
    file1.precision(16);
    file2.precision(16);
    file3.precision(16);
    file4.precision(16);
    for(int m=0; m<nev; m++)
      {
        file3<<real(F[m])<<endl;
        file4<<imag(F[m])<<endl;
        file5<<real(Refm[m])<<"\t"<<imag(Refm[m])<<endl;
        for(int n=0; n<nev; n++)
          {
            file1<<real(B(m,n)+K(m,n))<<endl;
            file2<<imag(B(m,n)+K(m,n))<<endl;
          }
      }
  }

//Solve the reduced system;
complex[int] xi(nev);
if(mpirank==0){
  matrix<complex> Kmat, Bmat, ABmat;
  Kmat=K;
  Bmat=B;
  ABmat=AB;
  HHmat=Kmat+Bmat+ABmat;
  set(HHmat,solver=UMFPACK,eps=1e-20);
  xi=HHmat^-1*F;
  /*
    complex[int,int] H(nev,nev), Hinv(nev,nev);
    H=K+B;
    H=H+AB;
    Hinv=H^-1;
    matrix<complex> HHmat=Hinv;;
    xi=HHmat*F;
  */
  //Write solution vector to file.
  ofstream file1("1_SIMPLE5/2_ModesMatrix/lambdaj"+iter+".dat");
  file1.precision(8);
  for(int m=0; m<nev; m++)
    file1<<real(xi[m])<<"\t"<<imag(xi[m])<<endl;
 }
broadcast(processor(0),xi);

//Compute the solution.
Vh <complex> etax, etay, etaxProc, etayProc;
Wh<complex> phi, phiProc;
for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
  }

mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0){
  //Compute the reflection coefficient.
  cout<<"\n\n\n";
  cout<<"Non-Dim parameter Lc,Tc = "<<Lc<<","<<tc<<endl;
  phi=phi+phi0;
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;
  cout<<"Total Time = "<<mpiWtime()-cpu<<endl;
  mesh ThNewIce=movemesh(ThIce,[x+real(etax),y+real(etay)]);
  Wh rphi=real(phi);

  //Write data to MATLAB
  //iter could be used to index the solution.
  Vh ux=real(etax), uy=real(etay);
  int[int] Order=[1,1];
  savevtk("1_SIMPLE5/sol1_"+iter+".vtk",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
  savevtk("1_SIMPLE5/sol2_"+iter+".vtk",ThIce,[real(Sigma(etax,etay)[0]), real(Sigma(etax,etay)[1]), real(Sigma(etax,etay)[2])],[imag(Sigma(etax,etay)[0]), imag(Sigma(etax,etay)[1]), imag(Sigma(etax,etay)[2])],dataname="ReSigma ImSigma",order=Order);
  savevtk("1_SIMPLE5/solCavity"+iter+".vtk",ThCavity,[real(phi),imag(phi)],dataname="RePhi ImPhi",order=Order);

  ofstream file("1_SIMPLE5/2_Modes/eval.dat");
  for(int m=0; m<nev; m++)
    file<<ev[m]<<endl;
  writeEigen;
 }
