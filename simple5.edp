//Simple example to demonstrate the ice-shelf toolbox;

verbosity=0.;
real cpu;
if(mpirank==0)
  cpu=clock();
bool debug=true;
include "macros.idp"
string SolutionDir="1_Forced/";

//Sets up an example problem. Can control input using CMD line args.
//For a detailed list of default args. Refer the manual.
setProblem;

//Solve the dispersion equation -k tan(k h) = \alpha. -k tan(k (h-d)) = \alpha
solveDispersion;

mpiBarrier;

//Build the meshes.
real botRight=-3.*tth, midPX=3.7*LL/4, midPY=-2.5*tth;
setMeshIce(botRight, midPX, midPY);
//cout<<"Built ice mesh"<<endl;

real midx=LL/2., midy=-0.5*HH, endy=-HH;
setMeshCav(midx, midy, endy);
//cout<<"Built cavity mesh"<<endl;

if(mpirank==0){
  cout<<"Refine Ice--Mesh"<<endl;
  ThIce=adaptmesh(ThIce,0.01,IsMetric=1,nbvx=2e6);
  cout<<"Ice : Number of Vertices = "<<ThIce.nv<<endl;
 }
 else if(mpirank==1){
   cout<<"Refine Cavity--Mesh"<<endl;
   ThCavity=adaptmesh(ThCavity,0.01,IsMetric=1,nbvx=2e6);
   cout<<"Cavity : Number of Vertices = "<<ThCavity.nv<<endl;
 }
broadcast(processor(0),ThIce);
broadcast(processor(1),ThCavity);


Xh[int][VX,VY](nev); //Define an array of fe-function to store in-vacuo modes.
real[int] ev(nev); //Define a real array for the eigenvalues.
solveEigen;

mpiBarrier;

//  2) Get the Non-local boundary condition
matrix<complex> MQ;
complex[int] ctilde(NModes+1);
if(mpirank==0){
  MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
 }
 else if(mpirank==1){
   ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
 }
broadcast(processor(0),MQ);
broadcast(processor(1),ctilde);

Wh<complex> chi1;
for(int m=0; m<NModes+1; m++)
  chi1 = chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

mpiBarrier;

//  3) Solve for the diffraction potential.
Wh<complex> phi0;
if(mpirank==0){
  func fh=chi1;//Store in fh, the right-hand side function on the ocean-cavity interface.
  getLaplaceMat(0,0);
  LHS=STIMA+(MQ);
  set(LHS,solver=sparsesolver);
  phih[]=LHS^-1*RHS[];
  phi0=phih;//Store in phi0;
 }
broadcast(processor(0),phi0[]);


//  4) Solve for radiation potential.
int partition = nev/mpisize;
Wh<complex>[int] phij(nev);
F.resize(nev);
B.resize(nev,nev);
K.resize(nev,nev);
complex[int] FProc(nev);
complex[int,int] BProc(nev,nev), KProc(nev,nev);
for(int m=mpirank*partition; m<mpirank*partition+partition; m++)
  {
    func fh=0;
    getLaplaceMat(VX[m],VY[m]);
    LHS=STIMA+(MQ);
    set(LHS,solver=sparsesolver);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    FProc[m]=-(1i*omega*gammahat)*int1d(ThIce,1,qforder=10)(phi0*(VX[m]*N.x+VY[m]*N.y));
    for(int n=0; n<nev; n++)
      {
        BProc(m,n) = (rhoi*ev[m]-rhoi*omega^2)*int2d(ThIce)(VX[m]*VX[n]+VY[m]*VY[n]);
        KProc(n,m) = int1d(ThIce,1,qforder=10)((-VY[m]*deltahat + phij[m]*(1i*omega*gammahat))*(VX[n]*N.x+VY[n]*N.y));
      }
  }
mpiReduce(BProc, B, processor(0), mpiSUM);
mpiReduce(KProc, K, processor(0), mpiSUM);
mpiReduce(FProc, F, processor(0), mpiSUM);

mpiBarrier;

//Solve the reduced system;
complex[int] xi(nev);
if(mpirank==0){
  solveReducedSystem;
 }
broadcast(processor(0),xi);

//Compute the solution.
Vh <complex> etax, etay, etaxProc, etayProc;
Wh<complex> phi, phiProc;
for(int m=mpirank*partition; m<mpirank*partition+partition; m++)
  {
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
  }

mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0){
  //Compute the reflection coefficient.
  phi=phi+phi0;
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;

  mesh ThNewIce=movemesh(ThIce,[x+real(etax),y+real(etay)]);
  plot(ThNewIce,wait=1,ps="deformedMesh.eps");
  Wh rphi=real(phi);
  plot(rphi,wait=1,fill=1,value=1,ps="velocity.eps");

  //Write data to MATLAB
  //iter could be used to index the solution.
  Vh ux=real(etax), uy=real(etay);
  /*
    writeToMATLAB(ux,ThIce,"xDisp"+iter+".bb","meshIce"+iter+".msh");
    writeToMATLAB(uy,ThIce,"yDisp"+iter+".bb","meshIce"+iter+".msh");
    writeToMATLAB(rphi,ThCavity,"potentialCav"+iter+".bb","meshCav"+iter+".msh");
  */
 }
if(mpirank==0)
  cout<<clock()-cpu<<" s"<<endl;
