/*
  Ice shelf with linear elasticity (complete)
  ********************************************************************************
  -> iceSpline.edp VERIFIED WITH square/ndIceShelf.edp
  -> square/ndIceShelf.edp VERIFIED WITH square/icefem.edp
  -> square/icefem.edp VERIFIED WITH MATLAB's Euler Bernoulli for the thin case
  ********************************************************************************
  */
//Function to compute the roots of the dispersion equation
verbosity = 0;
bool debug = false;
load "lapack"
include "getARGV.idp"
//---- From the iceShelf-toolbox --
include "dispersionFreeSurface.idp"
include "getMatrices.idp"
include "spline.idp"
include "nonLocal.idp"
include "refCoeff.idp"
include "getProperties.idp"
//---------------------------------
//------ Input data for the ice shelf.
bool isUniform=getARGV("-isUni",1);
int N1 = getARGV("-N",4);
int N2 = getARGV("-N",4);
real L = getARGV("-L",10000.), H = getARGV("-H",500.), th = getARGV("-h",100.);
real E, nu, rhow, rhoi, ag, Ad;
real[int] LC = getProps(E, nu, rhoi, rhow, ag, Ad);
real d = rhoi/rhow*th;
//--- Complex Wave-Periods
real tr = getARGV("-Tr",200.);
real ti = getARGV("-Ti",0.);
complex t = tr+1i*ti;
//---
real EI = E*th^3/(12*(1-nu^2));
real Lc = (EI/(rhow*ag))^(1./4.), tc = sqrt(rhow*Lc^6/(EI*H));
complex omega = 2*pi/t;

//Find out the non dimensional quanities.
real LL = L/Lc, HH = H/Lc, dd = d/Lc, tth = th/Lc;
complex tt = t/tc;
complex ndOmega = 2*pi/tt;
int NModes = 5;
int Nfreq = 20;
macro grad(u) [dx(u),dy(u)]//EOM''
  complex alpha = HH*ndOmega^2;
complex Ap = ag/(1i*omega)*Ad;

//------ Find the eigenvalues of the dispersion equation.
complex [int] k(NModes+1), kd(NModes+1);
k = dispersionfreesurface(alpha, NModes, HH); //From "dispersionFreeSurface.idp"
k[0] = -k[0];
kd = dispersionfreesurface(alpha, NModes, HH-dd); //From "dispersionFreeSurface.idp"
kd[0] = -kd[0];

//------ Find the Lame constants.
real mu = LC[0];
real lambda = LC[1];
real muhat = mu/Lc^2;
real lambdahat = lambda/Lc^2;

/*
  ------ Solve the Eigenvalue problem.
*/
macro div(u,v) (dx(u)+dy(v))//EOM''
macro epsilon(u1,u2) [dx(u1), dy(u2), (dy(u1)+dx(u2))/sqrt(2.)]//EOM''

//Construct the appropriate ice/shelf profiles
real icetopleft, icebottomleft, icebottomright, ix2, iy2;
if(isUniform==true){
  icetopleft = (1-rhoi/rhow)*(th/Lc);
  icebottomleft = -(rhoi/rhow)*(th/Lc);
  icebottomright = -(rhoi/rhow)*(th/Lc);
  ix2 = 3.7*LL/4;
  iy2 = -(rhoi/rhow)*(th/Lc);
 }
 else{
   icetopleft = (1-rhoi/rhow)*(th/Lc);
   icebottomleft = -(rhoi/rhow)*(th/Lc);
   icebottomright = -3.*th/Lc; //Thickens towards the grounding line.
   ix2 = 3.7*LL/4;
   iy2 = -2.5*(th/Lc);
 }
real ix1 = 0, iy1 = icebottomleft;
real ix3 = LL, iy3 = icebottomright;
//Build the border for the ice-shelf and mesh it.
border I01(t=0,LL) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=1;};
border I02(t=iy3,icetopleft) {x=LL; y=t; label=2;};
border I03(t=LL,0) {x=t; y=icetopleft; label=3;};
border I04i(t=icetopleft,0) {x=0; y=t; label=4;};
border I04ii(t=0,icebottomleft){x=0; y=t; label=5;};
mesh ThIce = buildmesh(I01(L/th*N1)+I02(N1)+I03(L/th*N1)+I04i(L/th*N1/2)+I04ii(L/th*N1/2));
//mesh ThIce = buildmesh(I01(10*N1)+I02(N1)+I03(10*N1)+I04i(N1/2)+I04ii(N1/2));
plot(ThIce,wait=true);
//--------------------------------------------------------
fespace Vh(ThIce,P1);
fespace Xh(ThIce,[P1,P1]);
Xh [u,v],[uu,vv];
//varf a([u,v],[uu,vv]) = int2d(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + on(2,u=0,v=0);
varf a([u,v],[uu,vv]) = int2d(ThIce)(lambdahat*div(u,v)*div(uu,vv) + 2*muhat*epsilon(u,v)'*epsilon(uu,vv)) + int1d(ThIce,1)(0*(u*uu+v*vv)*rhoi*ag/Lc) + on(2,u=0,v=0);
varf b([u,v],[uu,vv]) = int2d(ThIce,qft=qf1pTlump)(rhoi*(u*uu + v*vv));
matrix stima = a(Xh,Xh,solver=sparsesolver);
matrix massma = b(Xh,Xh,solver=sparsesolver);
real nev = Nfreq;
real [int] ev(nev);
Xh [int] [VX,VY](nev);
int kkk = EigenValue(stima,massma,sym=true,sigma=0,value=ev,vector=VX,tol=1e-10);
//for(int m=0; m<nev; m++)
//  {
//cout<<"EigenValue="<<ev[m]<<endl;
//  }
/*
  --End solving the Eigenvalue problem for the in-vacuo modes.
*/

//------ Mesh the cavity region.
real x1,x2,x3,y1,y2,y3;
if(isUniform){
  x1=0.; y1=-HH;
  x2=LL/2; y2=-HH;
  x3=LL; y3=-HH;
 } else{
  x1=0.; y1=-HH;
  x2=LL/2; y2=-2.6*th/Lc;
  x3=LL; y3=-3.3*th/Lc;
 }
border C01(t=0,LL) {x = t; y=splineCurve(t,x1,y1,x2,y2,x3,y3); label=1;};
border C02(t=y3,iy3) {x=LL; y=t; label=2;};
border C03(t=LL,0) {x=t; y=splineCurve(t,ix1,iy1,ix2,iy2,ix3,iy3); label=3;};
border C04(t=icebottomleft,y1) {x=0; y=t; label=4;};
//-------- Change the mesh here from square to spline-type
//mesh ThCavity = buildmesh(C01(L/th*N2)+C02(N2)+C03(L/th*N2)+C04(N2));
mesh ThCavity = buildmesh(C01(L/th*N2)+C02(N2)+C03(L/th*N2)+C04(N2));
plot(ThCavity,ThIce,wait=true);
//--End meshing the cavity region.

/*
  Begin block to get the Non-Local boundary condition.
  -> First obtain the Q operator and the function chi(z)
  -> The boundary condition on the shelf-front is accounted in the for-loop.
*/
fespace Wh(ThCavity,P1);
matrix<complex> MQ;
MQ = getQphi(ThCavity, NModes, k, kd, HH, dd, Ap, 4); //From "nonLocal.idp"
complex [int] ctilde(NModes+1);
ctilde = getChi(ThCavity, NModes, k, kd, HH, dd, Ap); //From "nonLocal.idp"
Wh<complex> chi1;
for(int m=0; m<NModes+1; m++)
  {
    Wh <complex> eigenfunc = ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));
    chi1 = chi1 + eigenfunc;
  }
func fh = chi1; //Get the function in terms of y


//------ Solving for the potential.
//-> First,compute the Diffraction potential.
Wh <complex> phih,psih, phi,phi0;
Vh <complex> etax, etay;
varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
varf lh(unused,psih) = int1d(ThCavity,4,qforder=10)(-fh*psih);//Normal points negative
matrix <complex> KMatrix = ah(Wh,Wh);
matrix <complex> LHS = KMatrix + (MQ);//Normal points negative
Wh <complex> RHS;
RHS[] = lh(0,Wh);
set(LHS,solver=sparsesolver);
phih[] = LHS^-1*RHS[];
phi0 = phih;
plot(phi0,wait=debug,fill=debug,value=debug);

//-> Next,solve for Radiation potentials and get the system of equations for the modes.
complex [int,int] B(nev,nev), K(nev,nev), AB(nev,nev), Hmat(nev,nev);
complex [int] F(nev);
Wh <complex> [int] phij(nev);
real gammahat = rhow/Lc, deltahat = rhow*ag/Lc; // Scaled down constants gammahat and deltahat.
for(int m=0; m<nev; m++)
  {
    //Part to get the forcing on the submerged part of the ice.
    complex[int] pk(NModes+1);

    //------ Insert the nonlocal construction module here entirely ------
    int nbv = ThCavity.nv;
    complex [int] f(NModes+1), g(NModes+1);
    complex [int,int] A(NModes+1,NModes+1), MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1), D(nbv,NModes+1);
    int flag = getMat(ThCavity, k, kd, HH, dd, Ap, NModes, A, f, g, MM, MMt, D);    
    for(int p=0; p<NModes+1; p++)
      {
        func phim = cos(k[p]*(y+HH))/cos(k[p]*HH);
        pk[p] = int1d(ThIce,5,qforder=10)(-1i*omega*Lc*VX[m]*N.x*phim); //The contribution to the kinematic boundary condition.
      }
    complex [int,int] MMtinv = MMt^-1; 
    pk = MMtinv*pk;
    //-------------------------------------------------------------------    
    Wh<complex> chi1;
    for(int p=0; p<NModes+1; p++)
      {
        Wh <complex> eigenfunc = pk[p]*cos(kd[p]*(y+HH))/cos(kd[p]*(HH-dd));
        chi1 = chi1 + eigenfunc;
      }
    func fk=chi1;   

    //func fk = 0; //Uncomment this when no-flow-boundary condition is applied on the front.
    
    
    varf ah(phih,psih) = int2d(ThCavity)(grad(phih)'*grad(psih));
    varf lh(unused,psih) = int1d(ThCavity,3,qforder=10)(-1i*omega*Lc*(VX[m]*N.x+VY[m]*N.y)*psih) + int1d(ThCavity,4,qforder=10)(-fk*psih);
    matrix <complex> KMatrix = ah(Wh,Wh), LHS = KMatrix + (MQ);//Normal points towards negative.
    Wh <complex> RHS;
    RHS[] = lh(0,Wh);
    set(LHS,solver=sparsesolver);
    phih[] = LHS^-1*RHS[];
    phij[m]=phih;
    plot(phij[m],wait=debug,fill=true,value=true,dim=3);

    F[m] = -(1i*omega*gammahat)*(int1d(ThIce,1,qforder=10)(phi0*(VX[m]*N.x + VY[m]*N.y)));
    for(int n=0; n<nev; n++)
      {
        B(m,n) = (rhoi*ev[m]-rhoi*omega^2)*int2d(ThIce)(VX[m]*VX[n] + VY[m]*VY[n]);
        //        K(m,n) = (deltahat)*int1d(ThIce,1,qforder=10)(VX[m]*VX[n] + VY[m]*VY[n]);
        K(n,m) = (deltahat)*int1d(ThIce,1,qforder=10)(-VY[m]*(VX[n]*N.x+VY[n]*N.y));
        AB(n,m) = (1i*omega*gammahat)*(int1d(ThIce,1,qforder=10)(phij[m]*(VX[n]*N.x + VY[n]*N.y)));
      }
  }

//--------------------- Writing down all the data to a folder -----------------------
int iter=getARGV("-iter",0);
string SolutionDir="./1_NoSolve/";
//------ The H matrix to a file.
{
  ofstream file(SolutionDir+"2_ModesMatrix/ReH"+iter+".dat");
  file.precision(16);
  for(int m=0; m<nev; m++) {
    for(int n=0; n<nev; n++)
      file<<real(K(m,n)+B(m,n)+AB(m,n))<<" ";
    file<<endl;
  }
}
{
  ofstream file(SolutionDir+"2_ModesMatrix/ImH"+iter+".dat");
  file.precision(16);
  for(int m=0; m<nev; m++) {
    for(int n=0; n<nev; n++)
      file<<imag(K(m,n)+B(m,n)+AB(m,n))<<" ";
    file<<endl;
  }
}

/* Data for FUN~
//------ Write down the von-mises stress file
{
//  ofstream file("/data/carma/Users/c3293624/KinBC/vmStressNoForce"+round(t)+"_"+round(th)+".bb");
ofstream file("iceForcing/NoForce/vmStress.bb");
file.precision(16);
file<<"2 1 1 "<<sigmavm.n<<" 2 \n";
for(int m=0; m<sigmavm[].n; m++)
file<<sigmaxy[][m]<<endl;
}

//------ Write down the potential
{
ofstream file("iceForcing/NoForce/potential.bb");
p  file.precision(16);
file<<"2 1 1 "<<phi.n<<" 2 \n";
for(int m=0; m<phi[].n; m++)
file<<phi[][m]<<endl;
}
*/
