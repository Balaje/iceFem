/*
Program to solve the ice shelf problem in 3d.
-> 
*/
verbosity = 0;
bool debug = false;
load "lapack"
load "msh3"
load "medit"

func complex oneroot(complex alpha, complex guess)
{
  complex ans1 = guess + 1;
  complex out = guess;
  complex f, difff;
  while (abs(ans1-out) > 1e-9)
    {
      ans1 = out;
      f = ans1*tanh(ans1) - alpha;
      difff = tanh(ans1) + ans1*(1/cosh(ans1))^2;
      out = ans1 - f/difff;
    }
  return out;
}
func complex homotopy(complex alpha, int N1)
{
  complex mroot;
  if(N1==0)
    mroot = oneroot(1,1);
  else
    mroot = oneroot(1,1i*N1*pi);

  real step = 0.043;
  //This function is used only in homotopy() - To generate the alphastep vector
  func real[int] genalphastep(int start, real last, real step)
  {
    int length = floor((last-start)/step);
    real[int] alphastep(length+2);
    for (int m=0; m<length+2; m++)
      alphastep[m] = start  + m*step;
    alphastep[length+1] = abs(last);
    return alphastep;
  }
  //End of Function
  real [int] alphastep = genalphastep(1, abs(alpha), -step*(abs(alpha)<1) + step*(abs(alpha)>=1));
  for (int m=1; m<alphastep.n; m++)
    mroot = oneroot(alphastep[m], mroot);

  real [int] argstep = genalphastep(0, arg(alpha), -(pi/30.)*(arg(alpha)<0) + (pi/30.)*(arg(alpha)>=0));
  argstep[(argstep.n)-1] = arg(alpha);
  complex [int] newalphastep(argstep.n);
  for (int m=1; m<argstep.n; m++)
    {
      newalphastep[m] = abs(alpha)*exp(1i*argstep[m]);
      mroot = oneroot(newalphastep[m], mroot);
    }

  return mroot;
}
func complex[int] dispersionfreesurface(complex alph, int N1, real H)
{
  // Scale alpha = alpha*h;
  complex alpha = alph*H;
  complex [int] mroots(N1+1);
  int count;
  if (N1==0)
    {
      count = 0;
      mroots[count] = homotopy(alpha,count);
    }
  else
    {
      count = 0;
      mroots[count] = homotopy(alpha,count);
      count = count + 1;
      while (0<=1)
        {
          mroots[count] = homotopy(alpha,count);
          if(abs( mroots[count] - (1i*(count)*pi+alpha/(1i*(count)*pi)) ) < 0.01)
            {
              while (0<=1)
                {
                  mroots[count] = oneroot(alpha, 1i*(count)*pi + alpha/(1i*(count)*pi));
                  if(abs( mroots[count] - (1i*(count)*pi + alpha/(1i*(count)*pi)) ) < 1e-15)
                    {
                      for(int m=0; m<N1-count; m++)
                        mroots[count+m+1] = 1i*(count+m)*pi + alpha/(1i*(count+m)*pi);
                      count = N1;
                      break;
                    }
                  if(count==N1)
                    break;
                  count = count + 1;
                }
            }
          if(count==N1)
            break;
          count = count + 1;
        }
    }
  mroots = -(1i/H)*mroots;
  mroots[0] = -mroots[0];
  return mroots;
}
//---End of module to find the roots of the dispersion equation.
//---Input the data for the ice shelf.
real LL = 20000, HH = 800, tth = 200;
real wid = 1000; //New parameter for the width of the ice-shelf.
real rhow = 1025, rhoi = 922.5;
real dd = (rhoi/rhow)*tth;
real E = 11e9, nu = 0.33;
real EI = E*tth^3/(12*(1-nu^2));
real t = 200;//Dimensional time period
real ag = 9.8;
real lambda = E*nu/((1+nu)*(1-2*nu));
real mu = E/(2*(1+nu));
real Ad = 0.6;
real omega = (2*pi/t);
complex Ap = (ag/(1i*omega))*Ad;

//Characteristic Constants
real Lc = (EI/(rhow*ag))^(1./4.);
real tc = sqrt(rhow*Lc^6/(EI*HH));

//Non dimensional constants
real L = LL/Lc, H = HH/Lc, d = dd/Lc, th = tth/Lc;
real ww = wid/Lc;
real ndOmega = omega*tc;
real alpha = ndOmega^2*H;

//Roots of the dispersion equations
int NModes = 5;
complex [int] k(NModes+1), kd(NModes+1);
k = dispersionfreesurface(alpha,NModes,H);
k[0]=-k[0];
kd = dispersionfreesurface(alpha,NModes,H-d);
kd[0]=-kd[0];


//Construct a cubic mesh for the ice shelf.
int[int] l6 = [1,2,3,4,5,6];
int N1 = 80;
real iceBottom = -d, iceTop = 0.1*th;
mesh3 ThIce = cube(N1,N1/20,N1/20,[L*x,ww*y,iceBottom+(iceTop-iceBottom)*z],label=l6,flags=3,region=11);
plot(ThIce, wait=true);
//Construct a cubic mesh for the cavity
int N2 = 80;
real cavityBottom = -H;
//mesh3 ThCavity = buildlayers(square(N1,N1,[L*x,ww*y]),N1,zbound=[cavityBottom,iceBottom]);
mesh3 ThCavity = cube(N2,N2/20,N2/20,[L*x,ww*y,cavityBottom+(iceBottom-cavityBottom)*z],label=l6,flags=3,region=11);
plot(ThCavity,wait=true);
plot(ThIce,ThCavity,wait=true);
//Done constructing the mesh.


//******************************************
//******************************************


//Construction of the non-local boundary condition.

//plot(InterfacePlane,wait=true);
complex [int] f(NModes+1), g(NModes+1);
complex [int,int] MM(NModes+1,NModes+1), MMt(NModes+1,NModes+1), D2(NModes+1,NModes+1), D1(NModes+1,NModes+1);

func phih0 = cos(k[0]*y)*cos(k[0]*(z+H));
for(int m=0; m<NModes+1; m++)
  {
    func phidm = cos(kd[m]*y)*cos(kd[m]*(z+H));
    func phim = cos(k[m]*y)*cos(k[m]*(z+H));
    f(m) = int2d(ThCavity,4,qforder=6)(Ap*phih0*phidm);
    D2(m,m) = sqrt(2.)*k[m]*sin(k[m]*ww)*(sin(2*k[m]*H)+2*H*k[m])/(4*k[m]^2);
    for(int n=0; n<NModes+1; n++)
      {
	func phidn = cos(kd[n]*y)*cos(kd[n]*(z+H));
	func phin = cos(k[n]*y)*cos(k[n]*(z+H));

	MM(m,n) = int2d(ThCavity,4,qforder=6)(phidm*phin);
	MMt(n,m) = MM(m,n);
      }
  }
g = 0;
g[0]=-Ap*D2(0,0);

// Plot the shape of the incident wave along the x-direction.
// Since the ocean is a semi infinite domain - we truncate the x-direction to 2*L 
// -L since x < 0 for the ocean.
mesh ThOcean = square(40,40,[-2*L*x, ww*y]);
fespace OH(ThOcean, P1);
OH<complex> iWave = exp(sqrt(2.)*k[0]*x)*cos(k[0]*y);
OH rIwave = real(iWave);


//Find all the interface nodes in the interface plane.
int nbv = ThCavity.nv;
real [int] interfacepointsX(0), interfacepointsY(0), interfacepointsZ(0);
real [int] interfacenodes(0);

int counter = 0;
for(int m=0; m<nbv; m++)
  {
    if(ThCavity(m).x==0)
      {
	interfacepointsX.resize(interfacepointsX.n+1);
	interfacepointsY.resize(interfacepointsY.n+1);
	interfacepointsZ.resize(interfacepointsZ.n+1);
	interfacenodes.resize(interfacenodes.n+1);
	interfacepointsX(counter) = ThCavity(m).x;
	interfacepointsY(counter) = ThCavity(m).y;
	interfacepointsZ(counter) = ThCavity(m).z;
	interfacenodes(counter) = m;
	counter += 1;
      }
  }
cout<<endl;
counter = 0; //Reset counter if needed to be used again.
//D is the DOF of the eigenfunctions at the interface.
complex [int,int] D(nbv,NModes+1);
D = 0;
for(int m=0; m<interfacepointsZ.n; m++)
  for(int n=0; n<NModes+1; n++)
    D(interfacenodes[m],n) = cos(kd[n]*(interfacepointsZ[m]+H))*cos(kd[n]*interfacepointsY[m]);

//Find out the Q Matrix.
fespace Wh(ThCavity, P1);
complex[int,int] pp(NModes+1,nbv);
pp = 0;
for(int m=0; m<NModes+1; m++)
  {
    func eigenfunc = cos(kd[m]*y)*cos(kd[m]*(z+H));
    varf planeIp(unused,vh) = int2d(ThCavity,4,qforder=6)(eigenfunc*vh);
    Wh<complex> ph;
    ph[] = planeIp(0,Wh);
    pp(m,:) = ph[];
  }
complex [int,int] MMinv = MM^-1;
complex [int,int] MMtinv = MMt^-1;
complex [int,int] TT = MMtinv*D2;
complex [int,int] T = TT*MMinv;
complex [int,int] tP = T*pp;
complex [int,int] Qp = D*tP;
matrix <complex> Q = Qp;
// Obtain the 2d Mass Matrix on the plane.
varf mh(uh,vh) = int2d(ThCavity,4,qforder=6)(uh*vh);
matrix <complex> MMatrix = mh(Wh,Wh);
matrix <complex> MQ = MMatrix*Q;
//Obtain the right hand side function. \chi(y)
complex [int] Mg = MMtinv*g;
complex [int] Tf = T*f, ctilde(NModes+1);
ctilde = Mg-Tf;
Wh <complex> chi1;
for(int m=0; m<NModes+1; m++)
  {
    Wh <complex> eigenfunc = ctilde[m]*cos(kd[m]*(z+H))*cos(kd[m]*y);
    chi1 = chi1 + eigenfunc;
  }
func fh = chi1;

//Define all the bilinear forms to obtain the corresponding matrices
real lambdahat = lambda/Lc^2, muhat = mu/Lc^2;
real gammahat = rhow/Lc, deltahat = rhow*ag/Lc;

macro grad(u)[dx(u), dy(u), dz(u)]//EOM"
macro div(u,v,w)(dx(u)+dy(v)+dz(w))//EOM"
macro epsilon(u,v,w)[dx(u), dy(v), dz(w), (dy(u)+dx(v))/sqrt(2.), (dz(v)+dy(w))/sqrt(2.), (dx(w)+dz(u))/sqrt(2.)]//EOM"


//On the ice
fespace Vh(ThIce,[P1,P1,P1]);
Vh <complex> [u,v,w],[uu,vv,www];
fespace Xh(ThIce,P1);
Xh<complex> phi;
varf ah([u,v,w],[uu,vv,www]) = int3d(ThIce)(lambdahat*div(u,v,w)*div(uu,vv,www) + 2*muhat*epsilon(u,v,w)'*epsilon(uu,vv,www)) - int3d(ThIce)(omega^2*rhoi*(u*uu+v*vv+w*www)) + on(2,u=0,v=0,w=0);
varf l1d([u,v,w],[uu,vv,www]) = int2d(ThIce,5,qforder=6)(u*uu+v*vv+w*www);
varf coupled([phi,unused],[uu,vv,www]) = int2d(ThIce,5,qforder=6)(phi*(uu*N.x+vv*N.y+www*N.z));

//In the cavity
Wh <complex> phih, chih;
Wh <complex> ux, uy, uz;
fespace Yh(ThCavity,[P1,P1,P1]);

varf ap(phih,chih) = int3d(ThCavity)(grad(phih)'*grad(chih));
varf bdyip([ux,uy,uz],[chih,unused]) = int2d(ThCavity,6,qforder=6)((ux*N.x+uy*N.y+uz*N.z)*chih);
varf source(unused,chih) = int2d(ThCavity,4,qforder=6)(-fh*chih);

//Obtain all the matrices
matrix<complex> iceK = ah(Vh,Vh);
matrix<complex> iceB = l1d(Vh,Vh);
matrix<complex> iceAB = coupled(Xh,Vh);
matrix<complex> cavityP = ap(Wh,Wh);
matrix<complex> cavityQ = bdyip(Yh,Wh);
// We have MQ for the non local boundary condition
// Linear part - Let us name it nlForce (non-local Force)
Wh<complex> nlForce;
nlForce[]=source(0,Wh);
complex [int] force = nlForce[];

int totalDof = 4*nlForce.n;
//Get all the blocks of the full matrix
matrix<complex> B1 = iceK + (deltahat)*iceB;
matrix<complex> B2 = 1i*omega*(gammahat)*iceAB;
matrix<complex> B3 = 1i*omega*(Lc)*cavityQ;
matrix<complex> B4 = cavityP + MQ;

matrix<complex> LHS;

LHS = [[B1, B2], [B3, B4]];
complex [int] RHS(totalDof);
for(int m=0; m<force.n; m++)
  RHS[3*force.n + m] = force[m];

complex [int] sol(totalDof);
set(LHS,solver=UMFPACK);
sol = LHS^-1*RHS;

int[int] ONES = 0:3:3*force.n-3;
int[int] TWOS = 1:3:3*force.n-2;
int[int] THREES = 2:3:3*force.n-1;
complex [int] UX(ONES.n), UY(ONES.n), UZ(ONES.n);
for(int m=0; m<ONES.n; m++)
  {
    UX[m] = sol(ONES[m]);
    UY[m] = sol(TWOS[m]);
    UZ[m] = sol(THREES[m]);
  }

Wh<complex> pot = sol(3*force.n:totalDof-1);
Xh<complex> uhx = UX, uhy = UY, uhz = UZ;

Xh rux = real(uhx)/Ad, ruy = real(uhy)/Ad, ruz = real(uhz)/Ad;

int coef = 1;
mesh3 newIceMesh = movemesh(ThIce,[x+coef*rux, y+coef*ruy, z+coef*ruz]);

//plot(pot,wait=true,value=true,fill=true);
//plot(rux,wait=true,value=true,fill=true,ShowMeshes=false);
plot(newIceMesh,wait=true);

//Trying to find out the reflection coefficient
complex [int] aa(NModes+1), bb(NModes+1), c(NModes+1);
complex [int,int] A(NModes+1,NModes+1);
for(int m=0; m<NModes+1; m++)
  {
    func eigenfunc = cos(kd[m]*(z+H))*cos(kd[m]*y);
    aa(m) = int2d(ThCavity,4,qforder=6)(pot*eigenfunc);
  }

c = MMinv*f; aa = MMinv*aa;
c = -c+aa;

/*
bb = T*aa; bb = bb+Mg; bb = bb-Tf;
c = MMt*bb; c = c-g;
complex [int,int] AA=D2^-1;
c = AA*c;
*/

complex Ref = c[0]/Ap;
cout<<"---------------------------------------------"<<endl;
cout<<"The Reflection Coefficient = "<<Ref<<endl;
cout<<"Absolute Value = "<<abs(Ref)<<endl;


medit("Velocity potential",ThCavity,real(pot));
medit("Displacement",newIceMesh);
