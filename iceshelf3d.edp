//Simple example to solve 3d problem.

verbosity=0;
macro dimension 3//EOM"
macro fspace 1//EOM"
include "macros.idp"

SolutionDir="1_SIMPLE3D/";

/*
  setProblem;
  setMeshIce(0,0,0);
  setMeshCav(0,0,0);
  solveDispersion;
*/

setMeshIceCav3d;
alpha=omega^2/10;
//cout<<alpha<<endl;
k=dispersionfreesurface(alpha,NModes,HH);
k[0]=-k[0];
kd=k;
dd=0;

//---- Find the eigenvalues of the dispersion relation.
Xh[int][VX,VY,VZ](nev);
real[int] ev(nev);
solveEigen;
writeEigen(1,1);


Wh<complex> chi1;
matrix<complex> MQ1, MQ2;
getQphi(5,MQ2); //Outlet
getQphi(4,MQ1); //Inlet
getChi;
for(int m=0; m<NModes+1; m++)
    chi1 = chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

if(mpirank==0)
    cout<<"Done Non-local boundary condition"<<endl;

splitMesh(isSplit);

Wh<complex> phi0;
func fh=chi1;
getLaplaceMat(0,0,0);
BMASSMA=alpha*BMASSMA;
LHS=STIMA+(MQ1)+(MQ2)+(-BMASSMA);
set(LHS,solver=sparsesolver);
phih[]=LHS^-1*RHS[];
phi0=phih;
WhBdy<complex> phi00=phi0;
{
    ofstream file1(SolutionDir+"2_RefCoeff/RefCoeff_Dif/refC"+iter+".dat");
    complex Ref;
    getRefCoeff(4,phi0,Ref);
    file1<<real(Ref)<<"\t"<<imag(Ref)<<endl;
}
{
    ofstream file1(SolutionDir+"2_RefCoeff/RefCoeff_Dif/refT"+iter+".dat");
    complex Ref;
    getRefModes(5,phi0,Ref);
    file1<<real(Ref)<<"\t"<<imag(Ref)<<endl;
}
if(mpirank==0)
    cout<<"Done diffraction potential "<<endl;

savevtk(SolutionDir+"2_Potential/solDif.vtu",ThCavity,real(phi0),dataname="RePhi");

Wh<complex>[int] phij(nev);
WhBdy<complex>[int] phijj(nev);
buildParti(nev);
complex[int,int] PHIJ(WhBdy.ndof,nev),PHIJProc(WhBdy.ndof,partisize);
complex[int] Refm(nev), RefmProc(nev), Reft(nev), ReftProc(nev);
for(int m=start; m<=stop; m++)
 {
     func fh=0;
     getLaplaceMat(VX[m],VY[m],VZ[m]);
     BMASSMA=alpha*BMASSMA;
     LHS=STIMA+(MQ1)+(MQ2)+(-BMASSMA);
     set(LHS,solver=sparsesolver);
     phih[]=LHS^-1*RHS[];
     phij[m]=phih;
     phijj[m]=phih;
     PHIJProc(:,m-start)=phijj[m][];
     getRefModes(5,phih,ReftProc[m]);
     getRefModes(4,phih,RefmProc[m]);
     if(mpirank==0)
         cout<<"Done radiation potential "<<m<<endl;
 }

int[int] rcounts1=rcounts*WhBdy.ndof, dspls1=dspls*WhBdy.ndof;
mpiAllgatherv(PHIJProc,PHIJ,rcounts1,dspls1);
mpiAllReduce(RefmProc,Refm,mpiCommWorld,mpiSUM);
mpiAllReduce(ReftProc,Reft,mpiCommWorld,mpiSUM);

for(int m=0; m<nev; m++)
    phijj[m][]=PHIJ(:,m);

K.resize(nev,nev);
B.resize(nev,nev);
AB.resize(nev,nev);
F.resize(nev);
buildReducedSystemOptim;

if(mpirank==0){  
    writeReducedSystem;
}

solveReducedSystem;

Vh<complex> etax, etay, etaz, etaxProc, etayProc, etazProc;
Wh<complex> phi, phiProc;
for(int m=start; m<=stop; m++)
 {
     phiProc = phiProc + xi[m]*phij[m];
     etaxProc = etaxProc + xi[m]*VX[m];
     etayProc = etayProc + xi[m]*VY[m];
     etazProc = etazProc + xi[m]*VZ[m];
 }
mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);
mpiReduce(etazProc[],etaz[],processor(0),mpiSUM);


if(mpirank==0)
 {
     phi=phi+phi0;
     int[int] Order=[1,1,1], Order1=[1,1];
     savevtk(SolutionDir+"/sol1_"+iter+".vtu",ThIce,[real(etax),real(etay),real(etaz)],[imag(etax),imag(etay),imag(etaz)], dataname="ReDisp ImDisp",order=Order);
     savevtk(SolutionDir+"/solCavity"+iter+".vtu",ThCavity,[real(phi),imag(phi),abs(phi)],dataname="Phi",order=Order1);

     complex RefR;
     getRefCoeff(4,phi,RefR);
     complex RefT;
     getRefModes(5,phi,RefT);

     cout<<RefR<<"\t"<<RefT<<endl;
     cout.precision(8);
     cout<<"Reflection Coefficient = "<<(abs(RefR)^2+abs(RefT)^2)<<endl;
 }
