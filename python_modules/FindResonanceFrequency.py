#######################################################################
# Python script to compute the resonance frequency
# Run:
#          python3 FindResonaceFrequency.py ICEBERG_COMPLEX/
#
# Implement the Newton-Raphson method to find the resonance frequency.
#
# Running notes:
#         Before running, obtain the paths for mpirun and FreeFem++-mpi
#         Open terminal and run
#                   which mpirun
#                   which FreeFem++-mpi
#         Append the results into the cmd variable inside the for loop. The same can be done
#         using a bash script and then ignoring the for-loop part in this code completely.
#
###


import numpy as np
from modules.interpolateFreq import *
import cplot
import matplotlib.pyplot as plt
from os import system
import sys
import math
# Import eigenvalue related function
from scipy.linalg import eig

pi = np.pi

# Function to solve a single frequency domain problem
def solve_one_ice_problem(omega):
    print(('Solving problem for frequency '+str(omega)))
    cmd = ('/opt/homebrew/bin/mpirun -np 2 /usr/local/ff++/mpich3/bin/FreeFem++-mpi '
           '-v 0 iceshelf2d.edp -N 12 -omegar '+str(omega.real)+' -omegai '+str(omega.imag)+
           ' -Youngs 2e9 -L 3630 -H 500 -h 280 -nev 10 -iter 0 -solDir '
           'ICEBERG_COMPLEX/ -hsize 0.01 -isSplit 1 > /dev/null')
    system(cmd)
    H = read_H_matrix()
    return H

# Function to read the H-matrix generated by the script
def read_H_matrix():
    HRe = np.genfromtxt("ICEBERG_COMPLEX/2_ModesMatrix/ReH0.dat")
    HIm = np.genfromtxt("ICEBERG_COMPLEX/2_ModesMatrix/ImH0.dat")
    H = HRe + 1j*HIm
    Nev = int(np.sqrt(np.size(H)))
    H = np.reshape(H, (Nev,Nev), order='F')
    return H

f = 0.115
omega0 = 2*pi*f + 1j*0
tol = 1e-7
def computeResonanceFrequency(f, omega0, tol, ind):
    count = 1
    dw = 1e-6
    omega0s = []
    while (abs(dw)/abs(omega0) > tol) and (np.isinf(dw) == 0):
        H0 = solve_one_ice_problem(omega0)
        H1 = solve_one_ice_problem(omega0 + dw)

        dH = (H1-H0)/dw
        domega, dwvec = eig(H0, -dH)
        dw = domega[np.argmin(abs(domega)/abs(omega0))]
        print(dw)
        if (np.isinf(abs(dw)/abs(omega0)) == 0):
            omega0 = omega0 + dw
            omega0s.append(omega0)

            omega0s = np.array(omega0s)
    np.savetxt("ICEBERG_COMPLEX/step_roots_real"+str(ind)+".txt", omega0s.real, delimiter="\t", newline="\n")
    np.savetxt("ICEBERG_COMPLEX/step_roots_imag"+str(ind)+".txt", omega0s.imag, delimiter="\t", newline="\n")

#### Load the computed complex plots and superimpose the path of the root finding algorithm
a = 2*pi*0.01
b = 2*pi*0.125
c = -0.08
d = 0.08
npts = 11 # Old frequency space
NModes = 3
nptsNew = 200
xq = np.linspace(a,b,nptsNew)
yq = np.linspace(c,d,nptsNew)
Xq,Yq = np.meshgrid(xq, yq)
omeganew = Xq + 1j*Yq
interpolateCoeffsFreqComplex(a, b, c, d, npts, 10, "ICEBERG_COMPLEX/2_ModesMatrix/", nptsNew)
LAM = buildLam("ICEBERG_COMPLEX/")
interpolateRefCoeffComplex(a, b, c, d, npts, 10, "ICEBERG_COMPLEX/2_RefCoeff/", "C", nptsNew, NModes)
RC = buildRMat(LAM, "ICEBERG_COMPLEX/", "C", 0)
RT = buildRMat(LAM, "ICEBERG_COMPLEX/", "T", 0)

## Generate them using the function first
omega0s1 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real_1.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag_1.txt")
omega0s2 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real_2.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag_2.txt")
omega0s3 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real_3.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag_3.txt")

plt.figure(figsize=[10,4])
ax=plt.subplot(2,1,1)
genComplexPlot(RC, omeganew/(2*pi))
plt.scatter(omega0s1.real[0]/(2*pi), omega0s1.imag[0]/(2*pi), color='blue')
plt.scatter(omega0s1.real/(2*pi), omega0s1.imag/(2*pi), alpha=0.5, color='black', s=20)
plt.scatter(omega0s2.real[0]/(2*pi), omega0s2.imag[0]/(2*pi), color='blue')
plt.scatter(omega0s2.real/(2*pi), omega0s2.imag/(2*pi), alpha=0.5, color='black', s=20)
plt.scatter(omega0s3.real[0]/(2*pi), omega0s3.imag[0]/(2*pi), color='blue')
plt.scatter(omega0s3.real/(2*pi), omega0s3.imag/(2*pi), alpha=0.5, color='black', s=20)

ax=plt.subplot(2,1,2)
genComplexPlot(RT, omeganew/(2*pi))
plt.scatter(omega0s1.real[0]/(2*pi), omega0s1.imag[0]/(2*pi), color='blue')
plt.scatter(omega0s1.real/(2*pi), omega0s1.imag/(2*pi), alpha=0.5, color='white', s=20)
plt.scatter(omega0s2.real[0]/(2*pi), omega0s2.imag[0]/(2*pi), color='blue')
plt.scatter(omega0s2.real/(2*pi), omega0s2.imag/(2*pi), alpha=0.5, color='white', s=20)
plt.scatter(omega0s3.real[0]/(2*pi), omega0s3.imag[0]/(2*pi), color='blue')
plt.scatter(omega0s3.real/(2*pi), omega0s3.imag/(2*pi), alpha=0.5, color='white', s=20)

plt.show()
