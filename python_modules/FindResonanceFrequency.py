#######################################################################
# Python script to compute the resonance frequency
# Run:
#          python3 FindResonaceFrequency.py ICEBERG_COMPLEX/
#
# Implement the Newton-Raphson method to find the resonance frequency.
#
# Running notes:
#         Before running, obtain the paths for mpirun and FreeFem++-mpi
#         Open terminal and run
#                   which mpirun
#                   which FreeFem++-mpi
#         Append the results into the cmd variable inside the for loop. The same can be done
#         using a bash script and then ignoring the for-loop part in this code completely.
#
###


import numpy as np
from modules.interpolateFreq import *
import cplot
import matplotlib.pyplot as plt
from os import system
import sys
import math
# Import eigenvalue related function
from scipy.linalg import eig
from scipy.signal import find_peaks

pi = np.pi

# Function to solve a single frequency domain problem
def solve_one_ice_problem(E, omega):
    print(('Solving problem for frequency '+str(omega)))
    solveFreeFemProblem('iceshelf2d.edp', 3630, 500, 280, 12, omega, E, 10, '0', 'ICEBERG_COMPLEX/', 0.01, 1)
    H = read_H_matrix('0')
    return H

# Function to read the H-matrix generated by the script
def read_H_matrix():
    HRe = np.genfromtxt("ICEBERG_COMPLEX/2_ModesMatrix/ReH0.dat")
    HIm = np.genfromtxt("ICEBERG_COMPLEX/2_ModesMatrix/ImH0.dat")
    H = HRe + 1j*HIm
    Nev = int(np.sqrt(np.size(H)))
    H = np.reshape(H, (Nev,Nev), order='F')
    return H

def computeResonanceFrequency(E, omega0, tol, ind):
    count = 1
    dw = 1e-6
    omega0s = [omega0]
    while (abs(dw)/abs(omega0) > tol) and (np.isinf(dw) == 0):
        H0 = solve_one_ice_problem(E, omega0)
        H1 = solve_one_ice_problem(E, omega0 + dw)

        dH = (H1-H0)/dw
        domega, dwvec = eig(H0, -dH)
        dw = domega[np.argmin(abs(domega)/abs(omega0))]
        print(dw)
        if (np.isinf(abs(dw)/abs(omega0)) == 0):
            omega0 = omega0 + dw
            omega0s.append(omega0)

    omega0s = np.array(omega0s)
    np.savetxt("ICEBERG_COMPLEX/step_roots_real"+str(ind)+".txt", omega0s.real, delimiter="\t", newline="\n")
    np.savetxt("ICEBERG_COMPLEX/step_roots_imag"+str(ind)+".txt", omega0s.imag, delimiter="\t", newline="\n")
    return omega0s

#### Load the computed complex plots and superimpose the path of the root finding algorithm
a = 2*pi*0.01
b = 2*pi*0.125
c = -0.08
d = 0.08
npts = 11 # Old frequency space
NModes = 3
nptsNew = 300
xq = np.linspace(a,b,nptsNew)
yq = np.linspace(c,d,nptsNew)
Xq,Yq = np.meshgrid(xq, yq)
omeganew = Xq + 1j*Yq
interpolateCoeffsFreqComplex(a, b, c, d, npts, 10, "ICEBERG_COMPLEX/2_ModesMatrix/", nptsNew)
LAM = buildLam("ICEBERG_COMPLEX/")
interpolateRefCoeffComplex(a, b, c, d, npts, 10, "ICEBERG_COMPLEX/2_RefCoeff/", "C", nptsNew, NModes)
interpolateRefCoeffComplex(a, b, c, d, npts, 10, "ICEBERG_COMPLEX/2_RefCoeff/", "T", nptsNew, NModes)
RC = buildRMat(LAM, "ICEBERG_COMPLEX/", "C", 0)
RT = buildRMat(LAM, "ICEBERG_COMPLEX/", "T", 0)

## Generate them using the function first
#omega0s0 = computeResonanceFrequency(2e9, 2*pi*0.012 + 0*1j, 1e-7, 0)
#omega0s1 = computeResonanceFrequency(2e9, 2*pi*0.022 + 0*1j, 1e-7, 1)
#omega0s2 = computeResonanceFrequency(2e9, 2*pi*0.051 + 0*1j, 1e-7, 2)
#omega0s3 = computeResonanceFrequency(2e9, 2*pi*0.115 + 0*1j, 1e-7, 3)

omega0s0 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real0.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag0.txt")
omega0s1 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real1.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag1.txt")
omega0s2 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real2.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag2.txt")
omega0s3 = np.genfromtxt("ICEBERG_COMPLEX/step_roots_real3.txt") + 1j*np.genfromtxt("ICEBERG_COMPLEX/step_roots_imag3.txt")

plt.figure(figsize=[11.4,9])
ax=plt.subplot(3,1,1)
genComplexPlot(RC, omeganew/(2*pi))
plt.scatter(omega0s0.real[0]/(2*pi), omega0s0.imag[0]/(2*pi), color='red', s=50, marker='^')
plt.scatter(omega0s0.real/(2*pi), omega0s0.imag/(2*pi), alpha=0.2, color='red', s=15)
plt.scatter(omega0s0.real[-1]/(2*pi), omega0s0.imag[-1]/(2*pi), color='red', s=50, marker='x')
plt.scatter(omega0s1.real[0]/(2*pi), omega0s1.imag[0]/(2*pi), color='blue', s=50, marker='^')
plt.scatter(omega0s1.real/(2*pi), omega0s1.imag/(2*pi), alpha = 0.2, color='blue', s=15)
plt.scatter(omega0s1.real[-1]/(2*pi), omega0s1.imag[-1]/(2*pi), color='blue', s=50, marker='x')
plt.scatter(omega0s2.real[0]/(2*pi), omega0s2.imag[0]/(2*pi), color='yellow', s=50, marker='^')
plt.scatter(omega0s2.real/(2*pi), omega0s2.imag/(2*pi), alpha=0.2, color='yellow', s=15)
plt.scatter(omega0s2.real[-1]/(2*pi), omega0s2.imag[-1]/(2*pi), color='yellow', s=50, marker='x')
plt.scatter(omega0s3.real[0]/(2*pi), omega0s3.imag[0]/(2*pi), color='magenta', s=50, marker='^')
plt.scatter(omega0s3.real/(2*pi), omega0s3.imag/(2*pi), alpha=0.2, color='magenta', s=15)
plt.scatter(omega0s3.real[-1]/(2*pi), omega0s3.imag[-1]/(2*pi), color='magenta', s=50, marker='x')


ax=plt.subplot(3,1,2)
genComplexPlot(RT, omeganew/(2*pi))
plt.scatter(omega0s0.real[0]/(2*pi), omega0s0.imag[0]/(2*pi), color='red', s=50, marker='^')
plt.scatter(omega0s0.real/(2*pi), omega0s0.imag/(2*pi), alpha=0.2, color='red', s=15)
plt.scatter(omega0s0.real[-1]/(2*pi), omega0s0.imag[-1]/(2*pi), color='red', s=50, marker='x')
plt.scatter(omega0s1.real[0]/(2*pi), omega0s1.imag[0]/(2*pi), color='blue', s=50, marker='^')
plt.scatter(omega0s1.real/(2*pi), omega0s1.imag/(2*pi), alpha = 0.2, color='blue', s=15)
plt.scatter(omega0s1.real[-1]/(2*pi), omega0s1.imag[-1]/(2*pi), color='blue', s=50, marker='x')
plt.scatter(omega0s2.real[0]/(2*pi), omega0s2.imag[0]/(2*pi), color='yellow', s=50, marker='^')
plt.scatter(omega0s2.real/(2*pi), omega0s2.imag/(2*pi), alpha=0.2, color='yellow', s=15)
plt.scatter(omega0s2.real[-1]/(2*pi), omega0s2.imag[-1]/(2*pi), color='yellow', s=50, marker='x')
plt.scatter(omega0s3.real[0]/(2*pi), omega0s3.imag[0]/(2*pi), color='magenta', s=50, marker='^')
plt.scatter(omega0s3.real/(2*pi), omega0s3.imag/(2*pi), alpha=0.2, color='magenta', s=15)
plt.scatter(omega0s3.real[-1]/(2*pi), omega0s3.imag[-1]/(2*pi), color='magenta', s=50, marker='x')

#plt.show()
#plt.savefig("ResPath.pdf", bbox_inches='tight')

###### Compare with location of peaks in real axis
ax=plt.subplot(3,1,3)
dispVsFreq = np.loadtxt('ICEBERG1/dispVsFreq2GPa.dat')
strainVsFreq = np.loadtxt('ICEBERG1/strainVsFreq2GPa.dat')
omeganew = 2*pi*np.linspace(0.01, 0.125, len(dispVsFreq))

# Displacement
plt.semilogy(omeganew/(2*pi), strainVsFreq[:,0],label='$\epsilon_{xx}$')
plt.semilogy(omeganew/(2*pi), strainVsFreq[:,1],label='$\epsilon_{yy}$')
plt.semilogy(omeganew/(2*pi), strainVsFreq[:,2],label='$\epsilon_{xy}$')
peaks0, _ = find_peaks(strainVsFreq[:,0], prominence=1e-6)
plt.semilogy(omeganew[peaks0]/(2*pi), strainVsFreq[peaks0,0],"x")
peaks1, _ = find_peaks(strainVsFreq[:,1], prominence=1e-6)
plt.semilogy(omeganew[peaks1]/(2*pi), strainVsFreq[peaks1,1],"x")
peaks2, _ = find_peaks(strainVsFreq[:,2], prominence=1e-6)
plt.semilogy(omeganew[peaks2]/(2*pi), strainVsFreq[peaks2,2],"x")
plt.legend()
plt.xlabel("$\omega/2\pi$", usetex=True)
plt.ylabel("$||\epsilon_{xx}||_{\infty}\;\;\\mathrm{or}\;\;||\epsilon_{yy}||_{\infty}\;\;\\mathrm{or}\;\;||\epsilon_{xy}||_{\infty}$", usetex=True)
plt.xlim(omeganew[0]/2/pi, omeganew[-1]/2/pi)
plt.savefig("ResPath.pdf", bbox_inches='tight')
plt.show()
