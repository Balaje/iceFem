//Program to compare the execution time with and without domain decompositition solution.
//Program simple5.edp solves the problem with domain decomposition.
/*
  In this program the interior nodes are eliminated by constructing a boundary mesh
  and interpolating between the boundary meshes alone.
*/

verbosity=0.;
real cpu=mpiWtime();
bool debug=true;
load "iovtk"

include "macros.idp"

macro Sigma(u,v)[2*muhat*dx(u)+lambdahat*(dx(u)+dy(v)),
                 2*muhat*dy(v)+lambdahat*(dx(u)+dy(v)),
                 muhat*(dy(u)+dx(v))]//EOM (Macro to define the stress tensor)"

nev=64;
setProblem;

solveDispersion;

real botRight=-3.*tth, midPX=3.7*LL/4, midPY=-2.5*tth;
setMeshIce(botRight, midPX, midPY);
real midx=LL/2., midy=-0.5*HH, endy=-HH;
setMeshCav(midx, midy, endy);

refineMesh;

Xh[int][VX,VY](nev); //Define an array of fe-function to store in-vacuo modes.
real[int] ev(nev); //Define a real array for the eigenvalues.
solveEigen;

//  2) Get the Non-local boundary condition
matrix<complex> MQ;
complex[int] ctilde(NModes+1);
Wh<complex> chi1;
MQ=getQphi(ThCavity,NModes,k,kd,HH,dd,Ap,4);
ctilde=getChi(ThCavity,NModes,k,kd,HH,dd,Ap);
for(int m=0; m<NModes+1; m++)
  chi1 = chi1+ctilde[m]*cos(kd[m]*(y+HH))/cos(kd[m]*(HH-dd));

//  3) Solve for the diffraction potential.
Wh<complex> phi0;
func fh=chi1;//Store in fh, the right-hand side function on the ocean-cavity interface.
getLaplaceMat(0,0);
LHS=STIMA+(MQ);
set(LHS,solver=UMFPACK,eps=1e-20);
phih[]=LHS^-1*RHS[];
phi0=phih;//Store in phi0;


//Different algorithm without splitting the mesh,
int parti = nev/mpisize;
Wh<complex>[int] phij(nev);
getInterpMatrices;
real cpu1=mpiWtime();
buildReducedSystemNoSplit(getLaplaceMat);
cout<<"No of vertices: "<<ThIce.nv<<"\t Time in processor "<<mpirank<<" = "<<mpiWtime()-cpu1<<"\t s"<<endl;

complex[int] xi(nev);
if(mpirank==0){
  matrix<complex> Kmat, Bmat, ABmat;
  Kmat=K;
  Bmat=B;
  ABmat=AB;
  HHmat=Kmat+Bmat+ABmat;
  set(HHmat,solver=UMFPACK,eps=1e-20);
  xi=HHmat^-1*F;  
 }
broadcast(processor(0),xi);

//Compute the solution.
Vh <complex> etax, etay, etaxProc, etayProc;
Wh<complex> phi, phiProc;
for(int m=mpirank*parti; m<mpirank*parti+parti; m++)
  {
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
  }

mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0){
  //Compute the reflection coefficient.
  phi=phi+phi0;
  complex[int] phiVec(phi.n), c(NModes+1);
  phiVec = phi[]; //Get the vector form of the finite element function.
  complex Ref = getRefCoeff(ThCavity, NModes, kd, k, phiVec, HH, dd, Ap, c); //From "refCoeff.idp"
  cout.precision(16);
  cout<<"Reflection Coefficient = "<<Ref<<endl<<"|R| = "<<abs(Ref)<<endl;
  cout<<"Total Time = "<<mpiWtime()-cpu<<endl;

  int[int] Order=[1,1];
  savevtk("1_SIMPLE6/sol1_"+iter+".vtk",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
  savevtk("1_SIMPLE6/sol2_"+iter+".vtk",ThIce,[real(Sigma(etax,etay)[0]), real(Sigma(etax,etay)[1]), real(Sigma(etax,etay)[2])],[imag(Sigma(etax,etay)[0]), imag(Sigma(etax,etay)[1]), imag(Sigma(etax,etay)[2])],dataname="ReSigma ImSigma",order=Order);
  
  savevtk("1_SIMPLE6/solCavity"+iter+".vtk",ThCavity,[real(phi),imag(phi)],dataname="RePhi ImPhi",order=Order);    
 }
