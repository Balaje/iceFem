//Example to solve the iceberg problem

verbosity=0;
macro dimension 2//EOM"
macro fspace 2//EOM"

include "macros.idp"

SolutionDir="2_ICEBERG/";

setProblem;

solveDispersion;

int N1=getARGV("-N1",4);
int[int] lbl=[3,1,1,1];
ThIce=square(LL/tth*N1,N1,[LL*x,-dd+tth*y],label=lbl);
int N2=getARGV("-N2",4);
lbl=[1,5,3,4];
ThCavity=square(LL/(HH-dd)*N2,N2,[LL*x,-HH+(HH-dd)*y],label=lbl);

Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
writeEigen(1,1);

Wh<complex> chi1;
matrix<complex> MQ1,MQ2;
getQphi(5,MQ2); //Outlet
getQphi(4,MQ1);
getChi(chi1);

splitMesh(isSplit);

Wh<complex> phi0;
WhBdy<complex> phi00;
func fh=chi1;
getLaplaceMat(0,0,0);
LHS=STIMA+(MQ1)+(MQ2);
set(LHS,solver=sparsesolver);
phih[]=LHS^-1*RHS[];
phi0=phih;
phi00=phi0;
{
    ofstream file1(SolutionDir+"2_RefCoeff/RefCoeff_Dif/refC"+iter+".dat");
    complex Ref;
    getRefCoeff(4,phi0,Ref);
    file1<<real(Ref)<<"\t"<<imag(Ref)<<endl;
}
{
    ofstream file1(SolutionDir+"2_RefCoeff/RefCoeff_Dif/refT"+iter+".dat");
    complex Ref;
    getRefModes(5,phi0,Ref);
    file1<<real(Ref)<<"\t"<<imag(Ref)<<endl;
}
//savevtk(SolutionDir+"2_Potential/solDif.vtu",ThCavity,real(phi0),dataname="RePhi");

Wh<complex> [int] phij(nev);
WhBdy<complex>[int] phijj(nev);
buildParti(nev);
complex[int,int] PHIJ(WhBdy.ndof,nev), PHIJProc(WhBdy.ndof,partisize);
complex[int] Refm(nev), RefmProc(nev), Reft(nev), ReftProc(nev);
for(int m=start; m<=stop; m++)
{
    func fh=0;
    getLaplaceMat(VX[m],VY[m],0);
    LHS=STIMA+(MQ1)+(MQ2);
    set(LHS,solver=sparsesolver);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    phijj[m]=phih;
    PHIJProc(:,m-start)=phijj[m][];
    getRefModes(5,phih,ReftProc[m]);
    getRefModes(4,phih,RefmProc[m]);
    if(mpirank==0){
        cout<<"Done Radiation Potential " <<m<<endl;
    }
}

int[int] rcounts1=rcounts*WhBdy.ndof, dspls1=dspls*WhBdy.ndof;
mpiAllgatherv(PHIJProc,PHIJ,rcounts1,dspls1);
mpiAllReduce(RefmProc,Refm,mpiCommWorld,mpiSUM);
mpiAllReduce(ReftProc,Reft,mpiCommWorld,mpiSUM);

for(int m=0; m<nev; m++)
    phijj[m][]=PHIJ(:,m);

buildReducedSystemOptim;

if(mpirank==0){  
    writeReducedSystem;
}

solveReducedSystem;

Vh<complex> etax, etay, etaz, etaxProc, etayProc, etazProc;
Wh<complex> phi, phiProc;
for(int m=start; m<=stop; m++)
{
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
}
mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0)
{
    phi=phi+phi0;
    int[int] Order1=[1,1,1],Order=[1,1];
    savevtk(SolutionDir+"/sol1_"+iter+".vtu",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
    savevtk(SolutionDir+"/solCavity"+iter+".vtu",ThCavity,[real(phi),imag(phi),abs(phi)],dataname="Phi",order=Order1);

    complex RefT;
    getRefModes(5,phi,RefT);
    complex RefR;
    getRefCoeff(4,phi,RefR);
    
    cout<<RefR<<"\t"<<RefT<<endl;
    cout.precision(8);
    cout<<"Reflection Coefficient = "<<(abs(RefR)^2+abs(RefT)^2)<<endl;
    ofstream file(SolutionDir+"2_RefCoeff/rc"+iter+".dat");
    file<<real(RefR)<<"\t"<<imag(RefR)<<"\t"<<real(RefT)<<"\t"<<imag(RefT)<<endl;
}
