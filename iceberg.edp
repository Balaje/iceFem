//Example to solve the iceberg problem

verbosity=0;
macro dimension 2//EOM"
macro fspace 2//EOM"

include "macros.idp"

SolutionDir=getARGV("-SolDir","1_ICEBERG/");

setProblem;

real draft1=-0.9*tth, free1=0.1*tth;
real draft2=-0.9*tth, free2=0.1*tth;
real HH1=-HH, HH2=-HH;
setLinearThickeningIce(draft1,draft2,free1,free2);
setLinearThickeningCavity(HH1,HH2,draft1,draft2);

refineMesh;

//Change numbering.
int[int] lbl=[3,3,2,1,1,1,1,1]; 
ThIce=change(ThIce,label=lbl);
lbl=[1,1,6,5,3,3,4,4];
ThCavity=change(ThCavity,label=lbl);


Xh[int][VX,VY](nev);
real[int] ev(nev);
solveEigen;
writeEigen(1,1);

Wh<complex> chi1;
matrix<complex> MQ1,MQ2;
dd=abs(draft2);
HH=abs(HH2);
solveDispersion;
getQphi(5,MQ2); //Outlet

dd=abs(draft1);
HH=abs(HH1);
solveDispersion;
getQphi(4,MQ1);
getChi(chi1);

splitMesh(isSplit);

Wh<complex> phi0;
WhBdy<complex> phi00;
func fh=chi1;
getLaplaceMat(0,0,0);
LHS=STIMA+(MQ1)+(MQ2);
set(LHS,solver=sparsesolver);
phih[]=LHS^-1*RHS[];
phi0=phih;
phi00=phi0;

dd=abs(draft1);
HH=abs(HH1);
solveDispersion;
getRefCoeff(4,phi0,RefC);
dd=abs(draft2);
HH=abs(HH2);
solveDispersion;
getRefModes(5,phi0,RefT);

//savevtk(SolutionDir+"2_Potential/solDif.vtu",ThCavity,real(phi0),dataname="RePhi");

Wh<complex> [int] phij(nev);
WhBdy<complex>[int] phijj(nev);
buildParti(nev);
complex[int,int] PHIJ(WhBdy.ndof,nev), PHIJProc(WhBdy.ndof,partisize);
complex[int] RefmProc(nev), ReftProc(nev);
for(int m=start; m<=stop; m++)
{
    func fh=0;
    getLaplaceMat(VX[m],VY[m],0);
    LHS=STIMA+(MQ1)+(MQ2);
    set(LHS,solver=sparsesolver);
    phih[]=LHS^-1*RHS[];
    phij[m]=phih;
    phijj[m]=phih;
    PHIJProc(:,m-start)=phijj[m][];
    dd=abs(draft2);
    HH=abs(HH2);
    solveDispersion;
    getRefModes(5,phih,ReftProc[m]);
    dd=abs(draft1);
    HH=abs(HH1);
    solveDispersion;
    getRefModes(4,phih,RefmProc[m]);
    if(mpirank==0){
        cout<<"Done Radiation Potential " <<m<<endl;
    }
}

int[int] rcounts1=rcounts*WhBdy.ndof, dspls1=dspls*WhBdy.ndof;
mpiAllgatherv(PHIJProc,PHIJ,rcounts1,dspls1);
mpiAllReduce(RefmProc,Refc,mpiCommWorld,mpiSUM);
mpiAllReduce(ReftProc,Reft,mpiCommWorld,mpiSUM);

for(int m=0; m<nev; m++)
    phijj[m][]=PHIJ(:,m);

buildReducedSystemOptim;

if(mpirank==0){  
    writeReducedSystem;
}

solveReducedSystem;

Vh<complex> etax, etay, etaz, etaxProc, etayProc, etazProc;
Wh<complex> phi, phiProc;
for(int m=start; m<=stop; m++)
{
    phiProc = phiProc + xi[m]*phij[m];
    etaxProc = etaxProc + xi[m]*VX[m];
    etayProc = etayProc + xi[m]*VY[m];
}
mpiReduce(phiProc[],phi[],processor(0),mpiSUM);
mpiReduce(etaxProc[],etax[],processor(0),mpiSUM);
mpiReduce(etayProc[],etay[],processor(0),mpiSUM);

if(mpirank==0)
{    
    phi=phi+phi0;
    int[int] Order1=[1,1,1],Order=[1,1];
    savevtk(SolutionDir+"/sol1_"+iter+".vtu",ThIce,[real(etax),real(etay)],[imag(etax),imag(etay)], dataname="ReDisp ImDisp",order=Order);
    savevtk(SolutionDir+"/solCavity"+iter+".vtu",ThCavity,[real(phi),imag(phi),abs(phi)],dataname="Phi",order=Order1);

    complex RefR;
    dd=abs(draft1);
    HH=abs(HH1);    
    solveDispersion;
    getRefCoeff(4,phi,RefR);
    
    complex RefT;
    dd=abs(draft2);
    HH=abs(HH2);        
    solveDispersion;  
    getRefModes(5,phi,RefT);    
    
    cout<<RefR<<"\t"<<RefT<<endl;
    cout.precision(8);
    cout<<"Reflection Coefficient = "<<sqrt(abs(RefR)^2+abs(RefT)^2)<<endl;
    ofstream file(SolutionDir+"2_RefCoeff/rc"+iter+".dat");
    file<<real(RefR)<<"\t"<<imag(RefR)<<"\t"<<real(RefT)<<"\t"<<imag(RefT)<<endl;
}
